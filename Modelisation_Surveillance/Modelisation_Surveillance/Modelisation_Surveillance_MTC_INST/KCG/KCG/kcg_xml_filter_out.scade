/* $********** SCADE Suite KCG 64-bit 6.6 (build i19) ***********
** Command: kcg66_x64.exe -config J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/KCG/config.txt
** Generation date: 2020-02-07T16:46:45
*************************************************************$ */

/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator1.xscade */
node Controller(
    Sensor_Temperature : Data;
    Sensor_pH : Data;
    Sensor_Redox : Data;
    Sensor_GPS : position;
    Time : float64;
    Stop : bool;
    Frequency : float64)
  returns (Send_Data : Statation_data; alarm : bool)
sig
  MTC_sig_def_1, MTC_sig_def_3, MTC_sig_use_4, MTC_sig_def_5, MTC_sig_def_7,
  MTC_sig_fire_9, MTC_sig_10, MTC_sig_11;
var
  store
  : Ten_Values_Table
  last = #1 MTCEx::MTC_Instrumenters::Controller_store_last_MTC_INST(#35
    not 'MTC_sig_def_3 #12 or
    'MTC_sig_use_4, true);
  Store_Time
  : float64
  default = #1 MTCEx::MTC_Instrumenters::Controller_Store_Time_def_MTC_INST(#36
    not 'MTC_sig_def_5 #33 and
    MTC_AC_Outputs, true);
  timeout
  : bool
  default = #1 MTCEx::MTC_Instrumenters::Controller_timeout_def_MTC_INST(#37
    not 'MTC_sig_def_7 #34 and
    MTC_AC_Outputs, true);
  MTC_Send_Data
  : Statation_data
  default = #1
  MTCEx::MTC_Instrumenters::Controller_MTC_Send_Data_def_MTC_INST(#38
    not 'MTC_sig_def_1 #35 and
    MTC_AC_Outputs, true);
  MTC_AC_Outputs : bool;
let

  automaton SM1
    initial state Normal_Station
      var
        notif : bool;
        MTC_CC_1 : bool;
        MTC_CC_2 : bool;
        MTC_AC_2 : bool;
        MTC_AC_3 : bool;
        MTC_AC_4 : bool;
        MTC_AC_5 : bool;
        MTC_AC_6 : bool;
        MTC_AC_7 : bool;
        MTC_AC_8 : bool;
        MTC_AC_9 : bool;
        MTC_AC_10 : bool;
        MTC_AC_11 : bool;
        MTC_CC_18_A : bool;
        MTC_CC_19_T : bool;
        MTC_CC_20_F : bool;
        MTC_CC_21_T : bool;
        MTC_CC_22_F : bool;
        MTC_CC_23_A : bool;
        MTC_CC_24_T : bool;
        MTC_CC_25_F : bool;
        MTC_CC_26_T : bool;
        MTC_CC_27_F : bool;
        MTC_CC_28_T : bool;
        MTC_CC_29_F : bool;
        MTC_AC_40 : bool;
        MTC_AC_41 : bool;
        _L1 : Data;
        _L2 : Data;
        _L3 : Data;
        _L7 : float64;
        _L6 : float64;
        _L5 : float64;
        _L8 : bool;
        _L9 : bool;
        _L10 : bool;
        _L11 : bool;
        _L12 : float64;
      let
        _L1= Sensor_Temperature;
        _L2= Sensor_pH;
        _L3= Sensor_Redox;
        _L5, _L6, _L7= #1 Vote_Alog(_L2, _L1, _L3, MTC_AC_4, true);
        notif= _L8;
        _L8= _L9 #1 or _L10 #1 or _L11;
        _L9= _L5 #1 = _L12;
        _L10= _L6 #2 = _L12;
        _L11= _L12 #3 = _L7;
        _L12= Notification_Defaillance;
        alarm= _L8;
        MTC_CC_1= true;
        MTC_CC_2= #1 not 'MTC_sig_fire_9;
        ()= #1 MTCEx::MTC_Observers::STATE_MTC_OBS(MTC_CC_1, MTC_CC_2, true);
        MTC_AC_2= false #3 or 'MTC_sig_10;
        MTC_AC_3= MTC_AC_5 #4 or MTC_AC_2;
        MTC_AC_4= MTC_AC_41;
        MTC_AC_5= true;
        MTC_AC_6= #2 not _L10 #1 and #3 not _L11;
        MTC_AC_7= #4 not _L9 #2 and #5 not _L11;
        MTC_AC_8= #6 not _L9 #3 and #7 not _L10;
        MTC_AC_9= MTC_AC_6 #4 and MTC_AC_3;
        MTC_AC_10= MTC_AC_7 #5 and MTC_AC_3;
        MTC_AC_11= MTC_AC_8 #6 and MTC_AC_3;
        MTC_CC_18_A= MTC_AC_2;
        MTC_CC_19_T= _L8 #7 and MTC_AC_2;
        MTC_CC_20_F= #8 not _L8 #8 and MTC_AC_2;
        MTC_CC_21_T= _L8 #9 and MTC_AC_5;
        MTC_CC_22_F= #9 not _L8 #10 and MTC_AC_5;
        MTC_CC_23_A= MTC_AC_3;
        MTC_CC_24_T= _L9 #11 and MTC_AC_9;
        MTC_CC_25_F= #10 not _L9 #12 and MTC_AC_9;
        MTC_CC_26_T= _L10 #13 and MTC_AC_10;
        MTC_CC_27_F= #11 not _L10 #14 and MTC_AC_10;
        MTC_CC_28_T= _L11 #15 and MTC_AC_11;
        MTC_CC_29_F= #12 not _L11 #16 and MTC_AC_11;
        ()=
          #1 MTCEx::MTC_Observers::Controller_PATHS9_MTC_OBS(MTC_CC_18_A,
            MTC_CC_19_T, MTC_CC_20_F, true);
        ()=
          ( activate #1
          MTCEx::MTC_Observers::Vote_Alog_111_MTC_OBS every MTC_AC_4 default ())(_L2,
            _L1, _L3, true);
        ()=
          #1 MTCEx::MTC_Observers::Controller_PATHS10_MTC_OBS(MTC_CC_21_T,
            MTC_CC_22_F, true);
        ()=
          #1 MTCEx::MTC_Observers::Controller_PATHS11_MTC_OBS(MTC_CC_23_A,
            MTC_CC_24_T, MTC_CC_25_F, MTC_CC_26_T, MTC_CC_27_F, MTC_CC_28_T,
            MTC_CC_29_F, true);
        MTC_AC_40= MTC_AC_5 #5 or MTC_AC_2;
        MTC_AC_41= MTC_AC_40 #6 or MTC_AC_40 #6 or MTC_AC_40;
      tel
      until
        if #1
        MTCEx::MTC_Instrumenters::Controller_SM1_Normal_Station_1_MTC_INST(notif,
          #13 not false, true)
          do var
            MTC_CC_4 : bool;
          let
            emit 'MTC_sig_fire_9;
            MTC_CC_4= true;
            ()= #1 MTCEx::MTC_Observers::TRANSITION_MTC_OBS(MTC_CC_4, true);
          tel resume Defaillance_Station;
        if #1
        MTCEx::MTC_Instrumenters::Controller_SM1_Normal_Station_2_MTC_INST(notif,
          #14 not notif, true)
          do var
            MTC_CC_3 : bool;
          let
            emit 'MTC_sig_fire_9;
            MTC_CC_3= true;
            ()= #2 MTCEx::MTC_Observers::TRANSITION_MTC_OBS(MTC_CC_3, true);
          tel resume Calculate;

    state Defaillance_Station
      var
        MTC_CC_5 : bool;
        MTC_CC_6 : bool;
      let
        MTC_CC_5= true;
        MTC_CC_6= #15 not 'MTC_sig_fire_9;
        ()= #2 MTCEx::MTC_Observers::STATE_MTC_OBS(MTC_CC_5, MTC_CC_6, true);
      tel

    state Calculate
      var
        MTC_CC_7 : bool;
        MTC_CC_8 : bool;
        MTC_AC_16 : bool;
        MTC_AC_17 : bool;
        MTC_AC_18 : bool;
        MTC_AC_19 : bool;
        MTC_AC_20 : bool;
        MTC_AC_21 : bool;
        MTC_AC_22 : bool;
        MTC_AC_23 : bool;
        MTC_AC_24 : bool;
        MTC_AC_25 : bool;
        MTC_AC_26 : bool;
        MTC_AC_27 : bool;
        MTC_AC_28 : bool;
        MTC_AC_29 : bool;
        MTC_AC_36 : bool;
        MTC_CC_32_T : bool;
        MTC_CC_33_F : bool;
        MTC_CC_34_T : bool;
        MTC_CC_35_F : bool;
        MTC_CC_36_T : bool;
        MTC_CC_37_F : bool;
        MTC_CC_38_A : bool;
        MTC_AC_42 : bool;
        MTC_AC_43 : bool;
        _L9 : float64;
        _L8 : Data;
        _L7 : position;
        _L4 : float64;
        _L5 : float64;
        _L6 : float64;
        _L3 : Data;
        _L2 : Statation_data;
        _L1 : Data;
        _L14 : float64;
        _L13 : float64;
        _L12 : float64;
        _L15 : float64;
        _L16 : float64;
        _L18 : float64;
        _L19 : float64;
        _L20 : bool;
        _L21 : float64;
        _L22 : float64;
        _L23 : float64;
        _L24 : float64;
        _L25 : float64;
        _L26 : float64;
        _L27 : float64;
        _L28 : float64;
        _L42 : Ten_Values_Table;
        _L43 : float64;
        _L30 : bool;
        _L29 : bool;
        _L17 : bool;
      let
        _L1= Sensor_pH;
        _L2= (#3 make Statation_data)(_L5, _L4, _L6, _L7, _L9);
        _L3= Sensor_Redox;
        _L4, _L5, _L6= #3 Vote_Alog(_L1, _L8, _L3, MTC_AC_17, true);
        MTC_Send_Data= _L2;
        _L7= Sensor_GPS;
        _L8= Sensor_Temperature;
        _L9= Time;
        _L12, _L13, _L14= #1 Mean_10_Table(_L42, MTC_AC_23, true);
        _L15= _L12 #1 * _L16;
        _L16= 0.5;
        _L18= _L12 #1 - _L5;
        _L19, _= #1 math::Abs(_L18, MTC_AC_24, true);
        _L20= _L17 #2 or _L29 #2 or _L30;
        _L21= _L13 #2 * _L27;
        _L22= _L14 #3 * _L28;
        _L23= _L13 #2 - _L4;
        _L24= _L14 #3 - _L6;
        _L25, _= #2 math::Abs(_L23, MTC_AC_26, true);
        _L26, _= #3 math::Abs(_L24, MTC_AC_28, true);
        _L27= 0.5;
        _L28= 0.5;
        alarm= _L20;
        activate IfBlock1 if #1
          MTCEx::MTC_Instrumenters::Controller_SM1_Calculate_IfBlock1_MTC_INST(alarm,
            MTC_AC_Outputs, true)
          then var
            MTC_CC_30 : bool;
          let
            MTC_CC_30= MTC_AC_Outputs;
            ()= #2 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_30, true);
          tel
          else var
            MTC_CC_31 : bool;
            MTC_AC_12 : bool;
            MTC_AC_13 : bool;
            MTC_AC_14 : bool;
            MTC_AC_15 : bool;
            _L5 : Data;
            _L6 : Data;
            _L7 : Data;
            _L11 : float64;
            _L12 : float64;
            _L13 : float64;
            _L15 : Ten_Values_Table;
            _L19 : float64^(1 + 1 + 1);
            _L20 : float64^1;
            _L21 : float64^1;
            _L23 : float64^1;
            _L29 : Ten_Values_Table;
          let
            _L5= Sensor_Temperature;
            _L6= Sensor_pH;
            _L7= Sensor_Redox;
            _L11, _L12, _L13= #7 Vote_Alog(_L5, _L6, _L7, MTC_AC_14, true);
            _L15= #1 Push_Table(_L29, _L19, MTC_AC_13, true);
            _L19= _L20 #2 @ _L21 #2 @ _L23;
            _L20= (_L11)#1^1;
            _L21= (_L12)#2^1;
            _L23= (_L13)#4^1;
            store= _L15;
            _L29= last 'store;
            emit 'MTC_sig_def_3;
            MTC_CC_31= MTC_AC_Outputs;
            ()= #1 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_31, true);
            MTC_AC_12= true;
            MTC_AC_13= MTC_AC_12;
            MTC_AC_14= MTC_AC_13 #8 or MTC_AC_13 #7 or MTC_AC_13;
            MTC_AC_15= MTC_AC_13;
            emit 'MTC_sig_use_4 if MTC_AC_15;
            ()=
              ( activate #7
              MTCEx::MTC_Observers::Vote_Alog_111_MTC_OBS every MTC_AC_14 default ())(_L5,
                _L6, _L7, true);
            ()=
              ( activate #1
              MTCEx::MTC_Observers::Push_Table_11_MTC_OBS every MTC_AC_13 default ())(_L29,
                _L19, true);
          tel
        returns ..;
        _L42= last 'store;
        _L43= Time;
        Store_Time= _L43;
        _L30= _L22 #3 < _L26;
        _L29= _L21 #2 < _L25;
        _L17= _L15 #1 < _L19;
        emit 'MTC_sig_def_1;
        emit 'MTC_sig_def_5;
        MTC_CC_7= true;
        MTC_CC_8= #16 not 'MTC_sig_fire_9;
        ()= #3 MTCEx::MTC_Observers::STATE_MTC_OBS(MTC_CC_7, MTC_CC_8, true);
        MTC_AC_16= true;
        MTC_AC_17= MTC_AC_42;
        MTC_AC_18= true;
        MTC_AC_19= #17 not _L29 #17 and #18 not _L30;
        MTC_AC_20= #19 not _L17 #18 and #20 not _L30;
        MTC_AC_21= #21 not _L17 #19 and #22 not _L29;
        MTC_AC_22= MTC_AC_19 #20 and MTC_AC_18;
        MTC_AC_23= MTC_AC_43;
        MTC_AC_24= MTC_AC_22;
        MTC_AC_25= MTC_AC_20 #21 and MTC_AC_18;
        MTC_AC_26= MTC_AC_25;
        MTC_AC_27= MTC_AC_21 #22 and MTC_AC_18;
        MTC_AC_28= MTC_AC_27;
        MTC_AC_29= MTC_AC_23;
        emit 'MTC_sig_use_4 if MTC_AC_29;
        MTC_AC_36= false;
        MTC_CC_32_T= _L17 #23 and MTC_AC_22;
        MTC_CC_33_F= #23 not _L17 #24 and MTC_AC_22;
        MTC_CC_34_T= _L29 #25 and MTC_AC_25;
        MTC_CC_35_F= #24 not _L29 #26 and MTC_AC_25;
        MTC_CC_36_T= _L30 #27 and MTC_AC_27;
        MTC_CC_37_F= #25 not _L30 #28 and MTC_AC_27;
        MTC_CC_38_A= MTC_AC_36;
        ()=
          ( activate #3
          MTCEx::MTC_Observers::Vote_Alog_111_MTC_OBS every MTC_AC_17 default ())(_L1,
            _L8, _L3, true);
        ()=
          #1 MTCEx::MTC_Observers::Controller_PATHS13_MTC_OBS(MTC_CC_32_T,
            MTC_CC_33_F, MTC_CC_34_T, MTC_CC_35_F, MTC_CC_36_T, MTC_CC_37_F,
            true);
        ()=
          ( activate #1
          MTCEx::MTC_Observers::Mean_10_Table_1_MTC_OBS every MTC_AC_23 default ())(_L42,
            true);
        ()=
          ( activate #1
          MTCEx::MTC_Observers::math_Abs_MTC_OBS every MTC_AC_24 default ())(true);
        ()=
          ( activate #2
          MTCEx::MTC_Observers::math_Abs_MTC_OBS every MTC_AC_26 default ())(true);
        ()=
          ( activate #3
          MTCEx::MTC_Observers::math_Abs_MTC_OBS every MTC_AC_28 default ())(true);
        ()= #1 MTCEx::MTC_Observers::Controller_PATHS14_MTC_OBS(MTC_CC_38_A, true);
        MTC_AC_42=
          MTC_AC_16 #9 or MTC_AC_16 #9 or MTC_AC_16 #9 or MTC_AC_18 #9 or MTC_AC_18
          #9 or
          MTC_AC_18;
        MTC_AC_43=
          MTC_AC_18 #10 or MTC_AC_18 #10 or MTC_AC_18 #10 or MTC_AC_18 #10 or MTC_AC_18
          #10 or
          MTC_AC_18;
      tel
      until
        if #1
        MTCEx::MTC_Instrumenters::Controller_SM1_Calculate_1_MTC_INST(alarm, #26
          not false, true)
          do var
            MTC_CC_10 : bool;
          let
            emit 'MTC_sig_fire_9;
            MTC_CC_10= true;
            ()= #3 MTCEx::MTC_Observers::TRANSITION_MTC_OBS(MTC_CC_10, true);
          tel restart Pollution;
        if #2
        MTCEx::MTC_Instrumenters::Controller_SM1_Calculate_2_MTC_INST(alarm, #27
          not alarm, true)
          do var
            MTC_CC_9 : bool;
          let
            emit 'MTC_sig_fire_9;
            MTC_CC_9= true;
            ()= #4 MTCEx::MTC_Observers::TRANSITION_MTC_OBS(MTC_CC_9, true);
          tel restart Timer;

    state Pollution
      var
        MTC_CC_11 : bool;
        MTC_CC_12 : bool;
        MTC_AC_37 : bool;
        MTC_AC_38 : bool;
        MTC_CC_39_A : bool;
        MTC_CC_40_A : bool;
        MTC_CC_41_T : bool;
        MTC_CC_42_F : bool;
        _L1 : bool;
        _L2 : float64;
      let
        _L1= Stop;
        _L2= Frequency;
        _= _L2;
        _= _L1;
        MTC_CC_11= true;
        MTC_CC_12= #28 not 'MTC_sig_fire_9;
        ()= #4 MTCEx::MTC_Observers::STATE_MTC_OBS(MTC_CC_11, MTC_CC_12, true);
        MTC_AC_37= false;
        MTC_AC_38= false;
        MTC_CC_39_A= MTC_AC_37;
        MTC_CC_40_A= MTC_AC_38;
        MTC_CC_41_T= _L1 #29 and MTC_AC_38;
        MTC_CC_42_F= #29 not _L1 #30 and MTC_AC_38;
        ()= #1 MTCEx::MTC_Observers::Controller_PATHS15_MTC_OBS(MTC_CC_39_A, true);
        ()=
          #1 MTCEx::MTC_Observers::Controller_PATHS16_MTC_OBS(MTC_CC_40_A,
            MTC_CC_41_T, MTC_CC_42_F, true);
      tel
      until
        if #1
        MTCEx::MTC_Instrumenters::Controller_SM1_Pollution_1_MTC_INST(Stop, #30
          not false, true)
          do var
            MTC_CC_14 : bool;
          let
            emit 'MTC_sig_fire_9;
            MTC_CC_14= true;
            ()= #5 MTCEx::MTC_Observers::TRANSITION_MTC_OBS(MTC_CC_14, true);
          tel restart Defaillance_Station;
        if #2
        MTCEx::MTC_Instrumenters::Controller_SM1_Pollution_2_MTC_INST(Stop,
          Frequency, #31 not Stop, true)
          do var
            MTC_CC_13 : bool;
          let
            emit 'MTC_sig_fire_9;
            MTC_CC_13= true;
            ()= #6 MTCEx::MTC_Observers::TRANSITION_MTC_OBS(MTC_CC_13, true);
          tel restart Timer;

    state Timer
      var
        MTC_CC_15 : bool;
        MTC_CC_16 : bool;
        MTC_AC_39 : bool;
        MTC_CC_43_A : bool;
        MTC_CC_44_T : bool;
        MTC_CC_45_F : bool;
        _L2 : float64;
        _L7 : float64;
        _L8 : float64;
        _L10 : float64;
        _L11 : bool;
        _L12 : float64;
        _L13 : float64;
      let
        _L2= Frequency;
        _L7= Time;
        _L8= _L7 #4 - _L10;
        _L10= Store_Time;
        _L11= _L8 #2 >= _L12;
        _L12= _L13 #1 / _L2;
        _L13= 1.0;
        timeout= _L11;
        emit 'MTC_sig_def_7;
        MTC_CC_15= true;
        MTC_CC_16= #32 not 'MTC_sig_fire_9;
        ()= #5 MTCEx::MTC_Observers::STATE_MTC_OBS(MTC_CC_15, MTC_CC_16, true);
        MTC_AC_39= false #11 or 'MTC_sig_11;
        MTC_CC_43_A= MTC_AC_39;
        MTC_CC_44_T= _L11 #31 and MTC_AC_39;
        MTC_CC_45_F= #33 not _L11 #32 and MTC_AC_39;
        ()=
          #1 MTCEx::MTC_Observers::Controller_PATHS17_MTC_OBS(MTC_CC_43_A,
            MTC_CC_44_T, MTC_CC_45_F, true);
      tel
      until
        if #1 MTCEx::MTC_Instrumenters::Controller_SM1_Timer_1_MTC_INST(timeout,
          #34 not false, true)
          do var
            MTC_CC_17 : bool;
          let
            emit 'MTC_sig_fire_9;
            MTC_CC_17= true;
            ()= #7 MTCEx::MTC_Observers::TRANSITION_MTC_OBS(MTC_CC_17, true);
          tel restart Normal_Station;
  returns ..;
  Send_Data= MTC_Send_Data;
  MTC_AC_Outputs= true;
  emit 'MTC_sig_10 if true;
  emit 'MTC_sig_10 if true;
  emit 'MTC_sig_11 if true;
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Modelisation_Surveillance.xscade */
type position = float64^2;

type
  Statation_data = {
    Temperature : float64,
    pH : float64,
    Redox : float64,
    Position : position,
    Time : float64
  };

type Data = float64^3;

const Temperature_Low : float64 = - 10.0;

const Redox_Low : float64 = - 3000.0;

const Redox_High : float64 = 3000.0;

const pH_High : float64 = 14.0;

const pH_low : float64 = 0.0;

const Temperature_High : float64 = 50.0;

const Redox_Normal_High : float64 = 900.0;

const Redox_Normal_Low : float64 = 700.0;

const pH_Normal_High : float64 = 9.0;

const pH_Normal_Low : float64 = 6.5;

const Temperature_Normal_High : float64 = 35.0;

const Temperature_Normal_Low : float64 = - 1.0;

const Beyond_Interval_value : float64 = 999.85419;

const Delta_pH : float64 = 1.0;

const Delta_Temperature : float64 = 5.0;

const Delta_Redox : float64 = 50.0;

const Notification_Defaillance : float64 = - 999.4156;

type Ten_Values_Table = Data^10;

const
  Normal_Value : Ten_Values_Table
    = [[10.0, 7.0, 800.0], [10.0, 7.0, 800.0], [10.0, 7.0, 800.0], [10.0, 7.0,
        800.0], [10.0, 7.0, 800.0], [10.0, 7.0, 800.0], [10.0, 7.0, 800.0], [
        10.0, 7.0, 800.0], [10.0, 7.0, 800.0], [10.0, 7.0, 800.0]];

const
  Normal_Send_Data : Statation_data
    = { Temperature:10.0, pH:7.0, Redox:800.0, Position:[0.0, 0.0], Time:0.0 };

open MTC;
open MTCEx;
open MTCEx::MTC_Observers;
open MTCEx::MTC_Instrumenters;

/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator2.xscade */
node Vote_Alog(
    pH_Data : Data;
    Temperature_Data : Data;
    Redox_Data : Data;
    MTC_AC_Outputs : bool;
    MTC_INSTRU : bool)
  returns (pH : float64; Temperature : float64; Redox : float64)
var
  MTC_AC_1 : bool;
  MTC_AC_2 : bool;
  MTC_AC_3 : bool;
  MTC_AC_4 : bool;
  MTC_AC_5 : bool;
  MTC_AC_6 : bool;
  MTC_AC_7 : bool;
  MTC_AC_8 : bool;
  MTC_AC_9 : bool;
  MTC_AC_10 : bool;
  MTC_AC_11 : bool;
  MTC_AC_12 : bool;
  MTC_AC_13 : bool;
  MTC_AC_14 : bool;
  MTC_AC_15 : bool;
  MTC_AC_16 : bool;
  MTC_AC_17 : bool;
  MTC_AC_18 : bool;
  MTC_AC_19 : bool;
  MTC_AC_20 : bool;
  MTC_AC_21 : bool;
  MTC_AC_22 : bool;
  MTC_AC_23 : bool;
  MTC_AC_24 : bool;
  MTC_AC_25 : bool;
  MTC_AC_26 : bool;
  MTC_AC_27 : bool;
  MTC_AC_28 : bool;
  MTC_AC_29 : bool;
  MTC_AC_30 : bool;
  MTC_AC_31 : bool;
  MTC_AC_32 : bool;
  MTC_AC_33 : bool;
  MTC_AC_34 : bool;
  MTC_AC_35 : bool;
  MTC_AC_36 : bool;
  MTC_AC_37 : bool;
  MTC_AC_38 : bool;
  MTC_AC_39 : bool;
  MTC_AC_40 : bool;
  MTC_AC_41 : bool;
  MTC_AC_42 : bool;
  MTC_AC_43 : bool;
  MTC_AC_44 : bool;
  MTC_AC_45 : bool;
  MTC_AC_46 : bool;
  MTC_AC_47 : bool;
  MTC_AC_48 : bool;
  MTC_AC_49 : bool;
  MTC_AC_50 : bool;
  MTC_AC_51 : bool;
  MTC_AC_52 : bool;
  MTC_AC_53 : bool;
  MTC_AC_54 : bool;
  MTC_CC_1_A : bool;
  MTC_CC_2_T : bool;
  MTC_CC_3_F : bool;
  MTC_CC_4_A : bool;
  MTC_CC_5_A : bool;
  MTC_CC_6_T : bool;
  MTC_CC_7_F : bool;
  MTC_CC_8_A : bool;
  MTC_CC_9_A : bool;
  MTC_CC_10_T : bool;
  MTC_CC_11_F : bool;
  MTC_CC_12_A : bool;
  MTC_CC_13_A : bool;
  MTC_CC_14_A : bool;
  MTC_CC_15_T : bool;
  MTC_CC_16_F : bool;
  MTC_CC_17_A : bool;
  MTC_CC_18_A : bool;
  MTC_CC_19_T : bool;
  MTC_CC_20_F : bool;
  MTC_CC_21_A : bool;
  MTC_CC_22_A : bool;
  MTC_CC_23_T : bool;
  MTC_CC_24_F : bool;
  MTC_CC_25_A : bool;
  MTC_CC_26_A : bool;
  MTC_CC_27_A : bool;
  MTC_CC_28_T : bool;
  MTC_CC_29_F : bool;
  MTC_CC_30_A : bool;
  MTC_CC_31_A : bool;
  MTC_CC_32_T : bool;
  MTC_CC_33_F : bool;
  MTC_CC_34_A : bool;
  MTC_CC_35_A : bool;
  MTC_CC_36_T : bool;
  MTC_CC_37_F : bool;
  MTC_CC_38_A : bool;
  MTC_CC_39_A : bool;
  _L1 : Data;
  _L2 : Data;
  _L3 : Data;
  _L5 : bool;
  _L6 : bool;
  _L9 : float64;
  _L8 : float64;
  _L7 : float64;
  _L17 : float64;
  _L16 : float64;
  _L15 : float64;
  _L14 : float64;
  _L13 : float64;
  _L12 : float64;
  _L11 : bool;
  _L10 : bool;
  _L4 : bool;
  _L18 : float64;
  _L19 : float64;
  _L22 : float64;
  _L21 : float64;
  _L20 : float64;
  _L25 : float64;
  _L24 : float64;
  _L23 : float64;
  _L26 : bool;
  _L27 : bool;
  _L28 : float64;
  _L29 : float64;
  _L30 : float64;
  _L31 : float64;
  _L32 : float64;
  _L33 : float64;
  _L34 : float64;
  _L36 : float64;
  _L37 : bool;
  _L38 : bool;
  _L39 : float64;
  _L40 : float64;
  _L41 : float64;
  _L42 : float64;
  _L43 : float64;
  _L44 : float64;
  _L45 : float64;
  _L46 : float64;
let
  _L1= pH_Data;
  _L2= Temperature_Data;
  _L3= Redox_Data;
  _L5= #1 Check_interval_Redox(_L25, MTC_AC_42, MTC_INSTRU);
  _L6= #1 Check_interval_Temperature(_L22, MTC_AC_24, MTC_INSTRU);
  _L9, _L8, _L7= (#1 flatten Data)(_L1);
  _L17= Beyond_Interval_value;
  _L16= Beyond_Interval_value;
  _L15= Beyond_Interval_value;
  _L14= #3 if _L11 then (_L7) else (_L17);
  _L13= #2 if _L10 then (_L8) else (_L16);
  _L12= #1 if _L4 then (_L9) else (_L15);
  _L11= #3 Check_interval_pH(_L7, MTC_AC_16, MTC_INSTRU);
  _L10= #2 Check_interval_pH(_L8, MTC_AC_11, MTC_INSTRU);
  _L4= #1 Check_interval_pH(_L9, MTC_AC_6, MTC_INSTRU);
  _L18= #1 Calculated_value(_L12, _L13, _L14, _L19, MTC_AC_2, MTC_INSTRU);
  _L19= Delta_pH;
  pH= _L18;
  _L22, _L21, _L20= (#2 flatten Data)(_L2);
  _L25, _L24, _L23= (#3 flatten Data)(_L3);
  _L26= #2 Check_interval_Temperature(_L21, MTC_AC_29, MTC_INSTRU);
  _L27= #3 Check_interval_Temperature(_L20, MTC_AC_34, MTC_INSTRU);
  _L28= #4 if _L6 then (_L22) else (_L31);
  _L29= #5 if _L26 then (_L21) else (_L32);
  _L30= #6 if _L27 then (_L20) else (_L33);
  _L31= Beyond_Interval_value;
  _L32= Beyond_Interval_value;
  _L33= Beyond_Interval_value;
  _L34= #2 Calculated_value(_L28, _L29, _L30, _L36, MTC_AC_20, MTC_INSTRU);
  _L36= Delta_Temperature;
  Temperature= _L34;
  _L37= #2 Check_interval_Redox(_L24, MTC_AC_47, MTC_INSTRU);
  _L38= #3 Check_interval_Redox(_L23, MTC_AC_52, MTC_INSTRU);
  _L39= #7 if _L5 then (_L25) else (_L42);
  _L40= #8 if _L37 then (_L24) else (_L43);
  _L41= #9 if _L38 then (_L23) else (_L44);
  _L42= Beyond_Interval_value;
  _L43= Beyond_Interval_value;
  _L44= Beyond_Interval_value;
  _L45= #3 Calculated_value(_L39, _L40, _L41, _L46, MTC_AC_38, MTC_INSTRU);
  _L46= Delta_Redox;
  Redox= _L45;
  MTC_AC_1= MTC_AC_Outputs;
  MTC_AC_2= MTC_AC_1;
  MTC_AC_3=
    MTC_AC_6 #3 or (MTC_AC_7 #5 or MTC_AC_12 #4 or MTC_AC_17) #2 or MTC_AC_11 #1
    or
    MTC_AC_16;
  MTC_AC_4= _L4;
  MTC_AC_5= #1 not _L4;
  MTC_AC_6= MTC_AC_2;
  MTC_AC_7= MTC_AC_4 #1 and MTC_AC_2;
  MTC_AC_8= MTC_AC_5 #2 and MTC_AC_2;
  MTC_AC_9= _L10;
  MTC_AC_10= #2 not _L10;
  MTC_AC_11= MTC_AC_2;
  MTC_AC_12= MTC_AC_9 #3 and MTC_AC_2;
  MTC_AC_13= MTC_AC_10 #4 and MTC_AC_2;
  MTC_AC_14= _L11;
  MTC_AC_15= #3 not _L11;
  MTC_AC_16= MTC_AC_2;
  MTC_AC_17= MTC_AC_14 #5 and MTC_AC_2;
  MTC_AC_18= MTC_AC_15 #6 and MTC_AC_2;
  MTC_AC_19= MTC_AC_Outputs;
  MTC_AC_20= MTC_AC_19;
  MTC_AC_21=
    MTC_AC_24 #8 or (MTC_AC_25 #10 or MTC_AC_30 #9 or MTC_AC_35) #7 or MTC_AC_29
    #6 or
    MTC_AC_34;
  MTC_AC_22= _L6;
  MTC_AC_23= #4 not _L6;
  MTC_AC_24= MTC_AC_20;
  MTC_AC_25= MTC_AC_22 #7 and MTC_AC_20;
  MTC_AC_26= MTC_AC_23 #8 and MTC_AC_20;
  MTC_AC_27= _L26;
  MTC_AC_28= #5 not _L26;
  MTC_AC_29= MTC_AC_20;
  MTC_AC_30= MTC_AC_27 #9 and MTC_AC_20;
  MTC_AC_31= MTC_AC_28 #10 and MTC_AC_20;
  MTC_AC_32= _L27;
  MTC_AC_33= #6 not _L27;
  MTC_AC_34= MTC_AC_20;
  MTC_AC_35= MTC_AC_32 #11 and MTC_AC_20;
  MTC_AC_36= MTC_AC_33 #12 and MTC_AC_20;
  MTC_AC_37= MTC_AC_Outputs;
  MTC_AC_38= MTC_AC_37;
  MTC_AC_39=
    MTC_AC_42 #13 or (MTC_AC_43 #15 or MTC_AC_48 #14 or MTC_AC_53) #12 or MTC_AC_47
    #11 or
    MTC_AC_52;
  MTC_AC_40= _L5;
  MTC_AC_41= #7 not _L5;
  MTC_AC_42= MTC_AC_38;
  MTC_AC_43= MTC_AC_40 #13 and MTC_AC_38;
  MTC_AC_44= MTC_AC_41 #14 and MTC_AC_38;
  MTC_AC_45= _L37;
  MTC_AC_46= #8 not _L37;
  MTC_AC_47= MTC_AC_38;
  MTC_AC_48= MTC_AC_45 #15 and MTC_AC_38;
  MTC_AC_49= MTC_AC_46 #16 and MTC_AC_38;
  MTC_AC_50= _L38;
  MTC_AC_51= #9 not _L38;
  MTC_AC_52= MTC_AC_38;
  MTC_AC_53= MTC_AC_50 #17 and MTC_AC_38;
  MTC_AC_54= MTC_AC_51 #18 and MTC_AC_38;
  MTC_CC_1_A= MTC_AC_3;
  MTC_CC_2_T= _L4 #19 and MTC_AC_2;
  MTC_CC_3_F= #10 not _L4 #20 and MTC_AC_2;
  MTC_CC_4_A= MTC_AC_7;
  MTC_CC_5_A= MTC_AC_8;
  MTC_CC_6_T= _L10 #21 and MTC_AC_2;
  MTC_CC_7_F= #11 not _L10 #22 and MTC_AC_2;
  MTC_CC_8_A= MTC_AC_12;
  MTC_CC_9_A= MTC_AC_13;
  MTC_CC_10_T= _L11 #23 and MTC_AC_2;
  MTC_CC_11_F= #12 not _L11 #24 and MTC_AC_2;
  MTC_CC_12_A= MTC_AC_17;
  MTC_CC_13_A= MTC_AC_18;
  MTC_CC_14_A= MTC_AC_21;
  MTC_CC_15_T= _L6 #25 and MTC_AC_20;
  MTC_CC_16_F= #13 not _L6 #26 and MTC_AC_20;
  MTC_CC_17_A= MTC_AC_25;
  MTC_CC_18_A= MTC_AC_26;
  MTC_CC_19_T= _L26 #27 and MTC_AC_20;
  MTC_CC_20_F= #14 not _L26 #28 and MTC_AC_20;
  MTC_CC_21_A= MTC_AC_30;
  MTC_CC_22_A= MTC_AC_31;
  MTC_CC_23_T= _L27 #29 and MTC_AC_20;
  MTC_CC_24_F= #15 not _L27 #30 and MTC_AC_20;
  MTC_CC_25_A= MTC_AC_35;
  MTC_CC_26_A= MTC_AC_36;
  MTC_CC_27_A= MTC_AC_39;
  MTC_CC_28_T= _L5 #31 and MTC_AC_38;
  MTC_CC_29_F= #16 not _L5 #32 and MTC_AC_38;
  MTC_CC_30_A= MTC_AC_43;
  MTC_CC_31_A= MTC_AC_44;
  MTC_CC_32_T= _L37 #33 and MTC_AC_38;
  MTC_CC_33_F= #17 not _L37 #34 and MTC_AC_38;
  MTC_CC_34_A= MTC_AC_48;
  MTC_CC_35_A= MTC_AC_49;
  MTC_CC_36_T= _L38 #35 and MTC_AC_38;
  MTC_CC_37_F= #18 not _L38 #36 and MTC_AC_38;
  MTC_CC_38_A= MTC_AC_53;
  MTC_CC_39_A= MTC_AC_54;
  ()= #1 MTCEx::MTC_Observers::Vote_Alog_PATHS1_MTC_OBS(MTC_CC_1_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Vote_Alog_PATHS2_MTC_OBS(MTC_CC_4_A, MTC_CC_5_A,
      MTC_CC_2_T, MTC_CC_3_F, MTC_CC_8_A, MTC_CC_9_A, MTC_CC_6_T, MTC_CC_7_F,
      MTC_CC_12_A, MTC_CC_13_A, MTC_CC_10_T, MTC_CC_11_F, MTC_INSTRU);
  ()=
    ( activate #1
    MTCEx::MTC_Observers::Calculated_value_1110_MTC_OBS every MTC_AC_2 default ())(_L12,
      _L13, _L14, _L19, MTC_INSTRU);
  ()=
    ( activate #1
    MTCEx::MTC_Observers::Check_interval_pH_1_MTC_OBS every MTC_AC_6 default ())(_L9,
      MTC_INSTRU);
  ()=
    ( activate #2
    MTCEx::MTC_Observers::Check_interval_pH_1_MTC_OBS every MTC_AC_11 default ())(_L8,
      MTC_INSTRU);
  ()=
    ( activate #3
    MTCEx::MTC_Observers::Check_interval_pH_1_MTC_OBS every MTC_AC_16 default ())(_L7,
      MTC_INSTRU);
  ()= #1 MTCEx::MTC_Observers::Vote_Alog_PATHS3_MTC_OBS(MTC_CC_14_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Vote_Alog_PATHS4_MTC_OBS(MTC_CC_17_A, MTC_CC_18_A,
      MTC_CC_15_T, MTC_CC_16_F, MTC_CC_21_A, MTC_CC_22_A, MTC_CC_19_T,
      MTC_CC_20_F, MTC_CC_25_A, MTC_CC_26_A, MTC_CC_23_T, MTC_CC_24_F,
      MTC_INSTRU);
  ()=
    ( activate #2
    MTCEx::MTC_Observers::Calculated_value_1110_MTC_OBS every MTC_AC_20 default ())(_L28,
      _L29, _L30, _L36, MTC_INSTRU);
  ()=
    ( activate #1
    MTCEx::MTC_Observers::Check_interval_Temperature_1_MTC_OBS every MTC_AC_24 default ())(_L22,
      MTC_INSTRU);
  ()=
    ( activate #2
    MTCEx::MTC_Observers::Check_interval_Temperature_1_MTC_OBS every MTC_AC_29 default ())(_L21,
      MTC_INSTRU);
  ()=
    ( activate #3
    MTCEx::MTC_Observers::Check_interval_Temperature_1_MTC_OBS every MTC_AC_34 default ())(_L20,
      MTC_INSTRU);
  ()= #1 MTCEx::MTC_Observers::Vote_Alog_PATHS5_MTC_OBS(MTC_CC_27_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Vote_Alog_PATHS6_MTC_OBS(MTC_CC_30_A, MTC_CC_31_A,
      MTC_CC_28_T, MTC_CC_29_F, MTC_CC_34_A, MTC_CC_35_A, MTC_CC_32_T,
      MTC_CC_33_F, MTC_CC_38_A, MTC_CC_39_A, MTC_CC_36_T, MTC_CC_37_F,
      MTC_INSTRU);
  ()=
    ( activate #3
    MTCEx::MTC_Observers::Calculated_value_1110_MTC_OBS every MTC_AC_38 default ())(_L39,
      _L40, _L41, _L46, MTC_INSTRU);
  ()=
    ( activate #1
    MTCEx::MTC_Observers::Check_interval_Redox_1_MTC_OBS every MTC_AC_42 default ())(_L25,
      MTC_INSTRU);
  ()=
    ( activate #2
    MTCEx::MTC_Observers::Check_interval_Redox_1_MTC_OBS every MTC_AC_47 default ())(_L24,
      MTC_INSTRU);
  ()=
    ( activate #3
    MTCEx::MTC_Observers::Check_interval_Redox_1_MTC_OBS every MTC_AC_52 default ())(_L23,
      MTC_INSTRU);
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator3.xscade */
node Check_interval_Temperature(
    temperature : float64;
    MTC_AC_Outputs : bool;
    MTC_INSTRU : bool)
  returns (Output1 : bool)
var
  MTC_AC_1 : bool;
  MTC_AC_2 : bool;
  MTC_AC_3 : bool;
  MTC_AC_4 : bool;
  MTC_AC_5 : bool;
  MTC_CC_1_T : bool;
  MTC_CC_2_F : bool;
  MTC_CC_3_T : bool;
  MTC_CC_4_F : bool;
  _L1 : float64;
  _L4 : bool;
  _L5 : float64;
  _L7 : bool;
  _L9 : bool;
  _L10 : float64;
let
  _L1= temperature;
  _L4= _L7 #1 and _L9;
  _L5= Temperature_High;
  Output1= _L4;
  _L7= _L10 #1 <= _L1;
  _L9= _L1 #2 <= _L5;
  _L10= Temperature_Low;
  MTC_AC_1= MTC_AC_Outputs;
  MTC_AC_2= _L9;
  MTC_AC_3= _L7;
  MTC_AC_4= MTC_AC_2 #2 and MTC_AC_1;
  MTC_AC_5= MTC_AC_3 #3 and MTC_AC_1;
  MTC_CC_1_T= _L7 #4 and MTC_AC_4;
  MTC_CC_2_F= #1 not _L7 #5 and MTC_AC_4;
  MTC_CC_3_T= _L9 #6 and MTC_AC_5;
  MTC_CC_4_F= #2 not _L9 #7 and MTC_AC_5;
  ()=
    #1
    MTCEx::MTC_Observers::Check_interval_Temperature_PATHS1_MTC_OBS(MTC_CC_1_T,
      MTC_CC_2_F, MTC_CC_3_T, MTC_CC_4_F, MTC_INSTRU);
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator4.xscade */
node Check_interval_pH(pH : float64; MTC_AC_Outputs : bool; MTC_INSTRU : bool)
  returns (Output1 : bool)
var
  MTC_AC_1 : bool;
  MTC_AC_2 : bool;
  MTC_AC_3 : bool;
  MTC_AC_4 : bool;
  MTC_AC_5 : bool;
  MTC_CC_1_T : bool;
  MTC_CC_2_F : bool;
  MTC_CC_3_T : bool;
  MTC_CC_4_F : bool;
  _L2 : bool;
  _L4 : float64;
  _L5 : float64;
  _L6 : float64;
  _L8 : bool;
  _L9 : bool;
let
  _L2= _L9 #1 and _L8;
  Output1= _L2;
  _L4= pH;
  _L5= pH_High;
  _L6= pH_low;
  _L8= _L5 #1 >= _L4;
  _L9= _L6 #1 <= _L4;
  MTC_AC_1= MTC_AC_Outputs;
  MTC_AC_2= _L8;
  MTC_AC_3= _L9;
  MTC_AC_4= MTC_AC_2 #2 and MTC_AC_1;
  MTC_AC_5= MTC_AC_3 #3 and MTC_AC_1;
  MTC_CC_1_T= _L9 #4 and MTC_AC_4;
  MTC_CC_2_F= #1 not _L9 #5 and MTC_AC_4;
  MTC_CC_3_T= _L8 #6 and MTC_AC_5;
  MTC_CC_4_F= #2 not _L8 #7 and MTC_AC_5;
  ()=
    #1 MTCEx::MTC_Observers::Check_interval_pH_PATHS1_MTC_OBS(MTC_CC_1_T,
      MTC_CC_2_F, MTC_CC_3_T, MTC_CC_4_F, MTC_INSTRU);
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator5.xscade */
node Check_interval_Redox(
    Redox : float64;
    MTC_AC_Outputs : bool;
    MTC_INSTRU : bool)
  returns (Output1 : bool)
var
  MTC_AC_1 : bool;
  MTC_AC_2 : bool;
  MTC_AC_3 : bool;
  MTC_AC_4 : bool;
  MTC_AC_5 : bool;
  MTC_CC_1_T : bool;
  MTC_CC_2_F : bool;
  MTC_CC_3_T : bool;
  MTC_CC_4_F : bool;
  _L1 : bool;
  _L4 : float64;
  _L5 : float64;
  _L6 : float64;
  _L7 : bool;
  _L8 : bool;
let
  _L1= _L7 #1 and _L8;
  _L4= Redox;
  Output1= _L1;
  _L5= Redox_Low;
  _L6= Redox_High;
  _L7= _L4 #1 >= _L5;
  _L8= _L4 #1 <= _L6;
  MTC_AC_1= MTC_AC_Outputs;
  MTC_AC_2= _L8;
  MTC_AC_3= _L7;
  MTC_AC_4= MTC_AC_2 #2 and MTC_AC_1;
  MTC_AC_5= MTC_AC_3 #3 and MTC_AC_1;
  MTC_CC_1_T= _L7 #4 and MTC_AC_4;
  MTC_CC_2_F= #1 not _L7 #5 and MTC_AC_4;
  MTC_CC_3_T= _L8 #6 and MTC_AC_5;
  MTC_CC_4_F= #2 not _L8 #7 and MTC_AC_5;
  ()=
    #1 MTCEx::MTC_Observers::Check_interval_Redox_PATHS1_MTC_OBS(MTC_CC_1_T,
      MTC_CC_2_F, MTC_CC_3_T, MTC_CC_4_F, MTC_INSTRU);
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator6.xscade */
function Check_normal_pH(pH : float64; MTC_AC_Outputs : bool)
  returns (Output1 : bool)
var
  _L3 : bool;
  _L5 : float64;
  _L6 : float64;
  _L7 : float64;
  _L8 : bool;
  _L9 : bool;
let
  _L3= _L8 #1 and _L9;
  Output1= _L3;
  _L5= pH;
  _L6= pH_Normal_Low;
  _L7= pH_Normal_High;
  _L8= _L6 #1 <= _L5;
  _L9= _L5 #2 <= _L7;
  _= MTC_AC_Outputs;
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator7.xscade */
function Check_normal_Temperature(Temperature : float64; MTC_AC_Outputs : bool)
  returns (Output1 : bool)
var
  _L7 : float64;
  _L6 : bool;
  _L4 : float64;
  _L2 : float64;
  _L8 : bool;
  _L9 : bool;
let
  _L2= Temperature;
  _L4= Temperature_Normal_High;
  Output1= _L6;
  _L6= _L8 #1 and _L9;
  _L7= Temperature_Normal_Low;
  _L8= _L7 #1 <= _L2;
  _L9= _L2 #2 <= _L4;
  _= MTC_AC_Outputs;
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator8.xscade */
function Check_normal_Redox(Redox : float64; MTC_AC_Outputs : bool)
  returns (Output1 : bool)
var
  _L6 : float64;
  _L4 : bool;
  _L3 : float64;
  _L1 : float64;
  _L7 : bool;
  _L8 : bool;
let
  _L1= Redox;
  Output1= _L4;
  _L3= Redox_Normal_High;
  _L4= _L7 #1 and _L8;
  _L6= Redox_Normal_Low;
  _L7= _L6 #1 <= _L1;
  _L8= _L1 #2 <= _L3;
  _= MTC_AC_Outputs;
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator9.xscade */
node Calculated_value(
    value1 : float64;
    value2 : float64;
    value3 : float64;
    delta : float64;
    MTC_AC_Outputs : bool;
    MTC_INSTRU : bool)
  returns (Output1 : float64)
sig
  MTC_sig_1, MTC_sig_2, MTC_sig_3;
var
  a : bool;
  b : bool;
  c : bool;
  MTC_AC_25 : bool;
  MTC_AC_26 : bool;
  MTC_AC_27 : bool;
  MTC_CC_9_A : bool;
  MTC_CC_10_T : bool;
  MTC_CC_11_F : bool;
  MTC_CC_12_A : bool;
  MTC_CC_13_T : bool;
  MTC_CC_14_F : bool;
  MTC_CC_15_A : bool;
  MTC_CC_16_T : bool;
  MTC_CC_17_F : bool;
  _L1 : float64;
  _L2 : float64;
  _L3 : float64;
  _L7 : float64;
  _L8 : float64;
  _L9 : float64;
  _L16 : bool;
  _L17 : bool;
  _L18 : bool;
let
  _L1= value1;
  _L2= value2;
  _L3= value3;
  _L7= Beyond_Interval_value;
  _L8= Beyond_Interval_value;
  _L9= Beyond_Interval_value;
  activate IfBlock1 if #2
    MTCEx::MTC_Instrumenters::Calculated_value_IfBlock1_MTC_INST(a, b, c,
      MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      _L4 : float64;
      _L5 : float64;
      _L6 : float64;
      _L7 : float64;
      _L8 : float64;
    let
      _L4= value1;
      _L5= value2;
      _L6= value3;
      _L7= #1 Check_Delta_3(_L4, _L5, _L6, _L8, MTC_AC_2, MTC_INSTRU);
      _L8= delta;
      Output1= _L7;
      MTC_CC_1= MTC_AC_Outputs;
      ()= #8 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC_Outputs;
      MTC_AC_2= MTC_AC_1;
      ()=
        ( activate #1
        MTCEx::MTC_Observers::Check_Delta_3_1111_MTC_OBS every MTC_AC_2 default ())(_L4,
          _L5, _L6, _L8, MTC_INSTRU);
    tel
    else if #3
    MTCEx::MTC_Instrumenters::Calculated_value_IfBlock1_else_MTC_INST(a, b, c,
      MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      _L1 : float64;
      _L2 : float64;
      _L3 : float64;
    let
      _L1, _, _= #1 math::Mean(_L2, _L3, MTC_AC_4, MTC_INSTRU);
      _L2= value2;
      _L3= value3;
      Output1= _L1;
      MTC_CC_2= MTC_AC_Outputs;
      ()= #7 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_2, MTC_INSTRU);
      MTC_AC_3= MTC_AC_Outputs;
      MTC_AC_4= MTC_AC_3;
      ()=
        ( activate #1
        MTCEx::MTC_Observers::math_Mean_MTC_OBS every MTC_AC_4 default ())(MTC_INSTRU);
    tel
    else if #4
    MTCEx::MTC_Instrumenters::Calculated_value_IfBlock1_else_else_MTC_INST(b, a,
      c, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_3 : bool;
      MTC_AC_9 : bool;
      MTC_AC_10 : bool;
      _L1 : float64;
      _L4 : float64;
      _L5 : float64;
    let
      _L1, _, _= #3 math::Mean(_L4, _L5, MTC_AC_10, MTC_INSTRU);
      _L4= value1;
      _L5= value3;
      Output1= _L1;
      MTC_CC_3= MTC_AC_Outputs;
      ()= #6 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_3, MTC_INSTRU);
      MTC_AC_9= MTC_AC_Outputs;
      MTC_AC_10= MTC_AC_9;
      ()=
        ( activate #3
        MTCEx::MTC_Observers::math_Mean_MTC_OBS every MTC_AC_10 default ())(MTC_INSTRU);
    tel
    else if #5
    MTCEx::MTC_Instrumenters::Calculated_value_IfBlock1_else_else_else_MTC_INST(c,
      a, b, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_4 : bool;
      MTC_AC_15 : bool;
      MTC_AC_16 : bool;
      _L2 : float64;
      _L3 : float64;
      _L4 : float64;
    let
      _L2, _, _= #5 math::Mean(_L3, _L4, MTC_AC_16, MTC_INSTRU);
      _L3= value1;
      _L4= value2;
      Output1= _L2;
      MTC_CC_4= MTC_AC_Outputs;
      ()= #5 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_4, MTC_INSTRU);
      MTC_AC_15= MTC_AC_Outputs;
      MTC_AC_16= MTC_AC_15;
      ()=
        ( activate #5
        MTCEx::MTC_Observers::math_Mean_MTC_OBS every MTC_AC_16 default ())(MTC_INSTRU);
    tel
    else if #6
    MTCEx::MTC_Instrumenters::Calculated_value_IfBlock1_else_else_else_else_MTC_INST(a,
      b, c, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_5 : bool;
      _L1 : float64;
    let
      _L1= value3;
      Output1= _L1;
      MTC_CC_5= MTC_AC_Outputs;
      ()= #4 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_5, MTC_INSTRU);
    tel
    else if #7
    MTCEx::MTC_Instrumenters::Calculated_value_IfBlock1_else_else_else_else_else_MTC_INST(b,
      c, a, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_6 : bool;
      _L1 : float64;
    let
      _L1= value1;
      Output1= _L1;
      MTC_CC_6= MTC_AC_Outputs;
      ()= #3 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_6, MTC_INSTRU);
    tel
    else if #8
    MTCEx::MTC_Instrumenters::Calculated_value_IfBlock1_else_else_else_else_else_else_MTC_INST(a,
      c, b, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_7 : bool;
      _L1 : float64;
    let
      _L1= value2;
      Output1= _L1;
      MTC_CC_7= MTC_AC_Outputs;
      ()= #2 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_7, MTC_INSTRU);
    tel
    else var
      MTC_CC_8 : bool;
      _L1 : float64;
    let
      _L1= Notification_Defaillance;
      Output1= _L1;
      MTC_CC_8= MTC_AC_Outputs;
      ()= #1 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_8, MTC_INSTRU);
    tel
  returns ..;
  a= _L16;
  b= _L17;
  c= _L18;
  _L16= _L1 #1 <> _L7;
  _L17= _L2 #2 <> _L8;
  _L18= _L3 #3 <> _L9;
  emit ('MTC_sig_1, 'MTC_sig_2, 'MTC_sig_3) if MTC_AC_Outputs;
  emit ('MTC_sig_1, 'MTC_sig_2, 'MTC_sig_3) if MTC_AC_Outputs;
  emit ('MTC_sig_1, 'MTC_sig_2, 'MTC_sig_3) if MTC_AC_Outputs;
  emit ('MTC_sig_1, 'MTC_sig_2, 'MTC_sig_3) if MTC_AC_Outputs;
  emit ('MTC_sig_1, 'MTC_sig_2, 'MTC_sig_3) if MTC_AC_Outputs;
  emit ('MTC_sig_1, 'MTC_sig_2, 'MTC_sig_3) if MTC_AC_Outputs;
  emit ('MTC_sig_1, 'MTC_sig_2, 'MTC_sig_3) if MTC_AC_Outputs;
  MTC_AC_25= 'MTC_sig_1;
  MTC_AC_26= 'MTC_sig_2;
  MTC_AC_27= 'MTC_sig_3;
  MTC_CC_9_A= MTC_AC_25;
  MTC_CC_10_T= _L16 #1 and MTC_AC_25;
  MTC_CC_11_F= #1 not _L16 #2 and MTC_AC_25;
  MTC_CC_12_A= MTC_AC_26;
  MTC_CC_13_T= _L17 #3 and MTC_AC_26;
  MTC_CC_14_F= #2 not _L17 #4 and MTC_AC_26;
  MTC_CC_15_A= MTC_AC_27;
  MTC_CC_16_T= _L18 #5 and MTC_AC_27;
  MTC_CC_17_F= #3 not _L18 #6 and MTC_AC_27;
  ()=
    #1 MTCEx::MTC_Observers::Calculated_value_PATHS8_MTC_OBS(MTC_CC_9_A,
      MTC_CC_10_T, MTC_CC_11_F, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Calculated_value_PATHS9_MTC_OBS(MTC_CC_12_A,
      MTC_CC_13_T, MTC_CC_14_F, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Calculated_value_PATHS10_MTC_OBS(MTC_CC_15_A,
      MTC_CC_16_T, MTC_CC_17_F, MTC_INSTRU);
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator10.xscade */
node Check_Delta_3(
    Input1 : float64;
    Input2 : float64;
    Input3 : float64;
    Delta : float64;
    MTC_AC_Outputs : bool;
    MTC_INSTRU : bool)
  returns (Output1 : float64)
sig
  MTC_sig_1, MTC_sig_2, MTC_sig_3, MTC_sig_4;
var
  fail2 : bool;
  fail1 : bool;
  fail3 : bool;
  all_fail : bool;
  MTC_AC_38 : bool;
  MTC_AC_39 : bool;
  MTC_AC_40 : bool;
  MTC_AC_41 : bool;
  MTC_AC_42 : bool;
  MTC_AC_43 : bool;
  MTC_AC_50 : bool;
  MTC_AC_51 : bool;
  MTC_AC_52 : bool;
  MTC_AC_53 : bool;
  MTC_AC_54 : bool;
  MTC_AC_55 : bool;
  MTC_AC_56 : bool;
  MTC_AC_57 : bool;
  MTC_AC_58 : bool;
  MTC_AC_59 : bool;
  MTC_AC_60 : bool;
  MTC_AC_61 : bool;
  MTC_AC_62 : bool;
  MTC_AC_63 : bool;
  MTC_AC_64 : bool;
  MTC_AC_65 : bool;
  MTC_AC_66 : bool;
  MTC_CC_9_A : bool;
  MTC_CC_10_T : bool;
  MTC_CC_11_F : bool;
  MTC_CC_12_A : bool;
  MTC_CC_13_T : bool;
  MTC_CC_14_F : bool;
  MTC_CC_15_A : bool;
  MTC_CC_16_T : bool;
  MTC_CC_17_F : bool;
  MTC_CC_18_A : bool;
  MTC_CC_19_T : bool;
  MTC_CC_20_F : bool;
  MTC_CC_21_T : bool;
  MTC_CC_22_F : bool;
  MTC_CC_23_T : bool;
  MTC_CC_24_F : bool;
  MTC_CC_25_A : bool;
  MTC_CC_26_A : bool;
  MTC_CC_27_A : bool;
  _L1 : float64;
  _L2 : float64;
  _L3 : float64;
  _L4 : float64;
  _L7 : float64;
  _L8 : float64;
  _L9 : float64;
  _L10 : bool;
  _L14 : float64;
  _L13 : float64;
  _L12 : bool;
  _L11 : float64;
  _L19 : bool;
  _L18 : float64;
  _L17 : float64;
  _L16 : float64;
  _L20 : bool;
let
  _L1= Input1;
  _L2= Input2;
  _L3= Input3;
  _L4= Delta;
  _L7, MTC_AC_41= #1 math::Abs(_L9, MTC_AC_40, MTC_INSTRU);
  _L8, _, _, _= #1 math::Mean3(_L1, _L2, _L3, MTC_AC_43, MTC_INSTRU);
  _L9= _L1 #1 - _L8;
  _L10= _L7 #1 > _L4;
  activate IfBlock1 if #1
    MTCEx::MTC_Instrumenters::Check_Delta_3_IfBlock1_MTC_INST(all_fail,
      MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      _L1 : float64;
      _L2 : float64;
      _L3 : float64;
      _L6 : float64;
    let
      Output1= _L6;
      _L1= Input1;
      _L2= Input2;
      _L3= Input3;
      _L6, _, _, _= #4 math::Mean3(_L1, _L2, _L3, MTC_AC_2, MTC_INSTRU);
      MTC_CC_1= MTC_AC_Outputs;
      ()= #8 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC_Outputs;
      MTC_AC_2= MTC_AC_1;
      ()=
        ( activate #4
        MTCEx::MTC_Observers::math_Mean3_MTC_OBS every MTC_AC_2 default ())(MTC_INSTRU);
    tel
    else if #6
    MTCEx::MTC_Instrumenters::Check_Delta_3_IfBlock1_else_MTC_INST(fail1, fail2,
      fail3, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_2 : bool;
      _L1 : float64;
    let
      _L1= Input3;
      Output1= _L1;
      MTC_CC_2= MTC_AC_Outputs;
      ()= #7 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_2, MTC_INSTRU);
    tel
    else if #7
    MTCEx::MTC_Instrumenters::Check_Delta_3_IfBlock1_else_else_MTC_INST(fail1,
      fail2, fail3, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_3 : bool;
      _L2 : float64;
    let
      Output1= _L2;
      _L2= Input2;
      MTC_CC_3= MTC_AC_Outputs;
      ()= #6 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_3, MTC_INSTRU);
    tel
    else if #8
    MTCEx::MTC_Instrumenters::Check_Delta_3_IfBlock1_else_else_else_MTC_INST(fail1,
      fail2, fail3, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_4 : bool;
      _L1 : float64;
    let
      _L1= Input1;
      Output1= _L1;
      MTC_CC_4= MTC_AC_Outputs;
      ()= #5 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_4, MTC_INSTRU);
    tel
    else if #9
    MTCEx::MTC_Instrumenters::Check_Delta_3_IfBlock1_else_else_else_else_MTC_INST(fail1,
      fail2, fail3, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_5 : bool;
      MTC_AC_12 : bool;
      MTC_AC_13 : bool;
      _L1 : float64;
      _L2 : float64;
      _L3 : float64;
    let
      _L1= Input2;
      _L2= Input3;
      _L3, _, _= #1 math::Mean(_L1, _L2, MTC_AC_13, MTC_INSTRU);
      Output1= _L3;
      MTC_CC_5= MTC_AC_Outputs;
      ()= #4 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_5, MTC_INSTRU);
      MTC_AC_12= MTC_AC_Outputs;
      MTC_AC_13= MTC_AC_12;
      ()=
        ( activate #1
        MTCEx::MTC_Observers::math_Mean_MTC_OBS every MTC_AC_13 default ())(MTC_INSTRU);
    tel
    else if #10
    MTCEx::MTC_Instrumenters::Check_Delta_3_IfBlock1_else_else_else_else_else_MTC_INST(fail1,
      fail2, fail3, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_6 : bool;
      MTC_AC_18 : bool;
      MTC_AC_19 : bool;
      _L1 : float64;
      _L2 : float64;
      _L3 : float64;
    let
      _L1, _, _= #2 math::Mean(_L2, _L3, MTC_AC_19, MTC_INSTRU);
      _L2= Input1;
      _L3= Input2;
      Output1= _L1;
      MTC_CC_6= MTC_AC_Outputs;
      ()= #3 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_6, MTC_INSTRU);
      MTC_AC_18= MTC_AC_Outputs;
      MTC_AC_19= MTC_AC_18;
      ()=
        ( activate #2
        MTCEx::MTC_Observers::math_Mean_MTC_OBS every MTC_AC_19 default ())(MTC_INSTRU);
    tel
    else if #11
    MTCEx::MTC_Instrumenters::Check_Delta_3_IfBlock1_else_else_else_else_else_else_MTC_INST(fail1,
      fail2, fail3, MTC_AC_Outputs, MTC_INSTRU)
    then var
      MTC_CC_7 : bool;
      MTC_AC_24 : bool;
      MTC_AC_25 : bool;
      _L1 : float64;
      _L2 : float64;
      _L3 : float64;
    let
      _L1, _, _= #3 math::Mean(_L3, _L2, MTC_AC_25, MTC_INSTRU);
      _L2= Input1;
      _L3= Input3;
      Output1= _L1;
      MTC_CC_7= MTC_AC_Outputs;
      ()= #2 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_7, MTC_INSTRU);
      MTC_AC_24= MTC_AC_Outputs;
      MTC_AC_25= MTC_AC_24;
      ()=
        ( activate #3
        MTCEx::MTC_Observers::math_Mean_MTC_OBS every MTC_AC_25 default ())(MTC_INSTRU);
    tel
    else var
      MTC_CC_8 : bool;
      MTC_AC_30 : bool;
      MTC_AC_31 : bool;
      _L1 : float64;
      _L2 : float64;
      _L3 : float64;
      _L4 : float64;
    let
      _L1, _, _, _= #6 math::Mean3(_L2, _L3, _L4, MTC_AC_31, MTC_INSTRU);
      _L2= Input1;
      _L3= Input2;
      _L4= Input3;
      Output1= _L1;
      MTC_CC_8= MTC_AC_Outputs;
      ()= #1 MTCEx::MTC_Observers::CONTROL_MTC_OBS(MTC_CC_8, MTC_INSTRU);
      MTC_AC_30= MTC_AC_Outputs;
      MTC_AC_31= MTC_AC_30;
      ()=
        ( activate #6
        MTCEx::MTC_Observers::math_Mean3_MTC_OBS every MTC_AC_31 default ())(MTC_INSTRU);
    tel
  returns ..;
  fail1= _L10;
  _L11= _L8 #2 - _L2;
  _L12= _L14 #2 > _L13;
  _L13= Delta;
  _L14, MTC_AC_53= #2 math::Abs(_L11, MTC_AC_52, MTC_INSTRU);
  fail2= _L12;
  _L16= _L8 #3 - _L3;
  _L17, MTC_AC_58= #3 math::Abs(_L16, MTC_AC_57, MTC_INSTRU);
  _L18= Delta;
  _L19= _L17 #3 > _L18;
  fail3= _L19;
  all_fail= _L20;
  _L20= _L10 #3 and _L12 #3 and _L19;
  emit 'MTC_sig_1 if MTC_AC_Outputs;
  emit ('MTC_sig_2, 'MTC_sig_3, 'MTC_sig_4) if MTC_AC_Outputs;
  emit ('MTC_sig_2, 'MTC_sig_3, 'MTC_sig_4) if MTC_AC_Outputs;
  emit ('MTC_sig_2, 'MTC_sig_3, 'MTC_sig_4) if MTC_AC_Outputs;
  emit ('MTC_sig_2, 'MTC_sig_3, 'MTC_sig_4) if MTC_AC_Outputs;
  emit ('MTC_sig_2, 'MTC_sig_3, 'MTC_sig_4) if MTC_AC_Outputs;
  emit ('MTC_sig_2, 'MTC_sig_3, 'MTC_sig_4) if MTC_AC_Outputs;
  MTC_AC_38= 'MTC_sig_2;
  MTC_AC_39= MTC_AC_38 #1 or MTC_AC_64;
  MTC_AC_40= MTC_AC_39;
  MTC_AC_42= MTC_AC_41;
  MTC_AC_43= MTC_AC_59 #2 or (MTC_AC_54 #3 or MTC_AC_42);
  MTC_AC_50= 'MTC_sig_3;
  MTC_AC_51= MTC_AC_50 #4 or MTC_AC_65;
  MTC_AC_52= MTC_AC_51;
  MTC_AC_54= MTC_AC_53;
  MTC_AC_55= 'MTC_sig_4;
  MTC_AC_56= MTC_AC_55 #5 or MTC_AC_66;
  MTC_AC_57= MTC_AC_56;
  MTC_AC_59= MTC_AC_58;
  MTC_AC_60= 'MTC_sig_1;
  MTC_AC_61= _L12 #1 and _L19;
  MTC_AC_62= _L10 #2 and _L19;
  MTC_AC_63= _L10 #4 and _L12;
  MTC_AC_64= MTC_AC_61 #5 and MTC_AC_60;
  MTC_AC_65= MTC_AC_62 #6 and MTC_AC_60;
  MTC_AC_66= MTC_AC_63 #7 and MTC_AC_60;
  MTC_CC_9_A= MTC_AC_38;
  MTC_CC_10_T= _L10 #8 and MTC_AC_38;
  MTC_CC_11_F= #1 not _L10 #9 and MTC_AC_38;
  MTC_CC_12_A= MTC_AC_50;
  MTC_CC_13_T= _L12 #10 and MTC_AC_50;
  MTC_CC_14_F= #2 not _L12 #11 and MTC_AC_50;
  MTC_CC_15_A= MTC_AC_55;
  MTC_CC_16_T= _L19 #12 and MTC_AC_55;
  MTC_CC_17_F= #3 not _L19 #13 and MTC_AC_55;
  MTC_CC_18_A= MTC_AC_60;
  MTC_CC_19_T= _L10 #14 and (MTC_AC_61 #15 and MTC_AC_60);
  MTC_CC_20_F= #4 not _L10 #16 and (MTC_AC_61 #17 and MTC_AC_60);
  MTC_CC_21_T= _L12 #18 and (MTC_AC_62 #19 and MTC_AC_60);
  MTC_CC_22_F= #5 not _L12 #20 and (MTC_AC_62 #21 and MTC_AC_60);
  MTC_CC_23_T= _L19 #22 and (MTC_AC_63 #23 and MTC_AC_60);
  MTC_CC_24_F= #6 not _L19 #24 and (MTC_AC_63 #25 and MTC_AC_60);
  MTC_CC_25_A= MTC_AC_39;
  MTC_CC_26_A= MTC_AC_51;
  MTC_CC_27_A= MTC_AC_56;
  ()=
    #1 MTCEx::MTC_Observers::Check_Delta_3_PATHS8_MTC_OBS(MTC_CC_9_A,
      MTC_CC_10_T, MTC_CC_11_F, MTC_INSTRU);
  ()=
    ( activate #1
    MTCEx::MTC_Observers::math_Abs_MTC_OBS every MTC_AC_40 default ())(MTC_INSTRU);
  ()=
    ( activate #1
    MTCEx::MTC_Observers::math_Mean3_MTC_OBS every MTC_AC_43 default ())(MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Check_Delta_3_PATHS9_MTC_OBS(MTC_CC_12_A,
      MTC_CC_13_T, MTC_CC_14_F, MTC_INSTRU);
  ()=
    ( activate #2
    MTCEx::MTC_Observers::math_Abs_MTC_OBS every MTC_AC_52 default ())(MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Check_Delta_3_PATHS10_MTC_OBS(MTC_CC_15_A,
      MTC_CC_16_T, MTC_CC_17_F, MTC_INSTRU);
  ()=
    ( activate #3
    MTCEx::MTC_Observers::math_Abs_MTC_OBS every MTC_AC_57 default ())(MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Check_Delta_3_PATHS11_MTC_OBS(MTC_CC_18_A,
      MTC_CC_19_T, MTC_CC_20_F, MTC_CC_21_T, MTC_CC_22_F, MTC_CC_23_T,
      MTC_CC_24_F, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Check_Delta_3_PATHS12_MTC_OBS(MTC_CC_25_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Check_Delta_3_PATHS13_MTC_OBS(MTC_CC_26_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Check_Delta_3_PATHS14_MTC_OBS(MTC_CC_27_A, MTC_INSTRU);
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator11.xscade */
node Mean_10_Table(
    Input1 : Ten_Values_Table;
    MTC_AC_Outputs : bool;
    MTC_INSTRU : bool)
  returns (Temperature : float64; pH : float64; Redox : float64)
var
  MTC_AC_1 : bool;
  MTC_AC_2 : bool;
  MTC_AC_3 : bool;
  MTC_AC_4 : bool;
  MTC_AC_5 : bool;
  MTC_AC_6 : bool;
  MTC_AC_7 : bool;
  MTC_AC_8 : bool;
  MTC_AC_9 : bool;
  MTC_AC_10 : bool;
  MTC_AC_11 : bool;
  MTC_AC_12 : bool;
  MTC_AC_13 : bool;
  MTC_AC_14 : bool;
  MTC_CC_1_A : bool;
  MTC_CC_2_A : bool;
  MTC_CC_3_A : bool;
  MTC_CC_4_A : bool;
  MTC_CC_5_A : bool;
  MTC_CC_6_A : bool;
  MTC_CC_7_A : bool;
  MTC_CC_8_A : bool;
  MTC_CC_9_A : bool;
  MTC_CC_10_A : bool;
  MTC_CC_11_A : bool;
  _L1 : Ten_Values_Table;
  _L11 : Data;
  _L10 : Data;
  _L9 : Data;
  _L8 : Data;
  _L7 : Data;
  _L6 : Data;
  _L5 : Data;
  _L4 : Data;
  _L3 : Data;
  _L2 : Data;
  _L14 : float64;
  _L13 : float64;
  _L12 : float64;
  _L17 : float64;
  _L16 : float64;
  _L15 : float64;
  _L20 : float64;
  _L19 : float64;
  _L18 : float64;
  _L23 : float64;
  _L22 : float64;
  _L21 : float64;
  _L26 : float64;
  _L25 : float64;
  _L24 : float64;
  _L29 : float64;
  _L28 : float64;
  _L27 : float64;
  _L32 : float64;
  _L31 : float64;
  _L30 : float64;
  _L35 : float64;
  _L34 : float64;
  _L33 : float64;
  _L38 : float64;
  _L37 : float64;
  _L36 : float64;
  _L41 : float64;
  _L40 : float64;
  _L39 : float64;
  _L42 : float64;
  _L43 : float64;
  _L44 : float64;
  _L45 : float64;
  _L46 : float64;
  _L47 : float64;
  _L48 : float64;
  _L49 : float64;
  _L50 : float64;
let
  _L1= Input1;
  _L11, _L10, _L9, _L8, _L7, _L6, _L5, _L4, _L3, _L2=
    (#1 flatten Ten_Values_Table)(_L1);
  _L14, _L13, _L12= (#2 flatten Data)(_L11);
  _L17, _L16, _L15= (#3 flatten Data)(_L10);
  _L20, _L19, _L18= (#4 flatten Data)(_L9);
  _L23, _L22, _L21= (#6 flatten Data)(_L8);
  _L26, _L25, _L24= (#8 flatten Data)(_L7);
  _L29, _L28, _L27= (#10 flatten Data)(_L6);
  _L32, _L31, _L30= (#12 flatten Data)(_L5);
  _L35, _L34, _L33= (#14 flatten Data)(_L4);
  _L38, _L37, _L36= (#16 flatten Data)(_L3);
  _L41, _L40, _L39= (#20 flatten Data)(_L2);
  _L42=
    _L14 #1 + _L17 #1 + _L20 #1 + _L23 #1 + _L26 #1 + _L29 #1 + _L32 #1 + _L35
    #1 +
    _L38 #1 +
    _L41;
  _L43=
    _L13 #2 + _L16 #2 + _L19 #2 + _L22 #2 + _L25 #2 + _L28 #2 + _L31 #2 + _L34
    #2 +
    _L37 #2 +
    _L40;
  _L44=
    _L12 #3 + _L15 #3 + _L18 #3 + _L21 #3 + _L24 #3 + _L27 #3 + _L30 #3 + _L33
    #3 +
    _L36 #3 +
    _L39;
  Temperature= _L45;
  _L45= _L42 #1 / _L46;
  _L46= 10.0;
  _L47= _L43 #2 / _L48;
  _L48= 10.0;
  pH= _L47;
  _L49= _L44 #3 / _L50;
  _L50= 10.0;
  Redox= _L49;
  MTC_AC_1= MTC_AC_Outputs;
  MTC_AC_2= MTC_AC_1 #2 or MTC_AC_13 #1 or MTC_AC_14;
  MTC_AC_3= MTC_AC_1 #4 or MTC_AC_13 #3 or MTC_AC_14;
  MTC_AC_4= MTC_AC_1 #6 or MTC_AC_13 #5 or MTC_AC_14;
  MTC_AC_5= MTC_AC_1 #8 or MTC_AC_13 #7 or MTC_AC_14;
  MTC_AC_6= MTC_AC_1 #10 or MTC_AC_13 #9 or MTC_AC_14;
  MTC_AC_7= MTC_AC_1 #12 or MTC_AC_13 #11 or MTC_AC_14;
  MTC_AC_8= MTC_AC_1 #14 or MTC_AC_13 #13 or MTC_AC_14;
  MTC_AC_9= MTC_AC_1 #16 or MTC_AC_13 #15 or MTC_AC_14;
  MTC_AC_10= MTC_AC_1 #18 or MTC_AC_13 #17 or MTC_AC_14;
  MTC_AC_11= MTC_AC_1 #20 or MTC_AC_13 #19 or MTC_AC_14;
  MTC_AC_12=
    MTC_AC_2 #29 or MTC_AC_3 #28 or MTC_AC_4 #27 or MTC_AC_5 #26 or MTC_AC_6 #25
    or
    MTC_AC_7 #24 or
    MTC_AC_8 #23 or
    MTC_AC_9 #22 or
    MTC_AC_10 #21 or
    MTC_AC_11;
  MTC_AC_13= MTC_AC_Outputs;
  MTC_AC_14= MTC_AC_Outputs;
  MTC_CC_1_A= MTC_AC_12;
  MTC_CC_2_A= MTC_AC_2;
  MTC_CC_3_A= MTC_AC_3;
  MTC_CC_4_A= MTC_AC_4;
  MTC_CC_5_A= MTC_AC_5;
  MTC_CC_6_A= MTC_AC_6;
  MTC_CC_7_A= MTC_AC_7;
  MTC_CC_8_A= MTC_AC_8;
  MTC_CC_9_A= MTC_AC_9;
  MTC_CC_10_A= MTC_AC_10;
  MTC_CC_11_A= MTC_AC_11;
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS1_MTC_OBS(MTC_CC_1_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS2_MTC_OBS(MTC_CC_2_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS3_MTC_OBS(MTC_CC_3_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS4_MTC_OBS(MTC_CC_4_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS5_MTC_OBS(MTC_CC_5_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS6_MTC_OBS(MTC_CC_6_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS7_MTC_OBS(MTC_CC_7_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS8_MTC_OBS(MTC_CC_8_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS9_MTC_OBS(MTC_CC_9_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS10_MTC_OBS(MTC_CC_10_A, MTC_INSTRU);
  ()=
    #1 MTCEx::MTC_Observers::Mean_10_Table_PATHS11_MTC_OBS(MTC_CC_11_A, MTC_INSTRU);
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/Operator12.xscade */
function Push_Table(
    Input1 : Ten_Values_Table;
    newData : Data;
    MTC_AC_Outputs : bool;
    MTC_INSTRU : bool)
  returns (Output1 : Ten_Values_Table)
var
  _L1 : Ten_Values_Table;
  _L13 : Data;
  _L15 : Data^(9 - 1 + 1 + 1);
  _L18 : Data^(9 - 1 + 1);
  _L19 : Data^1;
let
  _L1= Input1;
  _L13= newData;
  Output1= _L15;
  _L15= _L18 #1 @ _L19;
  _L18= _L1 #1 [1 .. 9];
  _L19= (_L13)#1^1;
  _= MTC_AC_Outputs;
  _= MTC_INSTRU;
tel


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/libdigital_MTC_INST/digital.xscade */
package digital
  node FallingEdge(FE_Input : bool) returns (FE_Output : bool)
  var
    _L1 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : bool;
    _L6 : bool;
  let
    _L1= FE_Input;
    FE_Output= _L6;
    _L3= _L4 #1 and _L5;
    _L4= #2 fby(_L1; 1; false);
    _L5= #3 not _L1;
    _L6= (false) #1 -> (_L3);
  tel

  node FallingEdgeNoRetrigger(FENR_Input : bool; NumberOfCycle : 'T)
    returns (FENR_Output : bool)
    where 'T integer
  var
    _L10 : bool;
    _L11 : bool;
    _L12 : bool;
    _L22 : 'T;
    _L23 : bool;
    _L26 : 'T;
    _L36 : bool;
    _L37 : bool;
    _L9 : bool;
    _L40 : bool;
    _L47 : bool;
    _L50 : bool;
    _L61 : bool;
    _L63 : bool;
    _L64 : bool;
    _L65 : 'T;
    _L68 : 'T;
  let
    _L9= FENR_Input;
    FENR_Output= _L40;
    _L10= #pre1 fby(_L9; 1; false);
    _L11= #2 not _L9;
    _L12= _L11 #3 and _L10;
    _L22= (0 #2 : 'T);
    _L23= _L22 #4 < _L65;
    _L26= NumberOfCycle;
    _L36= _L37 #5 and _L63;
    _L37= #6 not _L50;
    _L40= _L47 #7 and _L23;
    _L47= _L50 #8 or _L63;
    _L50= #9 fby(_L40; 1; _L61);
    _L61= false;
    _L63= (_L64) #10 -> (_L12);
    _L64= false;
    _L65= ( activate #13 count_down every _L47 initial default (_L68))(_L36, _L26);
    _L68= (0 #1 : 'T);
  tel

  node FallingEdgeRetrigger(FER_Input : bool; NumberOfCycle : 'T)
    returns (FER_Output : bool)
    where 'T integer
  var
    _L1 : bool;
    _L76 : bool;
    _L74 : bool;
    _L73 : bool;
    _L71 : 'T;
    _L70 : bool;
    _L68 : bool;
    _L65 : bool;
    _L64 : bool;
    _L63 : 'T;
    _L62 : bool;
    _L61 : bool;
    _L59 : bool;
    _L77 : 'T;
    _L79 : 'T;
  let
    _L1= FER_Input;
    FER_Output= _L62;
    _L76= _L63 #1 < _L77;
    _L74= false;
    _L73= #2 fby(_L62; 1; _L74);
    _L71= NumberOfCycle;
    _L70= false;
    _L68= _L61 #3 and _L59;
    _L65= _L73 #4 or _L64;
    _L64= (_L70) #5 -> (_L68);
    _L63= (0 #2 : 'T);
    _L62= _L65 #8 and _L76;
    _L61= #9 not _L1;
    _L59= #pre10 fby(_L1; 1; false);
    _L77= ( activate #11 count_down every _L65 initial default (_L79))(_L64, _L71);
    _L79= (0 #1 : 'T);
  tel

  node FlipFlopJK(Set : bool; Reset : bool; Init : bool)
    returns (Output : bool last = Init)
  var
    _L10 : bool;
    _L5 : bool;
    _L6 : bool;
    _L18 : bool;
    _L20 : bool;
    _L21 : bool;
    _L22 : bool;
    _L23 : bool;
    _L24 : bool;
  let
    _L5= Set;
    _L6= Reset;
    Output= _L10;
    _L10= #5 if _L24 then (_L22) else (_L18);
    _L18= _L5 #10 or _L21;
    _L20= #11 not _L6;
    _L21= _L20 #12 and _L23;
    _L22= #12 not last 'Output;
    _L23= last 'Output;
    _L24= Set #13 and Reset;
  tel

  node #pragma kcg expand #end FlipFlopReset(
      Set : bool;
      Reset : bool;
      Init : bool;
      MTC_AC_FFR_Output : bool)
    returns (
      FFR_Output : bool;
      MTC_AC_Set : bool default = false;
      MTC_AC_Reset : bool default = false;
      MTC_AC_Init : bool default = false)
  var
    _L10 : bool;
    _L2 : bool;
    _L4 : bool;
    _L7 : bool;
    _L8 : bool;
    _L11 : bool;
    _L12 : bool;
    _L14 : bool;
  let
    _L2= (_L10) #1 -> (_L14);
    _L4= #pre4 fby(_L2; 1; false);
    _L7= Set;
    _L8= Reset;
    FFR_Output= _L2;
    _L10= Init;
    _L11= _L7 #5 or _L4;
    _L12= #6 not _L8;
    _L14= _L12 #7 and _L11;
    _= MTC_AC_FFR_Output;
    MTC_AC_Set= false;
    MTC_AC_Reset= false;
    MTC_AC_Init= false;
  tel

  node #pragma kcg expand #end FlipFlopSet(
      Set : bool;
      Reset : bool;
      Init : bool;
      MTC_AC_FFS_Output : bool)
    returns (
      FFS_Output : bool;
      MTC_AC_Set : bool default = false;
      MTC_AC_Reset : bool default = false;
      MTC_AC_Init : bool default = false)
  var
    _L10 : bool;
    _L2 : bool;
    _L4 : bool;
    _L5 : bool;
    _L6 : bool;
    _L11 : bool;
    _L12 : bool;
    _L13 : bool;
  let
    _L2= (_L10) #1 -> (_L13);
    _L4= #pre4 fby(_L2; 1; false);
    FFS_Output= _L2;
    _L5= Set;
    _L6= Reset;
    _L10= Init;
    _L11= #5 not _L6;
    _L12= _L11 #6 and _L4;
    _L13= _L5 #7 or _L12;
    _= MTC_AC_FFS_Output;
    MTC_AC_Set= false;
    MTC_AC_Reset= false;
    MTC_AC_Init= false;
  tel

  node RisingEdge(RE_Input : bool) returns (RE_Output : bool)
  var
    _L1 : bool;
    _L6 : bool;
    _L3 : bool;
    _L8 : bool;
    _L9 : bool;
  let
    _L1= RE_Input;
    RE_Output= _L9;
    _L3= #1 fby(_L1; 1; false);
    _L6= _L8 #2 and _L1;
    _L8= #3 not _L3;
    _L9= (false) #1 -> (_L6);
  tel

  node RisingEdgeRetrigger(RER_Input : bool; NumberOfCycle : 'T)
    returns (RER_Output : bool)
    where 'T integer
  var
    _L13 : bool;
    _L14 : bool;
    _L16 : bool;
    _L31 : bool;
    _L44 : 'T;
    _L43 : bool;
    _L41 : 'T;
    _L39 : bool;
    _L38 : bool;
    _L36 : bool;
    _L35 : bool;
    _L46 : bool;
    _L47 : bool;
    _L48 : 'T;
    _L50 : 'T;
  let
    RER_Output= _L43;
    _L13= RER_Input;
    _L14= #pre1 fby(_L31; 1; false);
    _L16= _L13 #2 and _L14;
    _L31= #3 not _L13;
    _L44= (0 #2 : 'T);
    _L43= _L38 #4 and _L35;
    _L41= NumberOfCycle;
    _L39= #5 fby(_L43; 1; _L36);
    _L38= _L39 #6 or _L46;
    _L36= false;
    _L35= _L44 #7 < _L48;
    _L46= (_L47) #8 -> (_L16);
    _L47= false;
    _L48= ( activate #11 count_down every _L38 initial default (_L50))(_L46, _L41);
    _L50= (0 #1 : 'T);
  tel

  function #pragma kcg expand #end Toggle(
      T_Input : bool;
      MTC_AC_T_On : bool;
      MTC_AC_T_Off : bool)
    returns (T_On : bool; T_Off : bool; MTC_AC_T_Input : bool default = false)
  var
    _L3 : bool;
    _L9 : bool;
  let
    _L3= T_Input;
    T_On= _L3;
    T_Off= _L9;
    _L9= #1 not _L3;
    _= MTC_AC_T_On;
    _= MTC_AC_T_Off;
    MTC_AC_T_Input= false;
  tel

  node RisingEdgeNoRetrigger(RENR_Input : bool; NumberOfCycle : 'T)
    returns (RENR_Output : bool)
    where 'T integer
  var
    _L90 : bool;
    _L87 : bool;
    _L86 : 'T;
    _L85 : bool;
    _L84 : bool;
    _L82 : bool;
    _L81 : bool;
    _L80 : 'T;
    _L79 : bool;
    _L78 : bool;
    _L77 : bool;
    _L76 : bool;
    _L75 : bool;
    _L91 : bool;
    _L92 : bool;
    _L93 : 'T;
    _L95 : 'T;
  let
    RENR_Output= _L78;
    _L90= _L80 #1 < _L93;
    _L87= #2 fby(_L78; 1; _L92);
    _L86= NumberOfCycle;
    _L85= _L91 #3 and _L76;
    _L84= false;
    _L82= _L87 #4 or _L79;
    _L81= _L75 #5 and _L79;
    _L80= (0 #2 : 'T);
    _L79= (_L84) #6 -> (_L85);
    _L78= _L82 #9 and _L90;
    _L77= #10 not _L91;
    _L76= #pre11 fby(_L77; 1; false);
    _L75= #12 not _L87;
    _L91= RENR_Input;
    _L92= false;
    _L93= ( activate #13 count_down every _L82 initial default (_L95))(_L81, _L86);
    _L95= (0 #1 : 'T);
  tel

  node count_down(Reset : bool; N : 'T) returns (cpt : 'T) where 'T integer
  var
    _L1 : bool;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L13 : 'T;
  let
    _L1= Reset;
    _L2= N;
    cpt= _L3;
    _L3= #1 if _L1 then (_L2) else (_L8);
    _L4= _L3 #4 - _L7;
    _L7= (1 #1 : 'T);
    _L8= (_L2) #5 -> (_L13);
    _L13= #pre8 fby(_L4; 1; (0 : 'T));
  tel

  node EitherEdge(EE_Input : bool) returns (EE_Output : bool)
  var
    _L1 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : bool;
  let
    _L1= EE_Input;
    EE_Output= _L5;
    _L3= _L4 #1 xor _L1;
    _L4= #2 fby(_L1; 1; false);
    _L5= (false) #1 -> (_L3);
  tel

  function #pragma kcg expand #end BoolVect2IntElt(
      Acc : 'T;
      bi : bool;
      MTC_AC_AccOut : bool)
    returns (
      AccOut : 'T;
      MTC_AC_Acc : bool default = false;
      MTC_AC_bi : bool default = false)
    where 'T integer
  var
    _L1 : 'T;
    _L2 : bool;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : 'T;
  let
    AccOut= _L8;
    _L1= Acc;
    _L2= bi;
    _L4= _L1 #1 * _L9;
    _L5= #2 if _L2 then (_L6) else (_L7);
    _L6= (1 #2 : 'T);
    _L7= (0 #3 : 'T);
    _L8= _L5 #5 + _L4;
    _L9= (2 #1 : 'T);
    _= MTC_AC_AccOut;
    MTC_AC_Acc= false;
    MTC_AC_bi= false;
  tel

  function Int2BoolVectElt(Acc : 'T; MTC_AC_Outputs : bool)
    returns (AccOut : 'T; bi : bool)
    where 'T integer
  var
    _L1 : 'T;
    _L9 : 'T;
    _L10 : 'T;
    _L11 : 'T;
    _L12 : bool;
    _L13 : 'T;
  let
    AccOut= _L10;
    _L1= Acc;
    _L9= (2 #1 : 'T);
    _L10= _L1 #1 / _L9;
    bi= _L12;
    _L11= _L1 #2 mod _L9;
    _L12= _L11 #3 = _L13;
    _L13= (1 #2 : 'T);
    _= MTC_AC_Outputs;
  tel

  function BoolVect2Int8<<Nbool>>(BV : bool^Nbool; MTC_AC_Outputs : bool)
    returns (Out : int8)
  var
    _L2 : int8;
    _L3 : int8;
    _L4 : bool^Nbool;
  let
    _L2=
      ( fold
        #1 MTCEx::MTC_Instrumenters::digital_BoolVect2IntElt_MTC_INST
        <<Nbool>>)(_L3, _L4, (false)^Nbool, (false)^Nbool);
    _L3= (0 #2 : int8);
    _L4= BV;
    Out= _L2;
    _= MTC_AC_Outputs;
  tel

  function Int2BoolVect<<Nbool>>(In : 'T; MTC_AC_Outputs : bool)
    returns (BV : bool^Nbool)
    where 'T integer
  var
    #pragma kcg keep #end Acc : 'T;
    _L1 : 'T;
    _L4 : bool^Nbool;
    _L5 : bool^Nbool;
  let
    _L1= In;
    BV= _L5;
    Acc, _L4= ( mapfold 1 #1 Int2BoolVectElt <<Nbool>>)(_L1, (false)^Nbool);
    _L5= #3 reverse _L4;
    _= Acc;
    _= MTC_AC_Outputs;
  tel

  function BoolVect2Int16<<Nbool>>(BV : bool^Nbool; MTC_AC_Outputs : bool)
    returns (Out : int16)
  var
    _L2 : int16;
    _L3 : int16;
    _L4 : bool^Nbool;
  let
    _L2=
      ( fold
        #1 MTCEx::MTC_Instrumenters::digital_BoolVect2IntElt_MTC_INST
        <<Nbool>>)(_L3, _L4, (false)^Nbool, (false)^Nbool);
    _L3= (0 #2 : int16);
    _L4= BV;
    Out= _L2;
    _= MTC_AC_Outputs;
  tel

  function BoolVect2Uint16<<Nbool>>(BV : bool^Nbool; MTC_AC_Outputs : bool)
    returns (Out : uint16)
  var
    _L2 : uint16;
    _L3 : uint16;
    _L4 : bool^Nbool;
  let
    _L2=
      ( fold
        #1 MTCEx::MTC_Instrumenters::digital_BoolVect2IntElt_MTC_INST
        <<Nbool>>)(_L3, _L4, (false)^Nbool, (false)^Nbool);
    _L3= (0 #2 : uint16);
    _L4= BV;
    Out= _L2;
    _= MTC_AC_Outputs;
  tel

  function BoolVect2Uint32<<Nbool>>(BV : bool^Nbool; MTC_AC_Outputs : bool)
    returns (Out : uint32)
  var
    _L2 : uint32;
    _L3 : uint32;
    _L4 : bool^Nbool;
  let
    _L2=
      ( fold
        #1 MTCEx::MTC_Instrumenters::digital_BoolVect2IntElt_MTC_INST
        <<Nbool>>)(_L3, _L4, (false)^Nbool, (false)^Nbool);
    _L3= (0 #2 : uint32);
    _L4= BV;
    Out= _L2;
    _= MTC_AC_Outputs;
  tel

  function BoolVect2Uint64<<Nbool>>(BV : bool^Nbool; MTC_AC_Outputs : bool)
    returns (Out : uint64)
  var
    _L2 : uint64;
    _L3 : uint64;
    _L4 : bool^Nbool;
  let
    _L2=
      ( fold
        #1 MTCEx::MTC_Instrumenters::digital_BoolVect2IntElt_MTC_INST
        <<Nbool>>)(_L3, _L4, (false)^Nbool, (false)^Nbool);
    _L3= (0 #3 : uint64);
    _L4= BV;
    Out= _L2;
    _= MTC_AC_Outputs;
  tel

  function BoolVect2Uint8<<Nbool>>(BV : bool^Nbool; MTC_AC_Outputs : bool)
    returns (Out : uint8)
  var
    _L2 : uint8;
    _L3 : uint8;
    _L4 : bool^Nbool;
  let
    _L2=
      ( fold
        #1 MTCEx::MTC_Instrumenters::digital_BoolVect2IntElt_MTC_INST
        <<Nbool>>)(_L3, _L4, (false)^Nbool, (false)^Nbool);
    _L3= (0 #2 : uint8);
    _L4= BV;
    Out= _L2;
    _= MTC_AC_Outputs;
  tel

  function BoolVect2Int32<<Nbool>>(BV : bool^Nbool; MTC_AC_Outputs : bool)
    returns (Out : int32)
  var
    _L2 : int32;
    _L3 : int32;
    _L4 : bool^Nbool;
  let
    _L2=
      ( fold
        #1 MTCEx::MTC_Instrumenters::digital_BoolVect2IntElt_MTC_INST
        <<Nbool>>)(_L3, _L4, (false)^Nbool, (false)^Nbool);
    _L3= (0 #3 : int32);
    _L4= BV;
    Out= _L2;
    _= MTC_AC_Outputs;
  tel

  function BoolVect2Int64<<Nbool>>(BV : bool^Nbool; MTC_AC_Outputs : bool)
    returns (Out : int64)
  var
    _L2 : int64;
    _L3 : int64;
    _L4 : bool^Nbool;
  let
    _L2=
      ( fold
        #1 MTCEx::MTC_Instrumenters::digital_BoolVect2IntElt_MTC_INST
        <<Nbool>>)(_L3, _L4, (false)^Nbool, (false)^Nbool);
    _L3= (0 #2 : int64);
    _L4= BV;
    Out= _L2;
    _= MTC_AC_Outputs;
  tel

  node InactiveTime(Cond : bool; TimeCycle : 'T)
    returns (DeltaT : 'T)
    where 'T numeric
  var
    Cpt : 'T last = (0 #2 : 'T);
    _L1 : bool;
    _L2 : 'T;
    _L6 : 'T;
    _L8 : 'T;
    _L9 : 'T;
    _L10 : 'T;
  let
    _L1= Cond;
    _L2= last 'Cpt;
    _L6= _L2 #1 + _L10;
    _L8= #1 if _L1 then (_L9) else (_L6);
    _L9= (0 #3 : 'T);
    Cpt= _L8;
    _L10= TimeCycle;
    DeltaT= _L6;
  tel

  node InactiveCycles(Cond : bool) returns (DeltaCycles : int32)
  var
    Cpt : int32 last = 0;
    _L1 : bool;
    _L2 : int32;
    _L6 : int32;
    _L8 : int32;
    _L9 : int32;
    _L13 : int32;
  let
    _L1= Cond;
    _L2= last 'Cpt;
    _L6= _L2 #1 + _L13;
    _L8= #1 if _L1 then (_L9) else (_L6);
    _L9= 0;
    Cpt= _L8;
    DeltaCycles= _L6;
    _L13= (1 #1 : int32);
  tel

  node Relay(
      Input1 : 'T;
      UpperLimit_On : 'T;
      LowerLimit_Off : 'T;
      OutputWhenOn : 'T;
      OutputWhenOff : 'T)
    returns (Output1 : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L11 : bool;
    _L14 : 'T;
    _L16 : bool;
    _L17 : 'T;
    _L18 : bool;
    _L19 : 'T;
    _L20 : 'T;
    _L22 : 'T;
  let
    _L1= Input1;
    _L2= UpperLimit_On;
    _L4= LowerLimit_Off;
    _L5= OutputWhenOn;
    _L6= OutputWhenOff;
    _L11= _L20 #1 = _L22;
    _L14= #1 if _L11 then (_L17) else (_L19);
    _L16= _L1 #1 >= _L2;
    _L17= #2 if _L16 then (_L5) else (_L6);
    _L18= _L1 #1 <= _L4;
    _L19= #3 if _L18 then (_L6) else (_L5);
    Output1= _L14;
    _L20= #1 fby(_L14; 1; _L22);
    _L22= OutputWhenOff;
  tel

  node TriggerRise(Input : 'T) returns (Output : bool) where 'T numeric
  var
    _L1 : 'T;
    _L4 : bool;
    _L10 : bool;
    _L18 : bool;
    _L22 : 'T;
  let
    _L1= Input;
    _L4= _L1 #1 < _L22;
    Output= _L18;
    _L10= _L22 #1 = _L1;
    _L18= #1 EntryDetect(_L4, _L10);
    _L22= (0 #3 : 'T);
  tel

  node TriggerFall(Input : 'T) returns (Output : bool) where 'T numeric
  var
    _L25 : 'T;
    _L29 : bool;
    _L28 : bool;
    _L26 : bool;
    _L33 : 'T;
  let
    _L25= Input;
    Output= _L26;
    _L26= #1 EntryDetect(_L29, _L28);
    _L28= _L33 #1 = _L25;
    _L29= _L25 #1 > _L33;
    _L33= (0 #3 : 'T);
  tel

  node EntryDetect(Outside : bool; OnTheBorder : bool) returns (Entry : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L10 : bool;
    _L14 : bool;
    _L22 : bool;
    _L25 : bool;
    _L26 : bool;
    _L27 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
  let
    _L1= Outside;
    _L2= OnTheBorder;
    _L3= _L22 #1 or _L10 #1 or _L14;
    _L10= _L26 #1 and _L2;
    _L27= #1 fby(_L2; 1; _L2);
    _L28= #2 fby(_L3; 1; false);
    _L26= #3 fby(_L1; 1; _L1);
    _L14= _L29 #2 and _L27 #2 and _L30;
    _L25= _L1 #2 or _L2;
    _L22= _L26 #3 and _L29;
    Entry= _L3;
    _L29= #1 not _L25;
    _L30= #2 not _L28;
  tel

  node TriggerEither(Input : 'T) returns (Output : bool) where 'T numeric
  var
    _L8 : 'T;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
  let
    _L8= Input;
    Output= _L28;
    _L28= _L29 #1 or _L30;
    _L29= #2 TriggerFall(_L8);
    _L30= #2 TriggerRise(_L8);
  tel

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/libdigital_MTC_INST/TruthTables.xscade */
package truthtables
  open digital;
  type TruthTableValues = enum { T, F, X };

  function TruthTableElt(
      AccIn : bool;
      Cond : bool;
      TTelt : TruthTableValues;
      MTC_AC_Outputs : bool)
    returns (AccOut : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L13 : bool;
    _L15 : bool;
    _L14 : bool;
    _L16 : bool;
    _L17 : TruthTableValues;
  let
    _L1= _L2 #1 and _L13;
    _L2= AccIn;
    AccOut= _L1;
    _L13= (#2 case _L17 of | T: _L14 | F: _L15 | _: _L16);
    _L14= Cond;
    _L15= #5 not _L14;
    _L16= true;
    _L17= TTelt;
    _= MTC_AC_Outputs;
  tel

  function TruthTableLineIdx<<Ncond>>(
      Idx : int16;
      AccIn : int16;
      Conditions : bool^Ncond;
      TTline : TruthTableValues^Ncond;
      MTC_AC_Outputs : bool)
    returns (AccOut : int16)
  var
    _L2 : bool;
    _L3 : int16;
    _L4 : int16;
    _L8 : int16;
    _L10 : bool^Ncond;
    _L11 : bool;
    _L12 : TruthTableValues^Ncond;
  let
    _L2= ( fold #1 TruthTableElt <<Ncond>>)(_L11, _L10, _L12, (false)^Ncond);
    _L3= #3 if _L2 then (_L8) else (_L4);
    AccOut= _L3;
    _L4= AccIn;
    _L8= Idx;
    _L10= Conditions;
    _L11= true;
    _L12= TTline;
    _= MTC_AC_Outputs;
  tel

  function TruthTableIdx<<Ncond, Nlines>>(
      Conditions : bool^Ncond;
      Ttable : TruthTableValues^Ncond^Nlines;
      MTC_AC_Outputs : bool)
    returns (LineIdx : int16)
  var
    _L1 : bool^Ncond;
    _L2 : TruthTableValues^Ncond^Nlines;
    _L6 : int16;
    _L8 : bool^Ncond^Nlines;
    _L9 : TruthTableValues^Ncond^Nlines;
    _L10 : int16;
    _L11 : int16;
    _L12 : int16;
  let
    _L1= Conditions;
    _L2= Ttable;
    LineIdx= _L10;
    _L6= #1 - (1 #2 : int16);
    _L8= (_L1)#3^Nlines;
    _L9= #4 reverse _L2;
    _L10= _L11 #5 - _L12;
    _L11= (Nlines #4 : int16) #7 - (1 #5 : int16);
    _L12=
      ( foldi (#2 TruthTableLineIdx <<Ncond>>) <<Nlines>>)(_L6, _L8, _L9, (
          false)^Nlines);
    _= MTC_AC_Outputs;
  tel

  function TruthTableExh<<Nbool, Nres>>(
      BV : bool^Nbool;
      ResultValues : 'T^Nres;
      MTC_AC_Outputs : bool)
    returns (Result : 'T)
  var
    _L1 : bool^Nbool;
    _L3 : 'T;
    _L4 : 'T^Nres;
    _L5 : int8;
  let
    _L1= BV;
    _L3= (_L4#1 . [_L5] default ResultValues #0[0]);
    _L4= ResultValues;
    Result= _L3;
    _L5= (#3 BoolVect2Int8 <<Nbool>>)(_L1, false);
    assume A1 : Nres #4 =
    ( fold #3 $*$ <<Nbool>>)((1 #1 : int32), ((2 #2 : int32))#2^Nbool);
    _= MTC_AC_Outputs;
  tel

  function TruthTableLine<<Ncond>>(
      AccIn : 'T;
      Conditions : bool^Ncond;
      ResultValue : 'T;
      TTline : TruthTableValues^Ncond;
      MTC_AC_Outputs : bool)
    returns (Continue : bool; AccOut : 'T)
  var
    _L2 : bool;
    _L3 : 'T;
    _L4 : 'T;
    _L10 : bool^Ncond;
    _L11 : bool;
    _L12 : TruthTableValues^Ncond;
    _L14 : 'T;
    _L15 : bool;
  let
    _L2= ( fold #1 TruthTableElt <<Ncond>>)(_L11, _L10, _L12, (false)^Ncond);
    _L3= #3 if _L2 then (_L14) else (_L4);
    AccOut= _L3;
    _L4= AccIn;
    _L10= Conditions;
    _L11= true;
    _L12= TTline;
    _L14= ResultValue;
    Continue= _L15;
    _L15= #6 not _L2;
    _= MTC_AC_Outputs;
  tel

  function TruthTable<<Ncond, Nlines>>(
      Conditions : bool^Ncond;
      ResultValues : 'T^(Nlines + 1);
      Ttable : TruthTableValues^Ncond^Nlines;
      MTC_AC_Outputs : bool)
    returns (Result : 'T)
  var
    _L1 : bool^Ncond;
    _L2 : TruthTableValues^Ncond^Nlines;
    _L7 : 'T^(Nlines + 1);
    _L9 : bool^Ncond^Nlines;
    _L12 : 'T;
    _L16 : 'T^(Nlines + 1);
    _L17 : bool;
    _L19 : 'T;
    _L18 : int16;
    _L21 : 'T^(Nlines - 1 - 0 + 1);
  let
    _L1= Conditions;
    _L2= Ttable;
    Result= _L19;
    _L7= ResultValues;
    _L9= (_L1)#1^Nlines;
    _L12= _L16 #3[Nlines];
    _L16= ResultValues;
    _L17= true;
    _L18, _L19=
      ( foldw (#4 TruthTableLine <<Ncond>>) <<Nlines>> if _L17)(_L12, _L9, _L21,
        _L2, (false)^Nlines);
    _= _L18;
    _L21= _L7 #6 [0 .. Nlines - 1];
    _= MTC_AC_Outputs;
  tel

end;


/* xscade source: C:/Program Files/ANSYS Inc/v192/SCADE/SCADE/libraries/SC65/libmtc/MTC.xscade */
package MTC
  type
    imported #pragma kcg C:name Result_MTC #end
    #pragma kcg 
							Ada:name Result_MTC
						 #end Result is integer;

  node imported LATCH(Input1 : bool) returns (Output1 : bool);

  node imported #pragma kcg C:name LATCHALL01_MTC #end
    #pragma kcg 
			Ada:name LATCHALL01_MTC
		 #end LATCHALL01(Input1 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL02_MTC #end
    #pragma kcg 
			Ada:name LATCHALL02_MTC
		 #end LATCHALL02(
      Input1 : bool;
      Input2 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL03_MTC #end
    #pragma kcg 
			Ada:name LATCHALL03_MTC
		 #end LATCHALL03(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL04_MTC #end
    #pragma kcg 
			Ada:name LATCHALL04_MTC
		 #end LATCHALL04(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL05_MTC #end
    #pragma kcg 
			Ada:name LATCHALL05_MTC
		 #end LATCHALL05(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL06_MTC #end
    #pragma kcg 
			Ada:name LATCHALL06_MTC
		 #end LATCHALL06(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL07_MTC #end
    #pragma kcg 
			Ada:name LATCHALL07_MTC
		 #end LATCHALL07(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL08_MTC #end
    #pragma kcg 
			Ada:name LATCHALL08_MTC
		 #end LATCHALL08(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL09_MTC #end
    #pragma kcg 
			Ada:name LATCHALL09_MTC
		 #end LATCHALL09(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL10_MTC #end
    #pragma kcg 
			Ada:name LATCHALL10_MTC
		 #end LATCHALL10(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL11_MTC #end
    #pragma kcg 
			Ada:name LATCHALL11_MTC
		 #end LATCHALL11(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL12_MTC #end
    #pragma kcg 
			Ada:name LATCHALL12_MTC
		 #end LATCHALL12(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL13_MTC #end
    #pragma kcg 
			Ada:name LATCHALL13_MTC
		 #end LATCHALL13(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL14_MTC #end
    #pragma kcg 
			Ada:name LATCHALL14_MTC
		 #end LATCHALL14(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL15_MTC #end
    #pragma kcg 
			Ada:name LATCHALL15_MTC
		 #end LATCHALL15(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL16_MTC #end
    #pragma kcg 
			Ada:name LATCHALL16_MTC
		 #end LATCHALL16(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL17_MTC #end
    #pragma kcg 
			Ada:name LATCHALL17_MTC
		 #end LATCHALL17(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL18_MTC #end
    #pragma kcg 
			Ada:name LATCHALL18_MTC
		 #end LATCHALL18(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL19_MTC #end
    #pragma kcg 
			Ada:name LATCHALL19_MTC
		 #end LATCHALL19(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL20_MTC #end
    #pragma kcg 
			Ada:name LATCHALL20_MTC
		 #end LATCHALL20(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL21_MTC #end
    #pragma kcg 
			Ada:name LATCHALL21_MTC
		 #end LATCHALL21(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL22_MTC #end
    #pragma kcg 
			Ada:name LATCHALL22_MTC
		 #end LATCHALL22(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL23_MTC #end
    #pragma kcg 
			Ada:name LATCHALL23_MTC
		 #end LATCHALL23(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool;
      Input23 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL24_MTC #end
    #pragma kcg 
			Ada:name LATCHALL24_MTC
		 #end LATCHALL24(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool;
      Input23 : bool;
      Input24 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL25_MTC #end
    #pragma kcg 
			Ada:name LATCHALL25_MTC
		 #end LATCHALL25(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool;
      Input23 : bool;
      Input24 : bool;
      Input25 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL26_MTC #end
    #pragma kcg 
			Ada:name LATCHALL26_MTC
		 #end LATCHALL26(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool;
      Input23 : bool;
      Input24 : bool;
      Input25 : bool;
      Input26 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL27_MTC #end
    #pragma kcg 
			Ada:name LATCHALL27_MTC
		 #end LATCHALL27(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool;
      Input23 : bool;
      Input24 : bool;
      Input25 : bool;
      Input26 : bool;
      Input27 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL28_MTC #end
    #pragma kcg 
			Ada:name LATCHALL28_MTC
		 #end LATCHALL28(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool;
      Input23 : bool;
      Input24 : bool;
      Input25 : bool;
      Input26 : bool;
      Input27 : bool;
      Input28 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL29_MTC #end
    #pragma kcg 
			Ada:name LATCHALL29_MTC
		 #end LATCHALL29(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool;
      Input23 : bool;
      Input24 : bool;
      Input25 : bool;
      Input26 : bool;
      Input27 : bool;
      Input28 : bool;
      Input29 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL30_MTC #end
    #pragma kcg 
			Ada:name LATCHALL30_MTC
		 #end LATCHALL30(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool;
      Input23 : bool;
      Input24 : bool;
      Input25 : bool;
      Input26 : bool;
      Input27 : bool;
      Input28 : bool;
      Input29 : bool;
      Input30 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL31_MTC #end
    #pragma kcg 
			Ada:name LATCHALL31_MTC
		 #end LATCHALL31(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool;
      Input23 : bool;
      Input24 : bool;
      Input25 : bool;
      Input26 : bool;
      Input27 : bool;
      Input28 : bool;
      Input29 : bool;
      Input30 : bool;
      Input31 : bool)
    returns (Output1 : Result);

  node imported #pragma kcg C:name LATCHALL32_MTC #end
    #pragma kcg 
			Ada:name LATCHALL32_MTC
		 #end LATCHALL32(
      Input1 : bool;
      Input2 : bool;
      Input3 : bool;
      Input4 : bool;
      Input5 : bool;
      Input6 : bool;
      Input7 : bool;
      Input8 : bool;
      Input9 : bool;
      Input10 : bool;
      Input11 : bool;
      Input12 : bool;
      Input13 : bool;
      Input14 : bool;
      Input15 : bool;
      Input16 : bool;
      Input17 : bool;
      Input18 : bool;
      Input19 : bool;
      Input20 : bool;
      Input21 : bool;
      Input22 : bool;
      Input23 : bool;
      Input24 : bool;
      Input25 : bool;
      Input26 : bool;
      Input27 : bool;
      Input28 : bool;
      Input29 : bool;
      Input30 : bool;
      Input31 : bool;
      Input32 : bool)
    returns (Output1 : Result);

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/libmtcModelisation_Surveillance_MTC_INST/MTCEx.xscade */
package MTCEx
  package MTC_Observers
    node #pragma kcg expand #end Check_interval_Temperature_PATHS1_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_CC_3_T : bool;
        MTC_CC_4_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL04 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F, MTC_CC_3_T, MTC_CC_4_F);
    tel

    node #pragma kcg expand #end Check_interval_pH_PATHS1_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_CC_3_T : bool;
        MTC_CC_4_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL04 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F, MTC_CC_3_T, MTC_CC_4_F);
    tel

    node #pragma kcg expand #end Check_interval_Redox_PATHS1_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_CC_3_T : bool;
        MTC_CC_4_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL04 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F, MTC_CC_3_T, MTC_CC_4_F);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS1_MTC_OBS(
        MTC_CC_1_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_1_A);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS2_MTC_OBS(
        MTC_CC_2_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_2_A);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS3_MTC_OBS(
        MTC_CC_3_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_3_A);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS4_MTC_OBS(
        MTC_CC_4_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_4_A);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS5_MTC_OBS(
        MTC_CC_5_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_5_A);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS6_MTC_OBS(
        MTC_CC_6_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_6_A);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS7_MTC_OBS(
        MTC_CC_7_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_7_A);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS8_MTC_OBS(
        MTC_CC_8_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_8_A);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS9_MTC_OBS(
        MTC_CC_9_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_9_A);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS10_MTC_OBS(
        MTC_CC_10_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_10_A);
    tel

    node #pragma kcg expand #end Mean_10_Table_PATHS11_MTC_OBS(
        MTC_CC_11_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_11_A);
    tel

    node #pragma kcg expand #end math_Abs_PATHS1_MTC_OBS(
        MTC_CC_3_A : bool;
        MTC_CC_4_A : bool;
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL04 every MTC_INSTRU default (0))(MTC_CC_3_A,
          MTC_CC_4_A, MTC_CC_1_T, MTC_CC_2_F);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS1_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F);
    tel

    node #pragma kcg expand #end CONTROL_MTC_OBS(
        MTC_CC_1 : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1= ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_1);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS2_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS3_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS4_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS5_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS6_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS7_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end math_Mean3_MTC_OBS(MTC_INSTRU : bool)
      returns ()
    var
      MTC_ACTIVATED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_ACTIVATED);
    tel

    node #pragma kcg expand #end math_Mean_MTC_OBS(MTC_INSTRU : bool) returns ()
    var
      MTC_ACTIVATED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_ACTIVATED);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS8_MTC_OBS(
        MTC_CC_9_A : bool;
        MTC_CC_10_T : bool;
        MTC_CC_11_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL03 every MTC_INSTRU default (0))(MTC_CC_9_A,
          MTC_CC_10_T, MTC_CC_11_F);
    tel

    node #pragma kcg expand #end math_Abs_MTC_OBS(MTC_INSTRU : bool) returns ()
    var
      MTC_ACTIVATED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_ACTIVATED);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS9_MTC_OBS(
        MTC_CC_12_A : bool;
        MTC_CC_13_T : bool;
        MTC_CC_14_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL03 every MTC_INSTRU default (0))(MTC_CC_12_A,
          MTC_CC_13_T, MTC_CC_14_F);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS10_MTC_OBS(
        MTC_CC_15_A : bool;
        MTC_CC_16_T : bool;
        MTC_CC_17_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL03 every MTC_INSTRU default (0))(MTC_CC_15_A,
          MTC_CC_16_T, MTC_CC_17_F);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS11_MTC_OBS(
        MTC_CC_18_A : bool;
        MTC_CC_19_T : bool;
        MTC_CC_20_F : bool;
        MTC_CC_21_T : bool;
        MTC_CC_22_F : bool;
        MTC_CC_23_T : bool;
        MTC_CC_24_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL07 every MTC_INSTRU default (0))(MTC_CC_18_A,
          MTC_CC_19_T, MTC_CC_20_F, MTC_CC_21_T, MTC_CC_22_F, MTC_CC_23_T,
          MTC_CC_24_F);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS12_MTC_OBS(
        MTC_CC_25_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_25_A);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS13_MTC_OBS(
        MTC_CC_26_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_26_A);
    tel

    node #pragma kcg expand #end Check_Delta_3_PATHS14_MTC_OBS(
        MTC_CC_27_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_27_A);
    tel

    node #pragma kcg expand #end Calculated_value_PATHS1_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_CC_3_T : bool;
        MTC_CC_4_F : bool;
        MTC_CC_5_T : bool;
        MTC_CC_6_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F, MTC_CC_3_T, MTC_CC_4_F, MTC_CC_5_T, MTC_CC_6_F);
    tel

    node #pragma kcg expand #end Calculated_value_PATHS2_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Calculated_value_PATHS3_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Calculated_value_PATHS4_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Calculated_value_PATHS5_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Calculated_value_PATHS6_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Calculated_value_PATHS7_MTC_OBS(
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_4_T : bool;
        MTC_CC_5_F : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F);
    tel

    node #pragma kcg expand #end Check_Delta_3_1111_MTC_OBS(
        Input1 : 'MTC_T0;
        Input2 : 'MTC_T1;
        Input3 : 'MTC_T2;
        Delta : 'MTC_T3;
        MTC_INSTRU : bool)
      returns ()
    var
      MTC_ACTIVATED : bool;
      MTC_Input1_CHANGED : bool;
      MTC_Input2_CHANGED : bool;
      MTC_Input3_CHANGED : bool;
      MTC_Delta_CHANGED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_Input1_CHANGED= #1 MTC_Utils::GenericInputChanged(Input1);
      MTC_Input2_CHANGED= #2 MTC_Utils::GenericInputChanged(Input2);
      MTC_Input3_CHANGED= #3 MTC_Utils::GenericInputChanged(Input3);
      MTC_Delta_CHANGED= #4 MTC_Utils::GenericInputChanged(Delta);
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL05 every MTC_INSTRU default (
          0))(MTC_ACTIVATED, MTC_Input1_CHANGED, MTC_Input2_CHANGED,
          MTC_Input3_CHANGED, MTC_Delta_CHANGED);
    tel

    node #pragma kcg expand #end Calculated_value_PATHS8_MTC_OBS(
        MTC_CC_9_A : bool;
        MTC_CC_10_T : bool;
        MTC_CC_11_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL03 every MTC_INSTRU default (0))(MTC_CC_9_A,
          MTC_CC_10_T, MTC_CC_11_F);
    tel

    node #pragma kcg expand #end Calculated_value_PATHS9_MTC_OBS(
        MTC_CC_12_A : bool;
        MTC_CC_13_T : bool;
        MTC_CC_14_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL03 every MTC_INSTRU default (0))(MTC_CC_12_A,
          MTC_CC_13_T, MTC_CC_14_F);
    tel

    node #pragma kcg expand #end Calculated_value_PATHS10_MTC_OBS(
        MTC_CC_15_A : bool;
        MTC_CC_16_T : bool;
        MTC_CC_17_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL03 every MTC_INSTRU default (0))(MTC_CC_15_A,
          MTC_CC_16_T, MTC_CC_17_F);
    tel

    node #pragma kcg expand #end Vote_Alog_PATHS1_MTC_OBS(
        MTC_CC_1_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_1_A);
    tel

    node #pragma kcg expand #end Vote_Alog_PATHS2_MTC_OBS(
        MTC_CC_4_A : bool;
        MTC_CC_5_A : bool;
        MTC_CC_2_T : bool;
        MTC_CC_3_F : bool;
        MTC_CC_8_A : bool;
        MTC_CC_9_A : bool;
        MTC_CC_6_T : bool;
        MTC_CC_7_F : bool;
        MTC_CC_12_A : bool;
        MTC_CC_13_A : bool;
        MTC_CC_10_T : bool;
        MTC_CC_11_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL12 every MTC_INSTRU default (0))(MTC_CC_4_A,
          MTC_CC_5_A, MTC_CC_2_T, MTC_CC_3_F, MTC_CC_8_A, MTC_CC_9_A,
          MTC_CC_6_T, MTC_CC_7_F, MTC_CC_12_A, MTC_CC_13_A, MTC_CC_10_T,
          MTC_CC_11_F);
    tel

    node #pragma kcg expand #end Calculated_value_1110_MTC_OBS(
        value1 : 'MTC_T0;
        value2 : 'MTC_T1;
        value3 : 'MTC_T2;
        delta : 'MTC_T3;
        MTC_INSTRU : bool)
      returns ()
    var
      MTC_ACTIVATED : bool;
      MTC_value1_CHANGED : bool;
      MTC_value2_CHANGED : bool;
      MTC_value3_CHANGED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_value1_CHANGED= #1 MTC_Utils::GenericInputChanged(value1);
      MTC_value2_CHANGED= #2 MTC_Utils::GenericInputChanged(value2);
      MTC_value3_CHANGED= #3 MTC_Utils::GenericInputChanged(value3);
      _= delta;
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL04 every MTC_INSTRU default (
          0))(MTC_ACTIVATED, MTC_value1_CHANGED, MTC_value2_CHANGED,
          MTC_value3_CHANGED);
    tel

    node #pragma kcg expand #end Check_interval_pH_1_MTC_OBS(
        pH : 'MTC_T0;
        MTC_INSTRU : bool)
      returns ()
    var
      MTC_ACTIVATED : bool;
      MTC_pH_CHANGED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_pH_CHANGED= #1 MTC_Utils::GenericInputChanged(pH);
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (
          0))(MTC_ACTIVATED, MTC_pH_CHANGED);
    tel

    node #pragma kcg expand #end Vote_Alog_PATHS3_MTC_OBS(
        MTC_CC_14_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_14_A);
    tel

    node #pragma kcg expand #end Vote_Alog_PATHS4_MTC_OBS(
        MTC_CC_17_A : bool;
        MTC_CC_18_A : bool;
        MTC_CC_15_T : bool;
        MTC_CC_16_F : bool;
        MTC_CC_21_A : bool;
        MTC_CC_22_A : bool;
        MTC_CC_19_T : bool;
        MTC_CC_20_F : bool;
        MTC_CC_25_A : bool;
        MTC_CC_26_A : bool;
        MTC_CC_23_T : bool;
        MTC_CC_24_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL12 every MTC_INSTRU default (0))(MTC_CC_17_A,
          MTC_CC_18_A, MTC_CC_15_T, MTC_CC_16_F, MTC_CC_21_A, MTC_CC_22_A,
          MTC_CC_19_T, MTC_CC_20_F, MTC_CC_25_A, MTC_CC_26_A, MTC_CC_23_T,
          MTC_CC_24_F);
    tel

    node #pragma kcg expand #end Check_interval_Temperature_1_MTC_OBS(
        temperature : 'MTC_T0;
        MTC_INSTRU : bool)
      returns ()
    var
      MTC_ACTIVATED : bool;
      MTC_temperature_CHANGED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_temperature_CHANGED= #1 MTC_Utils::GenericInputChanged(temperature);
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (
          0))(MTC_ACTIVATED, MTC_temperature_CHANGED);
    tel

    node #pragma kcg expand #end Vote_Alog_PATHS5_MTC_OBS(
        MTC_CC_27_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_27_A);
    tel

    node #pragma kcg expand #end Vote_Alog_PATHS6_MTC_OBS(
        MTC_CC_30_A : bool;
        MTC_CC_31_A : bool;
        MTC_CC_28_T : bool;
        MTC_CC_29_F : bool;
        MTC_CC_34_A : bool;
        MTC_CC_35_A : bool;
        MTC_CC_32_T : bool;
        MTC_CC_33_F : bool;
        MTC_CC_38_A : bool;
        MTC_CC_39_A : bool;
        MTC_CC_36_T : bool;
        MTC_CC_37_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL12 every MTC_INSTRU default (0))(MTC_CC_30_A,
          MTC_CC_31_A, MTC_CC_28_T, MTC_CC_29_F, MTC_CC_34_A, MTC_CC_35_A,
          MTC_CC_32_T, MTC_CC_33_F, MTC_CC_38_A, MTC_CC_39_A, MTC_CC_36_T,
          MTC_CC_37_F);
    tel

    node #pragma kcg expand #end Check_interval_Redox_1_MTC_OBS(
        Redox : 'MTC_T0;
        MTC_INSTRU : bool)
      returns ()
    var
      MTC_ACTIVATED : bool;
      MTC_Redox_CHANGED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_Redox_CHANGED= #1 MTC_Utils::GenericInputChanged(Redox);
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (
          0))(MTC_ACTIVATED, MTC_Redox_CHANGED);
    tel

    node #pragma kcg expand #end Controller_PATHS1_MTC_OBS(
        MTC_CC_1_A : bool;
        MTC_CC_2_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_1_A,
          MTC_CC_2_A);
    tel

    node #pragma kcg expand #end STATE_MTC_OBS(
        MTC_CC_1 : bool;
        MTC_CC_2 : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_1, MTC_CC_2);
    tel

    node #pragma kcg expand #end TRANSITION_MTC_OBS(
        MTC_CC_3 : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1= ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_3);
    tel

    node #pragma kcg expand #end Controller_PATHS2_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F);
    tel

    node #pragma kcg expand #end Controller_PATHS3_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F);
    tel

    node #pragma kcg expand #end Controller_PATHS4_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F);
    tel

    node #pragma kcg expand #end Controller_PATHS5_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F);
    tel

    node #pragma kcg expand #end Controller_PATHS6_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_CC_3_T : bool;
        MTC_CC_4_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL04 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F, MTC_CC_3_T, MTC_CC_4_F);
    tel

    node #pragma kcg expand #end Controller_PATHS7_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F);
    tel

    node #pragma kcg expand #end Controller_PATHS8_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F);
    tel

    node #pragma kcg expand #end Controller_PATHS9_MTC_OBS(
        MTC_CC_18_A : bool;
        MTC_CC_19_T : bool;
        MTC_CC_20_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL03 every MTC_INSTRU default (0))(MTC_CC_18_A,
          MTC_CC_19_T, MTC_CC_20_F);
    tel

    node #pragma kcg expand #end Vote_Alog_111_MTC_OBS(
        pH_Data : 'MTC_T0;
        Temperature_Data : 'MTC_T1;
        Redox_Data : 'MTC_T2;
        MTC_INSTRU : bool)
      returns ()
    var
      MTC_ACTIVATED : bool;
      MTC_pH_Data_CHANGED : bool;
      MTC_Temperature_Data_CHANGED : bool;
      MTC_Redox_Data_CHANGED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_pH_Data_CHANGED= #1 MTC_Utils::GenericInputChanged(pH_Data);
      MTC_Temperature_Data_CHANGED=
        #2 MTC_Utils::GenericInputChanged(Temperature_Data);
      MTC_Redox_Data_CHANGED= #3 MTC_Utils::GenericInputChanged(Redox_Data);
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL04 every MTC_INSTRU default (
          0))(MTC_ACTIVATED, MTC_pH_Data_CHANGED, MTC_Temperature_Data_CHANGED,
          MTC_Redox_Data_CHANGED);
    tel

    node #pragma kcg expand #end Controller_PATHS10_MTC_OBS(
        MTC_CC_21_T : bool;
        MTC_CC_22_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_21_T,
          MTC_CC_22_F);
    tel

    node #pragma kcg expand #end Controller_PATHS11_MTC_OBS(
        MTC_CC_23_A : bool;
        MTC_CC_24_T : bool;
        MTC_CC_25_F : bool;
        MTC_CC_26_T : bool;
        MTC_CC_27_F : bool;
        MTC_CC_28_T : bool;
        MTC_CC_29_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL07 every MTC_INSTRU default (0))(MTC_CC_23_A,
          MTC_CC_24_T, MTC_CC_25_F, MTC_CC_26_T, MTC_CC_27_F, MTC_CC_28_T,
          MTC_CC_29_F);
    tel

    node #pragma kcg expand #end Controller_PATHS12_MTC_OBS(
        MTC_CC_1_T : bool;
        MTC_CC_2_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (0))(MTC_CC_1_T,
          MTC_CC_2_F);
    tel

    node #pragma kcg expand #end Push_Table_11_MTC_OBS(
        Input1 : 'MTC_T0;
        newData : 'MTC_T1;
        MTC_INSTRU : bool)
      returns ()
    var
      MTC_ACTIVATED : bool;
      MTC_Input1_CHANGED : bool;
      MTC_newData_CHANGED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_Input1_CHANGED= #1 MTC_Utils::GenericInputChanged(Input1);
      MTC_newData_CHANGED= #2 MTC_Utils::GenericInputChanged(newData);
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL03 every MTC_INSTRU default (
          0))(MTC_ACTIVATED, MTC_Input1_CHANGED, MTC_newData_CHANGED);
    tel

    node #pragma kcg expand #end Controller_PATHS13_MTC_OBS(
        MTC_CC_32_T : bool;
        MTC_CC_33_F : bool;
        MTC_CC_34_T : bool;
        MTC_CC_35_F : bool;
        MTC_CC_36_T : bool;
        MTC_CC_37_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL06 every MTC_INSTRU default (0))(MTC_CC_32_T,
          MTC_CC_33_F, MTC_CC_34_T, MTC_CC_35_F, MTC_CC_36_T, MTC_CC_37_F);
    tel

    node #pragma kcg expand #end Mean_10_Table_1_MTC_OBS(
        Input1 : 'MTC_T0;
        MTC_INSTRU : bool)
      returns ()
    var
      MTC_ACTIVATED : bool;
      MTC_Input1_CHANGED : bool;
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ACTIVATED= true;
      MTC_Input1_CHANGED= #1 MTC_Utils::GenericInputChanged(Input1);
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL02 every MTC_INSTRU default (
          0))(MTC_ACTIVATED, MTC_Input1_CHANGED);
    tel

    node #pragma kcg expand #end Controller_PATHS14_MTC_OBS(
        MTC_CC_38_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_38_A);
    tel

    node #pragma kcg expand #end Controller_PATHS15_MTC_OBS(
        MTC_CC_39_A : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL01 every MTC_INSTRU default (0))(MTC_CC_39_A);
    tel

    node #pragma kcg expand #end Controller_PATHS16_MTC_OBS(
        MTC_CC_40_A : bool;
        MTC_CC_41_T : bool;
        MTC_CC_42_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL03 every MTC_INSTRU default (0))(MTC_CC_40_A,
          MTC_CC_41_T, MTC_CC_42_F);
    tel

    node #pragma kcg expand #end Controller_PATHS17_MTC_OBS(
        MTC_CC_43_A : bool;
        MTC_CC_44_T : bool;
        MTC_CC_45_F : bool;
        MTC_INSTRU : bool)
      returns ()
    var
      probe MTC_ALL1 : MTC::Result;
    let
      MTC_ALL1=
        ( activate #1 MTC::LATCHALL03 every MTC_INSTRU default (0))(MTC_CC_43_A,
          MTC_CC_44_T, MTC_CC_45_F);
    tel

  end;

  package MTC_Instrumenters
    function #pragma kcg expand #end digital_BoolVect2IntElt_MTC_INST(
        Acc : 'T;
        bi : bool;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (AccOut : 'T)
      where 'T integer
    let
      AccOut, _, _= #0 digital::BoolVect2IntElt(Acc, bi, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end vect_ScalProd_MTC_INST<<n>>(
        V : 'T^n;
        W : 'T^n;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (SP : 'T)
      where 'T numeric
    let
      SP, _, _= (#0 vect::ScalProd <<n>>)(V, W, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end vect_SelectorHelper_MTC_INST<<DstSize>>(
        Input : 'T^DstSize;
        Index : 'I;
        Default : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (Output : 'T)
      where 'I integer
    let
      Output, _, _, _=
        (#0 vect::SelectorHelper <<DstSize>>)(Input, Index, Default, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end math_PolynomialStep_MTC_INST(
        Acc : 'T;
        X : 'T;
        C : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (Y : 'T)
      where 'T numeric
    let
      Y, _, _, _= #0 math::PolynomialStep(Acc, X, C, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end math_Min_MTC_INST(
        I1 : 'T;
        I2 : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (Mi_Output : 'T)
      where 'T numeric
    let
      Mi_Output, _, _= #0 math::Min(I1, I2, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end math_Max_MTC_INST(
        I1 : 'T;
        I2 : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (Ma_Output : 'T)
      where 'T numeric
    let
      Ma_Output, _, _= #0 math::Max(I1, I2, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    node #pragma kcg expand #end math_Abs_MTC_INST(
        A_Input : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (A_Output : 'T)
      where 'T numeric
    let
      A_Output, _= #0 math::Abs(A_Input, MTC_AC_Outputs, MTC_INSTRU);
    tel

    function #pragma kcg expand #end lut_SearchIdx_MTC_INST(
        i : int32;
        AccIn : int32;
        InX : 'T;
        X : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (AccOut : int32)
      where 'T numeric
    let
      AccOut, _, _, _, _= #0 lut::SearchIdx(i, AccIn, InX, X, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end lut_SearchIdxFloor_MTC_INST(
        i : int32;
        Acc : int32;
        InX : 'T;
        Xi : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (Out : int32)
      where 'T numeric
    let
      Out, _, _, _, _= #0 lut::SearchIdxFloor(i, Acc, InX, Xi, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end lut_PreLutNoSat_MTC_INST<<Xs>>(
        InX : 'T;
        X : 'T^Xs;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (F : 'T; Idx : int32)
      where 'T float
    let
      F, Idx, _, _=
        (#0 lut::PreLutNoSat <<Xs>>)(InX, X, MTC_AC_Outputs, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end lut_InterpolateLinear_MTC_INST(
        F : 'T;
        Y1 : 'T;
        Y2 : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (Y : 'T)
      where 'T numeric
    let
      Y, _, _, _= #0 lut::InterpolateLinear(F, Y1, Y2, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end verif_Implies_MTC_INST(
        A : bool;
        B : bool;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (C : bool)
    let
      C, _, _= #0 verif::Implies(A, B, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    node #pragma kcg expand #end Check_Delta_3_IfBlock1_MTC_INST(
        all_fail : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_AC_1 : bool;
      MTC_CC_1_T : bool;
      MTC_CC_2_F : bool;
    let
      MTC_cond= all_fail;
      MTC_AC_1= MTC_AC;
      MTC_CC_1_T= MTC_cond #1 and MTC_AC_1;
      MTC_CC_2_F= #1 not MTC_cond #2 and MTC_AC_1;
      ()=
        #1 MTC_Observers::Check_Delta_3_PATHS1_MTC_OBS(MTC_CC_1_T, MTC_CC_2_F,
          MTC_INSTRU);
    tel

    node #pragma kcg expand #end Check_Delta_3_IfBlock1_else_MTC_INST(
        fail1 : bool;
        fail2 : bool;
        fail3 : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= fail1 #6 and fail2 #6 and #8 not fail3;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= fail2 #1 and #1 not fail3;
      MTC_AC_3= fail1 #2 and #2 not fail3;
      MTC_AC_4= fail1 #3 and fail2;
      MTC_AC_5= MTC_AC_2 #4 and MTC_AC_1;
      MTC_AC_6= MTC_AC_3 #5 and MTC_AC_1;
      MTC_AC_7= MTC_AC_4 #7 and MTC_AC_1;
      MTC_AC_8= true;
      MTC_AC_9= MTC_AC_8 #8 and MTC_AC_7;
      MTC_CC_2_T= fail1 #9 and MTC_AC_5;
      MTC_CC_3_F= #3 not fail1 #10 and MTC_AC_5;
      MTC_CC_4_T= fail2 #11 and MTC_AC_6;
      MTC_CC_5_F= #4 not fail2 #12 and MTC_AC_6;
      MTC_CC_6_T= fail3 #13 and MTC_AC_9;
      MTC_CC_7_F= #5 not fail3 #14 and MTC_AC_9;
      ()=
        #1 MTC_Observers::Check_Delta_3_PATHS2_MTC_OBS(MTC_CC_2_T, MTC_CC_3_F,
          MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end Check_Delta_3_IfBlock1_else_else_MTC_INST(
        fail1 : bool;
        fail2 : bool;
        fail3 : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= fail1 #7 and #9 not fail2 #7 and fail3;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= #1 not fail2 #1 and fail3;
      MTC_AC_3= fail1 #2 and fail3;
      MTC_AC_4= fail1 #3 and #2 not fail2;
      MTC_AC_5= MTC_AC_2 #4 and MTC_AC_1;
      MTC_AC_6= MTC_AC_3 #5 and MTC_AC_1;
      MTC_AC_7= true;
      MTC_AC_8= MTC_AC_7 #6 and MTC_AC_6;
      MTC_AC_9= MTC_AC_4 #8 and MTC_AC_1;
      MTC_CC_2_T= fail1 #9 and MTC_AC_5;
      MTC_CC_3_F= #3 not fail1 #10 and MTC_AC_5;
      MTC_CC_4_T= fail2 #11 and MTC_AC_8;
      MTC_CC_5_F= #4 not fail2 #12 and MTC_AC_8;
      MTC_CC_6_T= fail3 #13 and MTC_AC_9;
      MTC_CC_7_F= #5 not fail3 #14 and MTC_AC_9;
      ()=
        #1 MTC_Observers::Check_Delta_3_PATHS3_MTC_OBS(MTC_CC_2_T, MTC_CC_3_F,
          MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end Check_Delta_3_IfBlock1_else_else_else_MTC_INST(
        fail1 : bool;
        fail2 : bool;
        fail3 : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= #10 not fail1 #8 and fail2 #8 and fail3;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= fail2 #1 and fail3;
      MTC_AC_3= #1 not fail1 #2 and fail3;
      MTC_AC_4= #2 not fail1 #3 and fail2;
      MTC_AC_5= MTC_AC_2 #4 and MTC_AC_1;
      MTC_AC_6= true;
      MTC_AC_7= MTC_AC_6 #5 and MTC_AC_5;
      MTC_AC_8= MTC_AC_3 #6 and MTC_AC_1;
      MTC_AC_9= MTC_AC_4 #7 and MTC_AC_1;
      MTC_CC_2_T= fail1 #9 and MTC_AC_7;
      MTC_CC_3_F= #3 not fail1 #10 and MTC_AC_7;
      MTC_CC_4_T= fail2 #11 and MTC_AC_8;
      MTC_CC_5_F= #4 not fail2 #12 and MTC_AC_8;
      MTC_CC_6_T= fail3 #13 and MTC_AC_9;
      MTC_CC_7_F= #5 not fail3 #14 and MTC_AC_9;
      ()=
        #1 MTC_Observers::Check_Delta_3_PATHS4_MTC_OBS(MTC_CC_2_T, MTC_CC_3_F,
          MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end
      Check_Delta_3_IfBlock1_else_else_else_else_MTC_INST(
        fail1 : bool;
        fail2 : bool;
        fail3 : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_AC_10 : bool;
      MTC_AC_11 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= fail1 #9 and #11 not fail2 #9 and #12 not fail3;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= #1 not fail2 #1 and #2 not fail3;
      MTC_AC_3= fail1 #2 and #3 not fail3;
      MTC_AC_4= fail1 #3 and #4 not fail2;
      MTC_AC_5= MTC_AC_2 #4 and MTC_AC_1;
      MTC_AC_6= MTC_AC_3 #5 and MTC_AC_1;
      MTC_AC_7= true;
      MTC_AC_8= MTC_AC_7 #6 and MTC_AC_6;
      MTC_AC_9= MTC_AC_4 #7 and MTC_AC_1;
      MTC_AC_10= true;
      MTC_AC_11= MTC_AC_10 #8 and MTC_AC_9;
      MTC_CC_2_T= fail1 #10 and MTC_AC_5;
      MTC_CC_3_F= #5 not fail1 #11 and MTC_AC_5;
      MTC_CC_4_T= fail2 #12 and MTC_AC_8;
      MTC_CC_5_F= #6 not fail2 #13 and MTC_AC_8;
      MTC_CC_6_T= fail3 #14 and MTC_AC_11;
      MTC_CC_7_F= #7 not fail3 #15 and MTC_AC_11;
      ()=
        #1 MTC_Observers::Check_Delta_3_PATHS5_MTC_OBS(MTC_CC_2_T, MTC_CC_3_F,
          MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end
      Check_Delta_3_IfBlock1_else_else_else_else_else_MTC_INST(
        fail1 : bool;
        fail2 : bool;
        fail3 : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_AC_10 : bool;
      MTC_AC_11 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= #13 not fail1 #10 and #14 not fail2 #10 and fail3;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= #1 not fail2 #1 and fail3;
      MTC_AC_3= #2 not fail1 #2 and fail3;
      MTC_AC_4= #3 not fail1 #3 and #4 not fail2;
      MTC_AC_5= MTC_AC_2 #4 and MTC_AC_1;
      MTC_AC_6= true;
      MTC_AC_7= MTC_AC_6 #5 and MTC_AC_5;
      MTC_AC_8= MTC_AC_3 #6 and MTC_AC_1;
      MTC_AC_9= true;
      MTC_AC_10= MTC_AC_9 #7 and MTC_AC_8;
      MTC_AC_11= MTC_AC_4 #8 and MTC_AC_1;
      MTC_CC_2_T= fail1 #9 and MTC_AC_7;
      MTC_CC_3_F= #5 not fail1 #11 and MTC_AC_7;
      MTC_CC_4_T= fail2 #12 and MTC_AC_10;
      MTC_CC_5_F= #6 not fail2 #13 and MTC_AC_10;
      MTC_CC_6_T= fail3 #14 and MTC_AC_11;
      MTC_CC_7_F= #7 not fail3 #15 and MTC_AC_11;
      ()=
        #1 MTC_Observers::Check_Delta_3_PATHS6_MTC_OBS(MTC_CC_2_T, MTC_CC_3_F,
          MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end
      Check_Delta_3_IfBlock1_else_else_else_else_else_else_MTC_INST(
        fail1 : bool;
        fail2 : bool;
        fail3 : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_AC_10 : bool;
      MTC_AC_11 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= #15 not fail1 #11 and fail2 #11 and #16 not fail3;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= fail2 #1 and #1 not fail3;
      MTC_AC_3= #2 not fail1 #2 and #3 not fail3;
      MTC_AC_4= #4 not fail1 #3 and fail2;
      MTC_AC_5= MTC_AC_2 #4 and MTC_AC_1;
      MTC_AC_6= true;
      MTC_AC_7= MTC_AC_6 #5 and MTC_AC_5;
      MTC_AC_8= MTC_AC_3 #6 and MTC_AC_1;
      MTC_AC_9= MTC_AC_4 #7 and MTC_AC_1;
      MTC_AC_10= true;
      MTC_AC_11= MTC_AC_10 #8 and MTC_AC_9;
      MTC_CC_2_T= fail1 #9 and MTC_AC_7;
      MTC_CC_3_F= #5 not fail1 #10 and MTC_AC_7;
      MTC_CC_4_T= fail2 #12 and MTC_AC_8;
      MTC_CC_5_F= #6 not fail2 #13 and MTC_AC_8;
      MTC_CC_6_T= fail3 #14 and MTC_AC_11;
      MTC_CC_7_F= #7 not fail3 #15 and MTC_AC_11;
      ()=
        #1 MTC_Observers::Check_Delta_3_PATHS7_MTC_OBS(MTC_CC_2_T, MTC_CC_3_F,
          MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F, MTC_INSTRU);
    tel

    function #pragma kcg expand #end vect_SumDup_MTC_INST(
        a : 'T;
        b : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (s1 : 'T; s2 : 'T)
      where 'T numeric
    let
      s1, s2, _, _= #0 vect::SumDup(a, b, MTC_AC_Outputs, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end lut_SearchIdxCeil_MTC_INST(
        i : int32;
        Acc : int32;
        InX : 'T;
        Xi : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (Out : int32)
      where 'T numeric
    let
      Out, _, _, _, _= #0 lut::SearchIdxCeil(i, Acc, InX, Xi, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end lut_Proj_MTC_INST<<N>>(
        Idx : int32;
        Input1 : 'T^N;
        DefVal : 'T;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (Output1 : 'T; Output2 : 'T)
    let
      Output1, Output2, _, _, _=
        (#0 lut::Proj <<N>>)(Idx, Input1, DefVal, MTC_AC_Outputs, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    node #pragma kcg expand #end verif_HasNeverBeenTrue_MTC_INST(
        Input1 : bool;
        MTC_AC_Outputs : bool;
        MTC_INSTRU : bool)
      returns (Output1 : bool)
    let
      Output1, _= #0 verif::HasNeverBeenTrue(Input1, MTC_AC_Outputs);
      _= MTC_INSTRU;
    tel

    node #pragma kcg expand #end Calculated_value_IfBlock1_MTC_INST(
        a : bool;
        b : bool;
        c : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_CC_1_T : bool;
      MTC_CC_2_F : bool;
      MTC_CC_3_T : bool;
      MTC_CC_4_F : bool;
      MTC_CC_5_T : bool;
      MTC_CC_6_F : bool;
    let
      MTC_cond= a #2 and b #2 and c;
      MTC_AC_1= MTC_AC;
      MTC_AC_2= b #1 and c;
      MTC_AC_3= a #3 and c;
      MTC_AC_4= a #4 and b;
      MTC_AC_5= MTC_AC_2 #5 and MTC_AC_1;
      MTC_AC_6= MTC_AC_3 #6 and MTC_AC_1;
      MTC_AC_7= MTC_AC_4 #7 and MTC_AC_1;
      MTC_CC_1_T= a #8 and MTC_AC_5;
      MTC_CC_2_F= #1 not a #9 and MTC_AC_5;
      MTC_CC_3_T= b #10 and MTC_AC_6;
      MTC_CC_4_F= #2 not b #11 and MTC_AC_6;
      MTC_CC_5_T= c #12 and MTC_AC_7;
      MTC_CC_6_F= #3 not c #13 and MTC_AC_7;
      ()=
        #1 MTC_Observers::Calculated_value_PATHS1_MTC_OBS(MTC_CC_1_T,
          MTC_CC_2_F, MTC_CC_3_T, MTC_CC_4_F, MTC_CC_5_T, MTC_CC_6_F,
          MTC_INSTRU);
    tel

    node #pragma kcg expand #end Calculated_value_IfBlock1_else_MTC_INST(
        a : bool;
        b : bool;
        c : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= #1 not a #3 and b #3 and c;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= b #1 and c;
      MTC_AC_3= #2 not a #2 and c;
      MTC_AC_4= #3 not a #4 and b;
      MTC_AC_5= MTC_AC_2 #5 and MTC_AC_1;
      MTC_AC_6= true;
      MTC_AC_7= MTC_AC_6 #6 and MTC_AC_5;
      MTC_AC_8= MTC_AC_3 #7 and MTC_AC_1;
      MTC_AC_9= MTC_AC_4 #8 and MTC_AC_1;
      MTC_CC_2_T= a #9 and MTC_AC_7;
      MTC_CC_3_F= #4 not a #10 and MTC_AC_7;
      MTC_CC_4_T= b #11 and MTC_AC_8;
      MTC_CC_5_F= #5 not b #12 and MTC_AC_8;
      MTC_CC_6_T= c #13 and MTC_AC_9;
      MTC_CC_7_F= #6 not c #14 and MTC_AC_9;
      ()=
        #1 MTC_Observers::Calculated_value_PATHS2_MTC_OBS(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F,
          MTC_INSTRU);
    tel

    node #pragma kcg expand #end Calculated_value_IfBlock1_else_else_MTC_INST(
        b : bool;
        a : bool;
        c : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= #2 not b #4 and a #4 and c;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= a #1 and c;
      MTC_AC_3= #1 not b #2 and c;
      MTC_AC_4= #3 not b #3 and a;
      MTC_AC_5= MTC_AC_2 #5 and MTC_AC_1;
      MTC_AC_6= true;
      MTC_AC_7= MTC_AC_6 #6 and MTC_AC_5;
      MTC_AC_8= MTC_AC_3 #7 and MTC_AC_1;
      MTC_AC_9= MTC_AC_4 #8 and MTC_AC_1;
      MTC_CC_2_T= b #9 and MTC_AC_7;
      MTC_CC_3_F= #4 not b #10 and MTC_AC_7;
      MTC_CC_4_T= a #11 and MTC_AC_8;
      MTC_CC_5_F= #5 not a #12 and MTC_AC_8;
      MTC_CC_6_T= c #13 and MTC_AC_9;
      MTC_CC_7_F= #6 not c #14 and MTC_AC_9;
      ()=
        #1 MTC_Observers::Calculated_value_PATHS3_MTC_OBS(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F,
          MTC_INSTRU);
    tel

    node #pragma kcg expand #end
      Calculated_value_IfBlock1_else_else_else_MTC_INST(
        c : bool;
        a : bool;
        b : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= #3 not c #5 and a #5 and b;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= a #1 and b;
      MTC_AC_3= #1 not c #2 and b;
      MTC_AC_4= #2 not c #3 and a;
      MTC_AC_5= MTC_AC_2 #4 and MTC_AC_1;
      MTC_AC_6= true;
      MTC_AC_7= MTC_AC_6 #6 and MTC_AC_5;
      MTC_AC_8= MTC_AC_3 #7 and MTC_AC_1;
      MTC_AC_9= MTC_AC_4 #8 and MTC_AC_1;
      MTC_CC_2_T= c #9 and MTC_AC_7;
      MTC_CC_3_F= #4 not c #10 and MTC_AC_7;
      MTC_CC_4_T= a #11 and MTC_AC_8;
      MTC_CC_5_F= #5 not a #12 and MTC_AC_8;
      MTC_CC_6_T= b #13 and MTC_AC_9;
      MTC_CC_7_F= #6 not b #14 and MTC_AC_9;
      ()=
        #1 MTC_Observers::Calculated_value_PATHS4_MTC_OBS(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F,
          MTC_INSTRU);
    tel

    node #pragma kcg expand #end
      Calculated_value_IfBlock1_else_else_else_else_MTC_INST(
        a : bool;
        b : bool;
        c : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_AC_10 : bool;
      MTC_AC_11 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= #4 not a #6 and #5 not b #6 and c;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= #1 not b #1 and c;
      MTC_AC_3= #2 not a #2 and c;
      MTC_AC_4= #3 not a #3 and #6 not b;
      MTC_AC_5= MTC_AC_2 #4 and MTC_AC_1;
      MTC_AC_6= true;
      MTC_AC_7= MTC_AC_6 #5 and MTC_AC_5;
      MTC_AC_8= MTC_AC_3 #7 and MTC_AC_1;
      MTC_AC_9= true;
      MTC_AC_10= MTC_AC_9 #8 and MTC_AC_8;
      MTC_AC_11= MTC_AC_4 #9 and MTC_AC_1;
      MTC_CC_2_T= a #10 and MTC_AC_7;
      MTC_CC_3_F= #7 not a #11 and MTC_AC_7;
      MTC_CC_4_T= b #12 and MTC_AC_10;
      MTC_CC_5_F= #8 not b #13 and MTC_AC_10;
      MTC_CC_6_T= c #14 and MTC_AC_11;
      MTC_CC_7_F= #9 not c #15 and MTC_AC_11;
      ()=
        #1 MTC_Observers::Calculated_value_PATHS5_MTC_OBS(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F,
          MTC_INSTRU);
    tel

    node #pragma kcg expand #end
      Calculated_value_IfBlock1_else_else_else_else_else_MTC_INST(
        b : bool;
        c : bool;
        a : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_AC_10 : bool;
      MTC_AC_11 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= #6 not b #7 and #7 not c #7 and a;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= #1 not c #1 and a;
      MTC_AC_3= #2 not b #2 and a;
      MTC_AC_4= #3 not b #3 and #4 not c;
      MTC_AC_5= MTC_AC_2 #4 and MTC_AC_1;
      MTC_AC_6= true;
      MTC_AC_7= MTC_AC_6 #5 and MTC_AC_5;
      MTC_AC_8= MTC_AC_3 #6 and MTC_AC_1;
      MTC_AC_9= true;
      MTC_AC_10= MTC_AC_9 #8 and MTC_AC_8;
      MTC_AC_11= MTC_AC_4 #9 and MTC_AC_1;
      MTC_CC_2_T= b #10 and MTC_AC_7;
      MTC_CC_3_F= #5 not b #11 and MTC_AC_7;
      MTC_CC_4_T= c #12 and MTC_AC_10;
      MTC_CC_5_F= #8 not c #13 and MTC_AC_10;
      MTC_CC_6_T= a #14 and MTC_AC_11;
      MTC_CC_7_F= #9 not a #15 and MTC_AC_11;
      ()=
        #1 MTC_Observers::Calculated_value_PATHS6_MTC_OBS(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F,
          MTC_INSTRU);
    tel

    node #pragma kcg expand #end
      Calculated_value_IfBlock1_else_else_else_else_else_else_MTC_INST(
        a : bool;
        c : bool;
        b : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_CC_1 : bool;
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_AC_8 : bool;
      MTC_AC_9 : bool;
      MTC_AC_10 : bool;
      MTC_AC_11 : bool;
      MTC_CC_2_T : bool;
      MTC_CC_3_F : bool;
      MTC_CC_4_T : bool;
      MTC_CC_5_F : bool;
      MTC_CC_6_T : bool;
      MTC_CC_7_F : bool;
    let
      MTC_cond= #8 not a #8 and #9 not c #8 and b;
      MTC_CC_1= MTC_AC;
      ()= #1 MTC_Observers::CONTROL_MTC_OBS(MTC_CC_1, MTC_INSTRU);
      MTC_AC_1= MTC_AC;
      MTC_AC_2= #1 not c #1 and b;
      MTC_AC_3= #2 not a #2 and b;
      MTC_AC_4= #3 not a #3 and #4 not c;
      MTC_AC_5= MTC_AC_2 #4 and MTC_AC_1;
      MTC_AC_6= true;
      MTC_AC_7= MTC_AC_6 #5 and MTC_AC_5;
      MTC_AC_8= MTC_AC_3 #6 and MTC_AC_1;
      MTC_AC_9= true;
      MTC_AC_10= MTC_AC_9 #7 and MTC_AC_8;
      MTC_AC_11= MTC_AC_4 #9 and MTC_AC_1;
      MTC_CC_2_T= a #10 and MTC_AC_7;
      MTC_CC_3_F= #5 not a #11 and MTC_AC_7;
      MTC_CC_4_T= c #12 and MTC_AC_10;
      MTC_CC_5_F= #6 not c #13 and MTC_AC_10;
      MTC_CC_6_T= b #14 and MTC_AC_11;
      MTC_CC_7_F= #7 not b #15 and MTC_AC_11;
      ()=
        #1 MTC_Observers::Calculated_value_PATHS7_MTC_OBS(MTC_CC_2_T,
          MTC_CC_3_F, MTC_CC_4_T, MTC_CC_5_F, MTC_CC_6_T, MTC_CC_7_F,
          MTC_INSTRU);
    tel

    function #pragma kcg expand #end Controller_MTC_Send_Data_def_MTC_INST(
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_Send_Data_def : Statation_data)
    let
      MTC_Send_Data_def= Normal_Send_Data;
      _= MTC_AC;
      _= MTC_INSTRU;
    tel

    node #pragma kcg expand #end Controller_store_last_MTC_INST(
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_store_last : Ten_Values_Table)
    var
      MTC_CC_1_A : bool;
      MTC_CC_2_A : bool;
    let
      MTC_store_last= Normal_Value;
      MTC_CC_1_A= MTC_AC #2 and ((true) #2 -> (false));
      MTC_CC_2_A= MTC_AC #3 and ((false) #3 -> (true));
      ()=
        #1 MTC_Observers::Controller_PATHS1_MTC_OBS(MTC_CC_1_A, MTC_CC_2_A, MTC_INSTRU);
    tel

    function #pragma kcg expand #end Controller_Store_Time_def_MTC_INST(
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_Store_Time_def : float64)
    let
      MTC_Store_Time_def= 0.0;
      _= MTC_AC;
      _= MTC_INSTRU;
    tel

    function #pragma kcg expand #end Controller_timeout_def_MTC_INST(
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_timeout_def : bool)
    let
      MTC_timeout_def= false;
      _= MTC_AC;
      _= MTC_INSTRU;
    tel

    node #pragma kcg expand #end Controller_SM1_Normal_Station_2_MTC_INST(
        notif : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_guard : bool)
    var
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_CC_1_T : bool;
      MTC_CC_2_F : bool;
    let
      MTC_guard= #1 not notif;
      MTC_AC_1= MTC_AC;
      MTC_AC_2= true;
      MTC_AC_3= MTC_AC_2 #1 and MTC_AC_1;
      MTC_CC_1_T= notif #2 and MTC_AC_3;
      MTC_CC_2_F= #2 not notif #3 and MTC_AC_3;
      ()=
        #1 MTC_Observers::Controller_PATHS2_MTC_OBS(MTC_CC_1_T, MTC_CC_2_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end Controller_SM1_Normal_Station_1_MTC_INST(
        notif : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_guard : bool)
    var
      MTC_AC_1 : bool;
      MTC_CC_1_T : bool;
      MTC_CC_2_F : bool;
    let
      MTC_guard= notif;
      MTC_AC_1= MTC_AC;
      MTC_CC_1_T= MTC_guard #1 and MTC_AC_1;
      MTC_CC_2_F= #1 not MTC_guard #2 and MTC_AC_1;
      ()=
        #1 MTC_Observers::Controller_PATHS3_MTC_OBS(MTC_CC_1_T, MTC_CC_2_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end Controller_SM1_Calculate_2_MTC_INST(
        alarm : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_guard : bool)
    var
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_CC_1_T : bool;
      MTC_CC_2_F : bool;
    let
      MTC_guard= #2 not alarm;
      MTC_AC_1= MTC_AC;
      MTC_AC_2= true;
      MTC_AC_3= MTC_AC_2 #1 and MTC_AC_1;
      MTC_CC_1_T= alarm #2 and MTC_AC_3;
      MTC_CC_2_F= #1 not alarm #3 and MTC_AC_3;
      ()=
        #1 MTC_Observers::Controller_PATHS4_MTC_OBS(MTC_CC_1_T, MTC_CC_2_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end Controller_SM1_Calculate_1_MTC_INST(
        alarm : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_guard : bool)
    var
      MTC_AC_1 : bool;
      MTC_CC_1_T : bool;
      MTC_CC_2_F : bool;
    let
      MTC_guard= alarm;
      MTC_AC_1= MTC_AC;
      MTC_CC_1_T= MTC_guard #1 and MTC_AC_1;
      MTC_CC_2_F= #1 not MTC_guard #2 and MTC_AC_1;
      ()=
        #1 MTC_Observers::Controller_PATHS5_MTC_OBS(MTC_CC_1_T, MTC_CC_2_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end Controller_SM1_Pollution_2_MTC_INST(
        Stop : bool;
        Frequency : float64;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_guard : bool)
    var
      MTC_AC_1 : bool;
      MTC_AC_2 : bool;
      MTC_AC_3 : bool;
      MTC_AC_4 : bool;
      MTC_AC_5 : bool;
      MTC_AC_6 : bool;
      MTC_AC_7 : bool;
      MTC_CC_1_T : bool;
      MTC_CC_2_F : bool;
      MTC_CC_3_T : bool;
      MTC_CC_4_F : bool;
    let
      MTC_guard= #4 not Stop #2 and Frequency #3 > 0;
      MTC_AC_1= MTC_AC;
      MTC_AC_2= Frequency #1 > 0;
      MTC_AC_3= #1 not Stop;
      MTC_AC_4= MTC_AC_2 #1 and MTC_AC_1;
      MTC_AC_5= true;
      MTC_AC_6= MTC_AC_5 #3 and MTC_AC_4;
      MTC_AC_7= MTC_AC_3 #4 and MTC_AC_1;
      MTC_CC_1_T= Stop #5 and MTC_AC_6;
      MTC_CC_2_F= #2 not Stop #6 and MTC_AC_6;
      MTC_CC_3_T= Frequency #2 > 0 #7 and MTC_AC_7;
      MTC_CC_4_F= #3 not (Frequency #4 > 0) #8 and MTC_AC_7;
      ()=
        #1 MTC_Observers::Controller_PATHS6_MTC_OBS(MTC_CC_1_T, MTC_CC_2_F,
          MTC_CC_3_T, MTC_CC_4_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end Controller_SM1_Pollution_1_MTC_INST(
        Stop : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_guard : bool)
    var
      MTC_AC_1 : bool;
      MTC_CC_1_T : bool;
      MTC_CC_2_F : bool;
    let
      MTC_guard= Stop;
      MTC_AC_1= MTC_AC;
      MTC_CC_1_T= MTC_guard #1 and MTC_AC_1;
      MTC_CC_2_F= #1 not MTC_guard #2 and MTC_AC_1;
      ()=
        #1 MTC_Observers::Controller_PATHS7_MTC_OBS(MTC_CC_1_T, MTC_CC_2_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end Controller_SM1_Timer_1_MTC_INST(
        timeout : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_guard : bool)
    var
      MTC_AC_1 : bool;
      MTC_CC_1_T : bool;
      MTC_CC_2_F : bool;
    let
      MTC_guard= timeout;
      MTC_AC_1= MTC_AC;
      MTC_CC_1_T= MTC_guard #1 and MTC_AC_1;
      MTC_CC_2_F= #1 not MTC_guard #2 and MTC_AC_1;
      ()=
        #1 MTC_Observers::Controller_PATHS8_MTC_OBS(MTC_CC_1_T, MTC_CC_2_F, MTC_INSTRU);
    tel

    node #pragma kcg expand #end Controller_SM1_Calculate_IfBlock1_MTC_INST(
        alarm : bool;
        MTC_AC : bool;
        MTC_INSTRU : bool)
      returns (MTC_cond : bool)
    var
      MTC_AC_1 : bool;
      MTC_CC_1_T : bool;
      MTC_CC_2_F : bool;
    let
      MTC_cond= alarm;
      MTC_AC_1= MTC_AC;
      MTC_CC_1_T= MTC_cond #1 and MTC_AC_1;
      MTC_CC_2_F= #1 not MTC_cond #2 and MTC_AC_1;
      ()=
        #1 MTC_Observers::Controller_PATHS12_MTC_OBS(MTC_CC_1_T, MTC_CC_2_F,
          MTC_INSTRU);
    tel

  end;

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/libmtcModelisation_Surveillance_MTC_INST/MTC_Utils.xscade */
package MTC_Utils
  node imported GenericInputChanged(Input : 'T) returns (Output : bool);

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/liblinear_MTC_INST/linear.xscade */
package linear
  function #pragma kcg expand #end Gain(
      G_Input : 'T;
      Gain : 'T;
      MTC_AC_G_Output : bool)
    returns (
      G_Output : 'T;
      MTC_AC_G_Input : bool default = false;
      MTC_AC_Gain : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
  let
    _L1= G_Input;
    _L2= Gain;
    G_Output= _L3;
    _L3= _L1 #1 * _L2;
    _= MTC_AC_G_Output;
    MTC_AC_G_Input= false;
    MTC_AC_Gain= false;
  tel

  node MeanCycle2(U : 'T) returns (MeanOn2Steps : 'T) where 'T float
  var
    _L1 : 'T;
    _L13 : 'T;
    _L14 : 'T;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= U;
    MeanOn2Steps= _L8;
    _L8= _L14 #1 / _L9;
    _L9= (2 #2 : 'T);
    _L13= #2 fby(_L1; 1; _L1);
    _L14= _L1 #3 + _L13;
  tel

  node MeanCycle3(U : 'T) returns (MeanOn3Step : 'T) where 'T float
  var
    _L10 : 'T;
    _L11 : 'T;
    _L12 : 'T;
    _L6 : 'T;
    _L7 : 'T;
    _L9 : 'T;
  let
    MeanOn3Step= _L12;
    _L6= U;
    _L7= #1 fby(_L6; 1; _L6);
    _L9= #2 fby(_L7; 1; _L6);
    _L10= (3 #2 : 'T);
    _L11= _L6 #3 + _L7 #3 + _L9;
    _L12= _L11 #4 / _L10;
  tel

  node Derivative(u : 'T; TimeCycle : 'T)
    returns (Derivative : 'T)
    where 'T float
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L6 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= _L3 #1 - _L2;
    _L2= #pre2 fby(_L3; 1; (0 : 'T));
    _L3= u;
    Derivative= _L6;
    _L6= (_L7) #3 -> (_L8);
    _L7= (0.0 #1 : 'T);
    _L8= _L1 #6 / _L9;
    _L9= TimeCycle;
  tel

  node #pragma kcg expand #end Filter1stOrderLoop(
      F1OL_Input : 'T;
      K1 : 'T;
      K2 : 'T;
      Init : 'T;
      MTC_AC_F1OL_Output : bool)
    returns (
      F1OL_Output : 'T;
      MTC_AC_F1OL_Input : bool default = false;
      MTC_AC_K1 : bool default = false;
      MTC_AC_K2 : bool default = false;
      MTC_AC_Init : bool default = false)
    where 'T numeric
  var
    _L9 : 'T;
    _L8 : 'T;
    _L7 : 'T;
    _L6 : 'T;
    _L5 : 'T;
    _L4 : 'T;
    _L3 : 'T;
    _L2 : 'T;
    _L1 : 'T;
  let
    _L9= Init;
    _L8= (_L9) #1 -> (_L7);
    _L7= _L4 #4 - _L6;
    _L6= _L5 #5 * _L2;
    _L5= #pre6 fby(_L8; 1; (0 : 'T));
    _L4= _L3 #7 * _L1;
    F1OL_Output= _L8;
    _L3= F1OL_Input;
    _L2= K2;
    _L1= K1;
    _= MTC_AC_F1OL_Output;
    MTC_AC_F1OL_Input= false;
    MTC_AC_K1= false;
    MTC_AC_K2= false;
    MTC_AC_Init= false;
  tel

  node #pragma kcg expand #end Memory(
      M_Input : 'T;
      Reset : bool;
      MemCond : bool;
      InitVal : 'T;
      MTC_AC_Out : bool)
    returns (
      Out : 'T;
      MTC_AC_M_Input : bool default = false;
      MTC_AC_Reset : bool default = false;
      MTC_AC_MemCond : bool default = false;
      MTC_AC_InitVal : bool default = false)
  var
    _L8 : 'T;
    _L7 : 'T;
    _L6 : 'T;
    _L5 : 'T;
    _L3 : bool;
    _L2 : 'T;
    _L1 : bool;
    _L9 : 'T;
  let
    Out= _L8;
    _L8= #1 if _L1 then (_L2) else (_L7);
    _L7= #4 if _L3 then (_L6) else (_L5);
    _L6= M_Input;
    _L5= #7 fby(_L8; 1; _L9);
    _L3= MemCond;
    _L2= InitVal;
    _L1= Reset;
    _L9= InitVal;
    _= MTC_AC_Out;
    MTC_AC_M_Input= false;
    MTC_AC_Reset= false;
    MTC_AC_MemCond= false;
    MTC_AC_InitVal= false;
  tel

  node HitCrossingEither(HCE_Input : 'T; Offset : 'T)
    returns (HCE_Output : bool)
    where 'T numeric
  var
    _L1 : 'T;
    _L5 : 'T;
    _L24 : bool;
    _L25 : bool;
    _L26 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
    _L31 : bool;
    _L43 : 'T;
  let
    _L1= HCE_Input;
    _L5= Offset;
    _L24= _L43 #1 <= _L5;
    _L25= _L1 #2 >= _L5;
    _L26= _L24 #3 and _L25;
    _L28= _L43 #4 >= _L5;
    _L29= _L1 #5 <= _L5;
    _L30= _L28 #6 and _L29;
    _L31= _L26 #7 or _L30;
    HCE_Output= _L31;
    _L43= #8 fby(_L1; 1; _L1);
  tel

  node HitCrossingFalling(HCF_Input : 'T; Offset : 'T)
    returns (HCF_Output : bool)
    where 'T numeric
  var
    _L1 : 'T;
    _L5 : 'T;
    _L10 : bool;
    _L18 : bool;
    _L22 : 'T;
    _L24 : bool;
    _L25 : bool;
    _L26 : bool;
    _L27 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
  let
    _L1= HCF_Input;
    _L5= Offset;
    _L10= (_L18) #1 -> (_L30);
    _L18= false;
    _L22= #pre4 fby(_L1; 1; (0 : 'T));
    _L24= _L22 #5 >= _L5;
    _L25= _L1 #6 < _L5;
    _L26= _L24 #7 and _L25;
    HCF_Output= _L10;
    _L27= _L22 #8 > _L5;
    _L28= _L1 #9 = _L5;
    _L29= _L27 #10 and _L28;
    _L30= _L26 #11 or _L29;
  tel

  node HitCrossingRising(HCR_Input : 'T; Offset : 'T)
    returns (HCR_Output : bool)
    where 'T numeric
  var
    _L1 : 'T;
    _L5 : 'T;
    _L10 : bool;
    _L18 : bool;
    _L22 : 'T;
    _L24 : bool;
    _L25 : bool;
    _L26 : bool;
    _L27 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
  let
    _L1= HCR_Input;
    _L5= Offset;
    _L10= (_L18) #1 -> (_L30);
    _L18= false;
    _L22= #pre4 fby(_L1; 1; (0 : 'T));
    _L24= _L22 #5 <= _L5;
    _L25= _L1 #6 > _L5;
    _L26= _L24 #7 and _L25;
    HCR_Output= _L10;
    _L27= _L22 #8 < _L5;
    _L28= _L1 #9 = _L5;
    _L29= _L27 #10 and _L28;
    _L30= _L26 #11 or _L29;
  tel

  node #pragma kcg expand #end MemoryBasic(
      BM_Input : 'T;
      Init : 'T;
      Write : bool;
      MTC_AC_Memorized : bool)
    returns (
      Memorized : 'T;
      MTC_AC_BM_Input : bool default = false;
      MTC_AC_Init : bool default = false;
      MTC_AC_Write : bool default = false)
  var
    _L2 : 'T;
    _L4 : 'T;
    _L5 : bool;
    _L6 : 'T;
    _L7 : 'T;
  let
    _L2= BM_Input;
    Memorized= _L4;
    _L4= #1 if _L5 then (_L2) else (_L6);
    _L5= Write;
    _L6= #4 fby(_L4; 1; _L7);
    _L7= Init;
    _= MTC_AC_Memorized;
    MTC_AC_BM_Input= false;
    MTC_AC_Init= false;
    MTC_AC_Write= false;
  tel

  node Backlash(input : 'T; deadband_width : 'T; initial_output : 'T)
    returns (output : 'T last = initial_output)
    where 'T float
  var
    _L81 : 'T;
    _L79 : 'T;
    _L78 : 'T;
    _L75 : 'T;
    _L74 : bool;
    _L73 : 'T;
    _L72 : bool;
    _L70 : 'T;
    _L69 : bool;
    _L66 : 'T;
    _L82 : 'T;
    _L83 : 'T;
    _L84 : 'T;
    _L85 : 'T;
    _L86 : 'T;
    _L87 : 'T;
    _L88 : 'T;
    _L89 : 'T;
  let
    _L66= input;
    _L69= _L66 #1 > _L70;
    output= _L73;
    _L70= _L84 #1 + _L82;
    _L72= _L74 #1 or _L69;
    _L73= #1 if _L72 then (_L75) else (_L85);
    _L74= _L89 #1 < _L81;
    _L75= _L79 #2 + _L78;
    _L78= input;
    _L79= #2 if _L69 then (_L88) else (_L87);
    _L81= _L83 #1 - _L86;
    _L82= deadband_width #2 / (2.0 #1 : 'T);
    _L83= last 'output;
    _L84= last 'output;
    _L85= last 'output;
    _L86= deadband_width #3 / (2.0 #2 : 'T);
    _L87= deadband_width #4 / (2.0 #3 : 'T);
    _L88= #2 - deadband_width #6 / (2.0 #5 : 'T);
    _L89= input;
  tel

  node DetectRisePositive(Input : 'T) returns (Output : bool) where 'T numeric
  var
    _L16 : 'T;
    _L15 : bool;
    _L13 : 'T;
    _L11 : bool;
    _L10 : bool;
    _L9 : 'T;
    _L18 : bool;
  let
    Output= _L18;
    _L9= #pre1 fby(_L16; 1; (0 : 'T));
    _L10= _L16 #1 > _L13;
    _L11= _L10 #1 and _L15;
    _L13= (0 #1 : 'T);
    _L15= _L9 #1 <= _L13;
    _L16= Input;
    _L18= (false) #2 -> (_L11);
  tel

  node DetectRiseNonNegative(Input : 'T)
    returns (Output : bool)
    where 'T numeric
  var
    _L16 : bool;
    _L15 : bool;
    _L14 : 'T;
    _L12 : bool;
    _L11 : 'T;
    _L9 : 'T;
    _L18 : bool;
  let
    _L9= Input;
    _L11= #pre1 fby(_L9; 1; (0 : 'T));
    _L12= _L9 #1 >= _L14;
    Output= _L18;
    _L14= (0 #1 : 'T);
    _L15= _L12 #1 and _L16;
    _L16= _L11 #1 < _L14;
    _L18= (false) #2 -> (_L15);
  tel

  node DetectIncrease(Input : 'T; Init : 'T)
    returns (Output : bool)
    where 'T numeric
  var
    _L11 : 'T;
    _L10 : bool;
    _L9 : 'T;
    _L8 : 'T;
  let
    _L8= #1 fby(_L11; 1; _L9);
    _L9= Init;
    _L10= _L11 #1 > _L8;
    _L11= Input;
    Output= _L10;
  tel

  node DetectFallNonPositive(Input : 'T)
    returns (Output : bool)
    where 'T numeric
  var
    _L17 : 'T;
    _L16 : 'T;
    _L14 : bool;
    _L13 : 'T;
    _L12 : bool;
    _L11 : bool;
    _L18 : bool;
  let
    Output= _L18;
    _L11= _L14 #1 and _L12;
    _L12= _L13 #1 > _L16;
    _L13= #pre1 fby(_L17; 1; (0 : 'T));
    _L14= _L17 #1 <= _L16;
    _L16= (0 #1 : 'T);
    _L17= Input;
    _L18= (false) #2 -> (_L11);
  tel

  node DetectFallNegative(Input : 'T) returns (Output : bool) where 'T numeric
  var
    _L1 : 'T;
    _L3 : bool;
    _L4 : 'T;
    _L7 : bool;
    _L8 : bool;
    _L29 : 'T;
    _L36 : bool;
  let
    _L1= Input;
    Output= _L36;
    _L3= _L1 #1 < _L4;
    _L4= (0 #1 : 'T);
    _L7= _L29 #1 >= _L4;
    _L8= _L3 #1 and _L7;
    _L29= #pre1 fby(_L1; 1; (0 : 'T));
    _L36= (false) #2 -> (_L8);
  tel

  node DetectDecrease(Input : 'T; Init : 'T)
    returns (Output : bool)
    where 'T numeric
  var
    _L11 : bool;
    _L10 : 'T;
    _L9 : 'T;
    _L8 : 'T;
  let
    _L8= #1 fby(_L9; 1; _L10);
    _L9= Input;
    _L10= Init;
    Output= _L11;
    _L11= _L9 #1 < _L8;
  tel

  node DetectChange(Input : 'T; Init : 'T) returns (Output : bool)
  var
    _L1 : 'T;
    _L3 : bool;
    _L4 : 'T;
    _L5 : 'T;
  let
    _L1= Input;
    Output= _L3;
    _L3= _L1 #1 <> _L4;
    _L4= #1 fby(_L1; 1; _L5);
    _L5= Init;
  tel

  node IntegralBackward(
      Input : 'T;
      Reset : bool;
      HighLimit : 'T;
      LowLimit : 'T;
      init : 'T;
      deltaT : 'T)
    returns (Output : 'T; Saturation : bool)
    where 'T numeric
  var
    RawIntegral : 'T;
    _L1 : 'T;
    _L2 : 'T;
    _L4 : 'T;
    _L9 : 'T;
    _L10 : 'T;
    _L12 : 'T;
    _L30 : 'T;
    _L31 : bool;
    _L32 : 'T;
    _L41 : 'T;
    _L40 : 'T;
    _L39 : bool;
    _L38 : bool;
    _L37 : 'T;
    _L36 : 'T;
    _L35 : 'T;
    _L34 : bool;
    _L42 : 'T;
  let
    _L1= Input;
    _L2= deltaT;
    _L4= init;
    _L9= _L30 #1 + _L10;
    _L10= _L1 #1 * _L2;
    _L12= #1 if _L31 then (_L4) else (_L9);
    _L30= #pre1 fby(_L42; 1; (0 : 'T));
    _L31= Reset;
    _L32= (_L4) #1 -> (_L12);
    assume A1 : LowLimit #7 <= HighLimit;
    _L34= RawIntegral #2 >= HighLimit;
    Saturation= _L38;
    _L35= HighLimit;
    _L36= LowLimit;
    _L37= RawIntegral;
    _L38= _L34 #2 or _L39;
    _L39= RawIntegral #8 <= LowLimit;
    _L40= #5 if _L39 then (_L36) else (_L37);
    _L41= #4 if _L34 then (_L35) else (_L40);
    Output= _L41;
    RawIntegral= _L32;
    _L42= Output;
  tel

  node IntegralTrapezoid(
      Input : 'T;
      Reset : bool;
      HighLimit : 'T;
      LowLimit : 'T;
      init : 'T;
      deltaT : 'T)
    returns (Output : 'T; Saturation : bool)
    where 'T numeric
  var
    RawIntegral : 'T;
    _L1 : 'T;
    _L2 : 'T;
    _L4 : 'T;
    _L9 : 'T;
    _L10 : 'T;
    _L12 : 'T;
    _L32 : 'T;
    _L35 : 'T;
    _L36 : bool;
    _L37 : 'T;
    _L42 : 'T;
    _L43 : 'T;
    _L44 : 'T;
    _L52 : bool;
    _L51 : bool;
    _L50 : 'T;
    _L49 : 'T;
    _L48 : 'T;
    _L47 : 'T;
    _L46 : 'T;
    _L45 : bool;
    _L53 : 'T;
  let
    _L1= Input;
    _L2= deltaT;
    _L4= init;
    _L9= _L35 #1 + _L10;
    _L10= _L43 #1 * _L2;
    _L12= #1 if _L36 then (_L4) else (_L9);
    _L32= #1 fby(_L1; 1; (0 #2 : 'T));
    _L35= #pre1 fby(_L53; 1; (0 : 'T));
    _L36= Reset;
    _L37= (_L4) #1 -> (_L12);
    assume A1 : LowLimit #7 <= HighLimit;
    _L42= _L1 #2 + _L32;
    _L43= _L42 #1 / _L44;
    _L44= (2 #1 : 'T);
    _L45= RawIntegral #2 >= HighLimit;
    Saturation= _L51;
    _L46= RawIntegral;
    _L47= LowLimit;
    _L48= #5 if _L45 then (_L49) else (_L50);
    Output= _L48;
    _L49= HighLimit;
    _L50= #4 if _L52 then (_L47) else (_L46);
    _L51= _L45 #2 or _L52;
    _L52= RawIntegral #8 <= LowLimit;
    _L53= Output;
    RawIntegral= _L37;
  tel

  node IntegralForward(
      Input : 'T;
      Reset : bool;
      HighLimit : 'T;
      LowLimit : 'T;
      init : 'T;
      deltaT : 'T)
    returns (Output : 'T; Saturation : bool)
    where 'T numeric
  var
    RawIntegral : 'T;
    _L1 : 'T;
    _L4 : 'T;
    _L10 : 'T;
    _L12 : 'T;
    _L33 : bool;
    _L38 : 'T;
    _L67 : bool;
    _L68 : 'T;
    _L69 : 'T;
    _L70 : 'T;
    _L72 : 'T;
    _L73 : 'T;
    _L74 : bool;
    _L75 : bool;
    _L76 : 'T;
    _L77 : 'T;
    _L78 : 'T;
  let
    _L1= Input;
    _L4= init;
    _L10= _L1 #1 * _L77;
    _L12= #1 if _L33 then (_L4) else (_L78);
    _L33= Reset;
    _L38= #1 fby(_L76; 1; init);
    assume A1 : LowLimit #9 <= HighLimit;
    RawIntegral= _L12;
    _L67= RawIntegral #10 <= LowLimit;
    _L68= LowLimit;
    _L69= #4 if _L67 then (_L68) else (_L70);
    _L70= RawIntegral;
    _L72= #6 if _L74 then (_L73) else (_L69);
    _L73= HighLimit;
    _L74= RawIntegral #2 >= HighLimit;
    Output= _L72;
    _L75= _L74 #2 or _L67;
    Saturation= _L75;
    _L76= Output;
    _L77= deltaT;
    _L78= _L38 #2 + _L10;
  tel

  node IntegrTrapez(
      U : 'T;
      Reset : bool;
      TimeCycle : 'T;
      LowLimit : 'T;
      HiLimit : 'T)
    returns (Y : 'T)
    where 'T float
  var
    _L24 : bool;
    _L23 : 'T;
    _L25 : 'T;
    _L26 : bool;
    _L27 : 'T;
    _L28 : 'T;
    _L29 : 'T;
  let
    _L23, _L24= #1 IntegralTrapezoid(_L25, _L26, _L29, _L28, (0 #4 : 'T), _L27);
    _L25= U;
    _L26= Reset;
    _L27= TimeCycle;
    _L28= LowLimit;
    _L29= HiLimit;
    Y= _L23;
    _= _L24;
  tel

  node IntegrFwd(
      U : 'T;
      Reset : bool;
      TimeCycle : 'T;
      LowLimit : 'T;
      HiLimit : 'T)
    returns (Y : 'T)
    where 'T float
  var
    _L24 : bool;
    _L23 : 'T;
    _L25 : 'T;
    _L26 : bool;
    _L27 : 'T;
    _L28 : 'T;
    _L29 : 'T;
  let
    _L23, _L24= #1 IntegralForward(_L25, _L26, _L29, _L28, (0 #3 : 'T), _L27);
    _L25= U;
    _L26= Reset;
    _L27= TimeCycle;
    _L28= LowLimit;
    _L29= HiLimit;
    Y= _L23;
    _= _L24;
  tel

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/liblinear_MTC_INST/filters.xscade */
package filters
  node TransferFcn01(In : 'T; Num : 'T; Den : 'T^2)
    returns (Out : 'T)
    where 'T float
  var
    _L44 : 'T;
    _L40 : 'T;
    _L29 : 'T;
    _L65 : 'T;
    _L66 : 'T;
    _L69 : 'T;
    _L72 : 'T;
    _L77 : 'T;
    _L78 : 'T;
  let
    Out= _L65;
    _L44= _L72 #1 * _L65;
    _L40= _L29 #2 * _L69;
    _L29= In;
    _L65= _L77 #3 / _L78;
    _L66= _L40 #4 - _L44;
    _L69= Num;
    _L72= Den #1[1];
    _L77= #6 fby(_L66; 1; 0.0);
    _L78= Den #0[0];
  tel

  node SumDelay(Delay : 'T; Val : 'T) returns (Out : 'T) where 'T float
  var
    _L2 : 'T;
    _L3 : 'T;
    _L15 : 'T;
    _L21 : 'T;
  let
    _L2= Delay;
    _L3= Val;
    Out= _L15;
    _L15= _L21 #1 + _L3;
    _L21= #2 fby(_L2; 1; (0 #3 : 'T));
  tel

  node Filter01(In : 'T; Num : 'T; Den : 'T^2)
    returns (Out : 'T)
    where 'T numeric
  var
    _L46 : 'T;
    _L66 : 'T;
    _L69 : 'T;
    _L71 : 'T;
    _L72 : 'T;
    _L73 : 'T;
    _L74 : 'T;
    _L76 : 'T;
    _L77 : 'T;
  let
    _L46= _L73 #1 / _L66;
    Out= _L46;
    _L66= Den #2[0];
    _L69= In;
    _L71= _L69 #3 * _L72;
    _L72= Num;
    _L73= _L71 #4 - _L77;
    _L74= _L76 #5 * _L46;
    _L76= Den #1[1];
    _L77= #7 fby(_L74; 1; (0 #2 : 'T));
  tel

  node Filter11(In : 'T; Num : 'T^2; Den : 'T^2)
    returns (Out : 'T)
    where 'T numeric
  var
    _L200 : 'T;
    _L203 : 'T;
    _L229 : 'T;
    _L230 : 'T;
    _L231 : 'T;
    _L232 : 'T;
    _L233 : 'T;
    _L234 : 'T;
    _L235 : 'T;
    _L243 : 'T;
    _L244 : 'T;
    _L245 : 'T;
  let
    _L203= In;
    _L200= _L230 #1 * _L203;
    _L229= _L231 #2 / _L245;
    Out= _L229;
    _L230= Num #3[0];
    _L231= _L200 #4 + _L244;
    _L232= Den #1[1];
    _L233= Num #2[1];
    _L234= _L203 #7 * _L233;
    _L235= _L232 #8 * _L229;
    _L243= _L234 #9 - _L235;
    _L244= #10 fby(_L243; 1; (0 #1 : 'T));
    _L245= Den #0[0];
  tel

  node Filter0D<<Ds>>(In : 'T; Num : 'T; Den : 'T^Ds)
    returns (Out : 'T)
    where 'T float
  var
    _L3 : 'T;
    _L14 : 'T^(Ds - 1);
    _L68 : 'T;
    _L73 : 'T^(Ds - 1);
    _L16 : 'T^(Ds - 1);
    _L116 : 'T;
    _L126 : 'T;
    _L129 : 'T;
    _L132 : 'T^(Ds - 1 - 1 + 1);
    _L134 : 'T^Ds;
    _L135 : 'T;
    _L136 : 'T;
    _L137 : 'T;
    _L138 : 'T;
  let
    _L3= In;
    _L14= #1 reverse _L16;
    _L68= ( fold #2 SumDelay <<Ds - 1>>)(_L126, _L14);
    Out= _L116;
    _L73= (_L116)#5^(Ds - 1);
    _L116= _L138 #7 / _L136;
    _L126= (0 #3 : 'T);
    _L129= _L3 #8 * _L135;
    _L132= _L134 #9 [1 .. Ds - 1];
    _L134= Den;
    _L135= Num;
    _L136= Den #0[0];
    _L137= #12 fby(_L68; 1; (0 #2 : 'T));
    _L138= _L129 #13 - _L137;
    _L16= ( map #14 $*$ <<Ds - 1>>)(_L132, _L73);
  tel

  node FilterNN<<Ns>>(In : 'T; Num : 'T^Ns; Den : 'T^Ns)
    returns (Out : 'T)
    where 'T float
  var
    _L3 : 'T;
    _L7 : 'T^(Ns - 1);
    _L68 : 'T;
    _L71 : 'T^(Ns - 1);
    _L73 : 'T^(Ns - 1);
    _L10 : 'T^(Ns - 1);
    _L16 : 'T^(Ns - 1);
    _L116 : 'T;
    _L126 : 'T;
    _L128 : 'T^(Ns - 1);
    _L129 : 'T^Ns;
    _L132 : 'T^Ns;
    _L133 : 'T;
    _L134 : 'T^(Ns - 1 - 1 + 1);
    _L135 : 'T;
    _L141 : 'T;
    _L140 : 'T;
    _L142 : 'T;
    _L143 : 'T;
    _L144 : 'T^(Ns - 1 - 1 + 1);
  let
    _L3= In;
    _L7= (_L3)#1^(Ns - 1);
    _L68= ( fold #3 SumDelay <<Ns - 1>>)(_L126, _L128);
    Out= _L116;
    _L73= (_L116)#6^(Ns - 1);
    _L116= _L143 #8 / _L133;
    _L126= (0 #1 : 'T);
    _L128= #9 reverse _L71;
    _L129= Num;
    _L132= Den;
    _L133= Den #0[0];
    _L134= _L129 #11 [1 .. Ns - 1];
    _L135= #13 fby(_L68; 1; (0 #2 : 'T));
    _L140= Num #1[0];
    _L141= In;
    _L142= _L141 #15 * _L140;
    _L143= _L142 #16 + _L135;
    _L144= _L132 #17 [1 .. Ns - 1];
    _L10= ( map #19 $*$ <<Ns - 1>>)(_L7, _L134);
    _L16= ( map #22 $*$ <<Ns - 1>>)(_L144, _L73);
    _L71= ( map #25 $-$ <<Ns - 1>>)(_L10, _L16);
  tel

  node FilterND<<Ns, Ds>>(In : 'T; Num : 'T^Ns; Den : 'T^Ds)
    returns (Out : 'T)
    where 'T float
  var
    _L7 : 'T^(Ns - 1);
    _L68 : 'T;
    _L71 : 'T^(Ds - 1);
    _L73 : 'T^(Ds - 1);
    _L10 : 'T^(Ns - 1);
    _L16 : 'T^(Ds - 1);
    _L116 : 'T;
    _L118 : 'T;
    _L120 : 'T^(Ns - 1 + (Ds - Ns));
    _L124 : 'T^(Ds - Ns);
    _L126 : 'T;
    _L128 : 'T;
    _L129 : 'T^(Ds - 1);
    _L130 : 'T^Ns;
    _L133 : 'T^Ds;
    _L134 : 'T;
    _L135 : 'T^(Ds - 1 - 1 + 1);
    _L136 : 'T^(Ns - 1 - 1 + 1);
    _L137 : 'T;
    _L139 : 'T;
    _L138 : 'T;
    _L140 : 'T;
    _L143 : 'T;
  let
    _L7= (_L128)#1^(Ns - 1);
    _L68= ( fold #3 SumDelay <<Ds - 1>>)(_L126, _L129);
    Out= _L116;
    _L73= (_L116)#6^(Ds - 1);
    _L116= _L137 #8 / _L134;
    _L118= (0 #1 : 'T);
    _L120= _L10 #9 @ _L124;
    _L124= (_L118)#10^(Ds - Ns);
    _L126= (0 #3 : 'T);
    _L128= In;
    _L129= #12 reverse _L71;
    _L130= Num;
    _L133= Den;
    _L134= Den #0[0];
    _L135= _L133 #14 [1 .. Ds - 1];
    _L136= _L130 #16 [1 .. Ns - 1];
    _L137= _L140 #18 + _L143;
    _L138= In;
    _L139= Num #1[0];
    _L140= _L138 #20 * _L139;
    _L143= #21 fby(_L68; 1; (0 #2 : 'T));
    _L10= ( map #22 $*$ <<Ns - 1>>)(_L7, _L136);
    _L16= ( map #25 $*$ <<Ds - 1>>)(_L135, _L73);
    _L71= ( map #28 $-$ <<Ds - 1>>)(_L120, _L16);
  tel

  node TransferFcn02(In : 'T; Num : 'T; Den : 'T^3)
    returns (Out : 'T)
    where 'T float
  var
    _L29 : 'T;
    _L65 : 'T;
    _L75 : 'T;
    _L76 : 'T;
    _L77 : 'T;
    _L78 : 'T;
    _L79 : 'T;
    _L80 : 'T;
    _L81 : 'T;
    _L85 : 'T;
    _L86 : 'T;
    _L87 : 'T;
    _L107 : 'T;
  let
    Out= _L65;
    _L29= In;
    _L65= _L107 #1 / _L87;
    _L75= Den #2[2];
    _L76= _L75 #3 * _L65;
    _L77= _L29 #4 * _L78;
    _L78= Num;
    _L80= #5 fby(_L79; 1; (0 #1 : 'T));
    _L81= _L85 #6 * _L65;
    _L85= Den #1[1];
    _L86= _L80 #8 - _L81;
    _L87= Den #0[0];
    _L79= _L77 #10 - _L76;
    _L107= #11 fby(_L86; 1; (0 #2 : 'T));
  tel

  node Filter02(In : 'T; Num : 'T; Den : 'T^3) returns (Out : 'T) where 'T float
  var
    _L29 : 'T;
    _L40 : 'T;
    _L46 : 'T;
    _L63 : 'T;
    _L64 : 'T;
    _L65 : 'T;
    _L66 : 'T;
    _L67 : 'T;
    _L68 : 'T;
    _L69 : 'T;
    _L70 : 'T;
    _L74 : 'T;
    _L75 : 'T;
  let
    _L29= In;
    _L40= _L29 #1 * _L63;
    _L46= _L74 #2 / _L69;
    Out= _L46;
    _L63= Num;
    _L65= Den #1[1];
    _L66= _L65 #4 * _L46;
    _L67= _L68 #5 * _L46;
    _L68= Den #2[2];
    _L69= Den #0[0];
    _L70= #8 fby(_L66; 1; (0.0 #1 : 'T));
    _L74= _L64 #9 - _L75;
    _L75= #10 fby(_L67; 2; (0.0 #2 : 'T));
    _L64= _L40 #11 - _L70;
  tel

  node TransferFcn0D<<Ds>>(In : 'T; Num : 'T; Den : 'T^Ds)
    returns (Out : 'T)
    where 'T float
  var
    _L4 : 'T^(Ds - 2 - 1 + 1);
    _L5 : 'T^Ds;
    _L6 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : 'T;
    _L10 : 'T;
    _L11 : 'T;
    _L18 : 'T;
    _L19 : 'T^(Ds - 2);
    _L20 : 'T;
    _L21 : 'T;
    _L22 : 'T;
    _L23 : 'T^(Ds - 2);
    _L26 : 'T^(Ds - 2);
  let
    _L4= _L5 #1 [1 .. Ds - 2];
    _L5= Den;
    _L6= In;
    _L7= Num;
    _L8= _L6 #3 * _L7;
    _L9= Den #0[Ds #14 - 1];
    _L10= _L9 #6 * _L21;
    _L19= #7 reverse _L23;
    _L20= #8 fby(_L18; 1; 0.0);
    _L21= _L20 #9 / _L22;
    _L22= Den #1[0];
    Out= _L21;
    _L26= (_L21)#11^(Ds - 2);
    _L11= _L8 #13 - _L10;
    _L18= ( fold #14 SumDelay <<Ds - 2>>)(_L11, _L19);
    _L23= ( map #17 $*$ <<Ds - 2>>)(_L4, _L26);
  tel

  node Filter01Norm(In : 'T; Num : 'T; Den : 'T)
    returns (Out : 'T)
    where 'T numeric
  var
    _L69 : 'T;
    _L71 : 'T;
    _L72 : 'T;
    _L73 : 'T;
    _L74 : 'T;
    _L76 : 'T;
    _L77 : 'T;
  let
    Out= _L73;
    _L69= In;
    _L71= _L69 #1 * _L72;
    _L72= Num;
    _L73= _L71 #2 - _L77;
    _L74= _L76 #3 * _L73;
    _L76= Den;
    _L77= #4 fby(_L74; 1; (0 #2 : 'T));
  tel

  node Filter12(In : 'T; Num : 'T^2; Den : 'T^3)
    returns (Out : 'T)
    where 'T numeric
  var
    _L200 : 'T;
    _L203 : 'T;
    _L229 : 'T;
    _L230 : 'T;
    _L231 : 'T;
    _L232 : 'T;
    _L233 : 'T;
    _L234 : 'T;
    _L235 : 'T;
    _L243 : 'T;
    _L244 : 'T;
    _L245 : 'T;
    _L248 : 'T;
    _L249 : 'T;
    _L250 : 'T;
    _L253 : 'T;
  let
    _L203= In;
    _L200= _L230 #1 * _L203;
    _L229= _L248 #2 / _L245;
    Out= _L229;
    _L230= Num #0[0];
    _L231= _L200 #4 + _L244;
    _L232= Den #2[1];
    _L233= Num #1[1];
    _L234= _L203 #7 * _L233;
    _L235= _L232 #8 * _L229;
    _L243= _L234 #9 - _L235;
    _L244= #10 fby(_L243; 1; (0 #2 : 'T));
    _L245= Den #4[0];
    _L248= _L231 #12 - _L250;
    _L249= _L253 #13 * _L229;
    _L250= #14 fby(_L249; 2; (0 #1 : 'T));
    _L253= Den #3[2];
  tel

  node TransferFcn12(In : 'T; Num : 'T^2; Den : 'T^3)
    returns (Out : 'T)
    where 'T float
  var
    _L29 : 'T;
    _L65 : 'T;
    _L75 : 'T;
    _L76 : 'T;
    _L77 : 'T;
    _L78 : 'T;
    _L79 : 'T;
    _L80 : 'T;
    _L81 : 'T;
    _L85 : 'T;
    _L86 : 'T;
    _L87 : 'T;
    _L93 : 'T;
    _L94 : 'T;
    _L97 : 'T;
    _L98 : 'T;
    _L104 : 'T;
  let
    Out= _L65;
    _L29= In;
    _L65= _L98 #1 / _L87;
    _L75= Den #1[2];
    _L76= _L75 #3 * _L65;
    _L77= _L78 #4 * _L29;
    _L78= Num #0[1];
    _L80= #6 fby(_L79; 1; (0 #1 : 'T));
    _L81= _L85 #7 * _L65;
    _L85= Den #3[1];
    _L87= Den #4[0];
    _L93= _L94 #10 - _L81;
    _L86= _L80 #11 + _L93;
    _L94= _L97 #12 * _L104;
    _L97= Num #2[0];
    _L98= #14 fby(_L86; 1; (0 #2 : 'T));
    _L79= _L77 #15 - _L76;
    _L104= In;
  tel

  node TransferFcnND<<Ns, Ds>>(In : 'T; Num : 'T^Ns; Den : 'T^Ds)
    returns (Out : 'T)
    where 'T float
  var
    _L4 : 'T^(Ds - 1 - 1 + 1);
    _L5 : 'T^Ds;
    _L6 : 'T;
    _L7 : 'T^Ns;
    _L18 : 'T;
    _L19 : 'T^(Ds - 1);
    _L20 : 'T;
    _L21 : 'T;
    _L22 : 'T;
    _L23 : 'T^(Ds - 1);
    _L26 : 'T^(Ds - 1);
    _L31 : 'T^Ns;
    _L32 : 'T^Ns;
    _L36 : 'T^(Ds - Ns - 1 + Ns);
    _L38 : 'T;
    _L41 : 'T^(Ds - 1);
    _L47 : 'T;
    _L48 : 'T^(Ds - Ns - 1);
  let
    _L4= _L5 #1 [1 .. Ds - 1];
    _L5= Den;
    _L6= In;
    _L7= Num;
    _L18= ( fold #3 SumDelay <<Ds - 1>>)(_L47, _L19);
    _L19= #6 reverse _L41;
    _L20= #7 fby(_L18; 1; 0.0);
    _L21= _L20 #8 / _L22;
    _L22= Den #0[0];
    Out= _L21;
    _L26= (_L21)#10^(Ds - 1);
    _L31= (_L6)#12^Ns;
    _L36= _L48 #13 @ _L32;
    _L48= (_L38)#14^(Ds - Ns - 1);
    _L38= (0 #1 : 'T);
    _L47= (0 #2 : 'T);
    _L32= ( map #17 $*$ <<Ns>>)(_L31, _L7);
    _L23= ( map #19 $*$ <<Ds - 1>>)(_L4, _L26);
    _L41= ( map #22 $-$ <<Ds - 1>>)(_L36, _L23);
  tel

  node Filter02Norm(In : 'T; Num : 'T; Den : 'T^2)
    returns (Out : 'T)
    where 'T numeric
  var
    _L29 : 'T;
    _L40 : 'T;
    _L63 : 'T;
    _L64 : 'T;
    _L65 : 'T;
    _L66 : 'T;
    _L67 : 'T;
    _L68 : 'T;
    _L70 : 'T;
    _L74 : 'T;
    _L75 : 'T;
  let
    _L29= In;
    _L40= _L29 #1 * _L63;
    Out= _L74;
    _L63= Num;
    _L65= Den #0[0];
    _L66= _L65 #3 * _L74;
    _L67= _L68 #4 * _L74;
    _L68= Den #1[1];
    _L70= #6 fby(_L66; 1; (0 #4 : 'T));
    _L74= _L64 #7 - _L75;
    _L75= #8 fby(_L67; 2; (0 #3 : 'T));
    _L64= _L40 #9 - _L70;
  tel

  node Filter11Norm(In : 'T; Num : 'T^2; Den : 'T)
    returns (Out : 'T)
    where 'T numeric
  var
    _L200 : 'T;
    _L203 : 'T;
    _L230 : 'T;
    _L231 : 'T;
    _L232 : 'T;
    _L233 : 'T;
    _L234 : 'T;
    _L235 : 'T;
    _L243 : 'T;
    _L244 : 'T;
  let
    _L203= In;
    _L200= _L230 #1 * _L203;
    Out= _L231;
    _L230= Num #0[0];
    _L231= _L200 #3 + _L244;
    _L232= Den;
    _L233= Num #1[1];
    _L234= _L203 #5 * _L233;
    _L235= _L232 #6 * _L231;
    _L243= _L234 #7 - _L235;
    _L244= #8 fby(_L243; 1; (0 #1 : 'T));
  tel

  node Filter12Norm(In : 'T; Num : 'T^2; Den : 'T^2)
    returns (Out : 'T)
    where 'T numeric
  var
    _L200 : 'T;
    _L203 : 'T;
    _L230 : 'T;
    _L231 : 'T;
    _L232 : 'T;
    _L233 : 'T;
    _L234 : 'T;
    _L235 : 'T;
    _L243 : 'T;
    _L244 : 'T;
    _L248 : 'T;
    _L249 : 'T;
    _L250 : 'T;
    _L253 : 'T;
  let
    _L203= In;
    _L200= _L230 #1 * _L203;
    Out= _L248;
    _L230= Num #0[0];
    _L231= _L200 #3 + _L244;
    _L232= Den #2[0];
    _L233= Num #1[1];
    _L234= _L203 #6 * _L233;
    _L235= _L232 #7 * _L248;
    _L243= _L234 #8 - _L235;
    _L244= #9 fby(_L243; 1; (0 #2 : 'T));
    _L248= _L231 #10 - _L250;
    _L249= _L253 #11 * _L248;
    _L250= #12 fby(_L249; 2; (0 #1 : 'T));
    _L253= Den #3[1];
  tel

  node Filter0DNorm<<Ds>>(In : 'T; Num : 'T; Den : 'T^Ds)
    returns (Out : 'T)
    where 'T float
  var
    _L3 : 'T;
    _L14 : 'T^Ds;
    _L68 : 'T;
    _L73 : 'T^Ds;
    _L16 : 'T^Ds;
    _L126 : 'T;
    _L129 : 'T;
    _L134 : 'T^Ds;
    _L135 : 'T;
    _L137 : 'T;
    _L138 : 'T;
  let
    _L3= In;
    _L14= #1 reverse _L16;
    _L68= ( fold #2 SumDelay <<Ds>>)(_L126, _L14);
    Out= _L138;
    _L73= (_L138)#4^Ds;
    _L126= (0 #4 : 'T);
    _L129= _L3 #5 * _L135;
    _L134= Den;
    _L135= Num;
    _L137= #6 fby(_L68; 1; (0 #3 : 'T));
    _L138= _L129 #7 - _L137;
    _L16= ( map #8 $*$ <<Ds>>)(_L134, _L73);
  tel

  node FilterNDNorm<<Ns, Ds>>(In : 'T; Num : 'T^Ns; Den : 'T^Ds)
    returns (Out : 'T)
    where 'T float
  var
    _L7 : 'T^(Ns - 1);
    _L68 : 'T;
    _L71 : 'T^Ds;
    _L73 : 'T^Ds;
    _L10 : 'T^(Ns - 1);
    _L16 : 'T^Ds;
    _L118 : 'T;
    _L120 : 'T^(Ns - 1 + (Ds - Ns + 1));
    _L124 : 'T^(Ds - Ns + 1);
    _L126 : 'T;
    _L128 : 'T;
    _L129 : 'T^Ds;
    _L130 : 'T^Ns;
    _L133 : 'T^Ds;
    _L136 : 'T^(Ns - 1 - 1 + 1);
    _L137 : 'T;
    _L139 : 'T;
    _L138 : 'T;
    _L140 : 'T;
    _L143 : 'T;
  let
    _L7= (_L128)#1^(Ns - 1);
    _L68= ( fold #3 SumDelay <<Ds>>)(_L126, _L129);
    Out= _L137;
    _L73= (_L137)#5^Ds;
    _L118= (0 #1 : 'T);
    _L120= _L10 #6 @ _L124;
    _L124= (_L118)#7^(Ds - Ns + 1);
    _L126= (0 #2 : 'T);
    _L128= In;
    _L129= #10 reverse _L71;
    _L130= Num;
    _L133= Den;
    _L136= _L130 #11 [1 .. Ns - 1];
    _L137= _L140 #13 + _L143;
    _L138= In;
    _L139= Num #0[0];
    _L140= _L138 #15 * _L139;
    _L143= #16 fby(_L68; 1; (0 #3 : 'T));
    _L10= ( map #17 $*$ <<Ns - 1>>)(_L7, _L136);
    _L16= ( map #20 $*$ <<Ds>>)(_L133, _L73);
    _L71= ( map #22 $-$ <<Ds>>)(_L120, _L16);
  tel

  node FilterNNNorm<<Ns>>(In : 'T; Num : 'T^Ns; Den : 'T^(Ns - 1))
    returns (Out : 'T)
    where 'T float
  var
    _L3 : 'T;
    _L7 : 'T^(Ns - 1);
    _L68 : 'T;
    _L71 : 'T^(Ns - 1);
    _L73 : 'T^(Ns - 1);
    _L10 : 'T^(Ns - 1);
    _L16 : 'T^(Ns - 1);
    _L126 : 'T;
    _L128 : 'T^(Ns - 1);
    _L129 : 'T^Ns;
    _L132 : 'T^(Ns - 1);
    _L134 : 'T^(Ns - 1 - 1 + 1);
    _L135 : 'T;
    _L141 : 'T;
    _L140 : 'T;
    _L142 : 'T;
    _L143 : 'T;
  let
    _L3= In;
    _L7= (_L3)#1^(Ns - 1);
    _L68= ( fold #3 SumDelay <<Ns - 1>>)(_L126, _L128);
    Out= _L143;
    _L73= (_L143)#6^(Ns - 1);
    _L126= (0 #1 : 'T);
    _L128= #8 reverse _L71;
    _L129= Num;
    _L132= Den;
    _L134= _L129 #9 [1 .. Ns - 1];
    _L135= #11 fby(_L68; 1; (0 #2 : 'T));
    _L140= Num #0[0];
    _L141= In;
    _L142= _L141 #13 * _L140;
    _L143= _L142 #14 + _L135;
    _L10= ( map #15 $*$ <<Ns - 1>>)(_L7, _L134);
    _L16= ( map #18 $*$ <<Ns - 1>>)(_L132, _L73);
    _L71= ( map #21 $-$ <<Ns - 1>>)(_L10, _L16);
  tel

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/libmath_MTC_INST/vect.xscade */
package vect
  function #pragma kcg expand #end ScalProd<<n>>(
      V : 'T^n;
      W : 'T^n;
      MTC_AC_SP : bool)
    returns (
      SP : 'T;
      MTC_AC_V : bool default = false;
      MTC_AC_W : bool default = false)
    where 'T numeric
  var
    _L2 : 'T^n;
    _L3 : 'T^n;
    _L4 : 'T;
    _L6 : 'T;
    _L7 : 'T^n;
  let
    _L2= V;
    _L3= W;
    SP= _L6;
    _L4= (0 #1 : 'T);
    _L6= ( fold #2 $+$ <<n>>)(_L4, _L7);
    _L7= ( map #1 $*$ <<n>>)(_L2, _L3);
    _= MTC_AC_SP;
    MTC_AC_V= false;
    MTC_AC_W= false;
  tel

  function MatVectProd<<m, n>>(A : 'T^n^m; V : 'T^n; MTC_AC_Outputs : bool)
    returns (R : 'T^m)
    where 'T numeric
  var
    _L1 : 'T^n^m;
    _L2 : 'T^n;
    _L4 : 'T^n^m;
    _L7 : 'T^m;
  let
    _L1= A;
    _L2= V;
    R= _L7;
    _L7=
      ( map (#1 MTCEx::MTC_Instrumenters::vect_ScalProd_MTC_INST <<n>>) <<m>>)(_L1,
        _L4, (false)^m, (false)^m);
    _L4= (_L2)#3^m;
    _= MTC_AC_Outputs;
  tel

  function MatProd<<m, n, p>>(A : 'T^n^m; B : 'T^p^n; MTC_AC_Outputs : bool)
    returns (C : 'T^p^m)
    where 'T numeric
  var
    _L1 : 'T^n^m;
    _L2 : 'T^p^n;
    _L4 : 'T^p^n^m;
    _L7 : 'T^p^m;
  let
    _L1= A;
    _L2= B;
    C= _L7;
    _L4= (_L2)#3^m;
    _L7= ( map (#1 VectMatProd <<n, p>>) <<m>>)(_L1, _L4, (false)^m);
    _= MTC_AC_Outputs;
  tel

  function VectMatProd<<m, n>>(V : 'T^m; A : 'T^n^m; MTC_AC_Outputs : bool)
    returns (R : 'T^n)
    where 'T numeric
  var
    _L1 : 'T^n^m;
    _L2 : 'T^m;
    _L4 : 'T^m^n;
    _L5 : 'T^m^n;
    _L8 : 'T^n;
  let
    _L1= A;
    _L2= V;
    R= _L8;
    _L8=
      ( map (#1 MTCEx::MTC_Instrumenters::vect_ScalProd_MTC_INST <<m>>) <<n>>)(_L5,
        _L4, (false)^n, (false)^n);
    _L4= (_L2)#1^n;
    _L5= #1 transpose (_L1; 1; 2);
    _= MTC_AC_Outputs;
  tel

  function MatAdd<<m, n>>(A : 'T^n^m; B : 'T^n^m; MTC_AC_Outputs : bool)
    returns (C : 'T^n^m)
    where 'T numeric
  var
    _L2 : 'T^n^m;
    _L3 : 'T^n^m;
    _L4 : 'T^n^m;
  let
    _L2= ( map (#1 VectAdd <<n>>) <<m>>)(_L3, _L4, (false)^m);
    _L3= A;
    _L4= B;
    C= _L2;
    _= MTC_AC_Outputs;
  tel

  function Inv4x4(A : 'T^4^4; Epsilon : 'T; MTC_AC_Outputs : bool)
    returns (InvA : 'T^4^4; Error : bool)
    where 'T float
  var
    Det : 'T;
    _L5 : bool;
    _L4 : 'T;
    _L3 : 'T;
    _L2 : 'T^4^4;
    _L1 : 'T;
  let
    _L5= _L3 #1 <= _L4;
    _L4= Epsilon;
    assume A1 : Epsilon #1 >= 0.0;
    _L3= #1 if Det #2 < 0.0 then (#8 - Det) else (Det);
    Error= _L5;
    activate IfBlock1 if Error
      then let
        InvA= ((0.0)#2^4)#1^4;
      tel
      else var
        C00 : 'T;
        C01 : 'T;
        C02 : 'T;
        C10 : 'T;
        C11 : 'T;
        C12 : 'T;
        C20 : 'T;
        C21 : 'T;
        C22 : 'T;
        C03 : 'T;
        C13 : 'T;
        C23 : 'T;
        C30 : 'T;
        C31 : 'T;
        C32 : 'T;
        C33 : 'T;
        C0011 : 'T;
        C0021 : 'T;
        C0031 : 'T;
        C0110 : 'T;
        C0120 : 'T;
        C0130 : 'T;
        C0210 : 'T;
        C0220 : 'T;
        C0230 : 'T;
        C0310 : 'T;
        C0320 : 'T;
        C0330 : 'T;
        C1001 : 'T;
        C1021 : 'T;
        C1031 : 'T;
        C1100 : 'T;
        C1120 : 'T;
        C1130 : 'T;
        C1200 : 'T;
        C1220 : 'T;
        C1230 : 'T;
        C1300 : 'T;
        C1320 : 'T;
        C1330 : 'T;
        C2001 : 'T;
        C2031 : 'T;
        C2011 : 'T;
        C2100 : 'T;
        C2110 : 'T;
        C2130 : 'T;
        C2200 : 'T;
        C2210 : 'T;
        C2230 : 'T;
        C2300 : 'T;
        C2310 : 'T;
        C2330 : 'T;
        C3001 : 'T;
        C3011 : 'T;
        C3021 : 'T;
        C3100 : 'T;
        C3110 : 'T;
        C3120 : 'T;
        C3200 : 'T;
        C3220 : 'T;
        C3210 : 'T;
        C3300 : 'T;
        C3310 : 'T;
        C3320 : 'T;
      let
        InvA=
          #16[#17[C00 #49 / Det, C10 #50 / Det, C20 #51 / Det, C30 #52 / Det],
            #18[C01 #53 / Det, C11 #54 / Det, C21 #55 / Det, C31 #56 / Det],
            #19[C02 #57 / Det, C12 #58 / Det, C22 #59 / Det, C32 #60 / Det],
            #20[C03 #61 / Det, C13 #62 / Det, C23 #63 / Det, C33 #64 / Det]];
        C00=
          A #337[1][1] #199 * C0011 #55 + A #338[2][1] #200 * C0021 #55 +
          A #339[3][1] #201 * C0031;
        C0011= A #340[2][2] #202 * A #341[3][3] #36 - A #342[2][3] #203 * A #343[3][2];
        C0021=
          #35 - A #344[1][2] #204 * A #345[3][3] #56 + A #346[1][3] #205 * A #347[3][2];
        C0031= A #348[1][2] #206 * A #349[2][3] #37 - A #350[1][3] #207 * A #351[2][2];
        C01=
          A #352[1][0] #208 * C0110 #57 + A #353[2][0] #209 * C0120 #57 +
          A #354[3][0] #210 * C0130;
        C0110=
          #36 - A #355[2][2] #211 * A #356[3][3] #58 + A #357[2][3] #212 * A #358[3][2];
        C0120= A #359[1][2] #213 * A #360[3][3] #38 - A #361[1][3] #214 * A #362[3][2];
        C0130=
          #37 - A #363[1][2] #215 * A #364[2][3] #59 + A #365[1][3] #216 * A #366[2][2];
        C02=
          A #367[1][0] #217 * C0210 #60 + A #368[2][0] #218 * C0220 #60 +
          A #369[3][0] #219 * C0230;
        C0210= A #370[2][1] #220 * A #371[3][3] #39 - A #372[2][3] #221 * A #373[3][1];
        C0220=
          #38 - A #374[1][1] #222 * A #375[3][3] #61 + A #376[1][3] #223 * A #377[3][1];
        C0230= A #378[1][1] #224 * A #379[2][3] #40 - A #380[1][3] #225 * A #381[2][1];
        C03=
          A #382[1][0] #226 * C0310 #62 + A #383[2][0] #227 * C0320 #62 +
          A #384[3][0] #228 * C0330;
        C0310=
          #39 - A #385[2][1] #229 * A #386[3][2] #63 + A #387[2][2] #230 * A #388[3][1];
        C0320= A #389[1][1] #231 * A #390[3][2] #41 - A #391[1][2] #232 * A #392[3][1];
        C0330=
          #40 - A #393[1][1] #233 * A #394[2][2] #64 + A #395[1][2] #234 * A #396[2][1];
        C10=
          A #397[0][1] #235 * C1001 #65 + A #398[2][1] #236 * C1021 #65 +
          A #399[3][1] #237 * C1031;
        C1001=
          #41 - A #400[2][2] #238 * A #401[3][3] #66 + A #402[2][3] #239 * A #403[3][2];
        C1021= A #404[0][2] #240 * A #405[3][3] #42 - A #406[0][3] #241 * A #407[3][2];
        C1031=
          #42 - A #408[0][2] #242 * A #409[2][3] #67 + A #410[0][3] #243 * A #411[2][2];
        C11=
          A #412[0][0] #244 * C1100 #68 + A #413[2][0] #245 * C1120 #68 +
          A #414[3][0] #246 * C1130;
        C1100= A #415[2][2] #247 * A #416[3][3] #43 - A #417[2][3] #248 * A #418[3][2];
        C1120=
          #43 - A #419[0][2] #249 * A #420[3][3] #69 + A #421[0][3] #250 * A #422[3][2];
        C1130= A #423[0][2] #251 * A #424[2][3] #44 - A #425[0][3] #252 * A #426[2][2];
        C12=
          A #427[0][0] #253 * C1200 #70 + A #428[2][0] #254 * C1220 #70 +
          A #429[3][0] #255 * C1230;
        C1200=
          #44 - A #430[2][1] #256 * A #431[3][3] #71 + A #432[2][3] #257 * A #433[3][1];
        C1220= A #434[0][1] #258 * A #435[3][3] #45 - A #436[0][3] #259 * A #437[3][1];
        C1230=
          #45 - A #438[0][1] #260 * A #439[2][3] #72 + A #440[0][3] #261 * A #441[2][1];
        C13=
          A #442[0][0] #262 * C1300 #73 + A #443[2][0] #263 * C1320 #73 +
          A #444[3][0] #264 * C1330;
        C1300= A #445[2][1] #265 * A #446[3][2] #46 - A #447[2][2] #266 * A #448[3][1];
        C1320=
          #46 - A #449[0][1] #267 * A #450[3][2] #74 + A #451[0][2] #268 * A #452[3][1];
        C1330= A #453[0][1] #269 * A #454[2][2] #47 - A #455[0][2] #270 * A #456[2][1];
        C20=
          A #457[0][1] #271 * C2001 #75 + A #458[1][1] #272 * C2011 #75 +
          A #459[3][1] #273 * C2031;
        C2001= A #460[1][2] #274 * A #461[3][3] #48 - A #462[1][3] #275 * A #463[3][2];
        C2011=
          #47 - A #464[0][2] #276 * A #465[3][3] #76 + A #466[0][3] #277 * A #467[3][2];
        C2031= A #468[0][2] #278 * A #469[1][3] #49 - A #470[0][3] #279 * A #471[1][2];
        C21=
          A #472[0][0] #280 * C2100 #77 + A #473[1][0] #281 * C2110 #77 +
          A #474[3][0] #282 * C2130;
        C2100=
          #48 - A #475[1][2] #283 * A #476[3][3] #78 + A #477[1][3] #284 * A #478[3][2];
        C2110= A #479[0][2] #285 * A #480[3][3] #50 - A #481[0][3] #286 * A #482[3][2];
        C2130=
          #49 - A #483[0][2] #287 * A #484[1][3] #79 + A #485[0][3] #288 * A #486[1][2];
        C22=
          A #487[0][0] #289 * C2200 #80 + A #488[1][0] #290 * C2210 #80 +
          A #489[3][0] #291 * C2230;
        C2200= A #490[1][1] #292 * A #491[3][3] #51 - A #492[1][3] #293 * A #493[3][1];
        C2210=
          #50 - A #494[0][1] #294 * A #495[3][3] #81 + A #496[0][3] #295 * A #497[3][1];
        C2230= A #498[0][1] #296 * A #499[1][3] #52 - A #500[0][3] #297 * A #501[1][1];
        C23=
          A #502[0][0] #298 * C2300 #82 + A #503[1][0] #299 * C2310 #82 +
          A #504[3][0] #300 * C2330;
        C2300=
          #51 - A #505[1][1] #301 * A #506[3][2] #83 + A #507[1][2] #302 * A #508[3][1];
        C2310= A #509[0][1] #303 * A #510[3][2] #53 - A #511[0][2] #304 * A #512[3][1];
        C2330=
          #52 - A #513[0][1] #305 * A #514[1][2] #84 + A #515[0][2] #306 * A #516[1][1];
        C30=
          A #517[0][1] #307 * C3001 #85 + A #518[1][1] #308 * C3011 #85 +
          A #519[2][1] #309 * C3021;
        C3001=
          #53 - A #520[1][2] #310 * A #521[2][3] #86 + A #522[1][3] #311 * A #523[2][2];
        C3011= A #524[0][2] #312 * A #525[2][3] #54 - A #526[0][3] #313 * A #527[2][2];
        C3021=
          #54 - A #528[0][2] #314 * A #529[1][3] #87 + A #530[0][3] #315 * A #531[1][2];
        C31=
          A #532[0][0] #316 * C3100 #88 + A #533[1][0] #317 * C3110 #88 +
          A #534[2][0] #318 * C3120;
        C3100= A #535[1][2] #319 * A #536[2][3] #55 - A #537[1][3] #320 * A #538[2][2];
        C3110=
          #55 - A #539[0][2] #321 * A #540[2][3] #89 + A #541[0][3] #322 * A #542[2][2];
        C3120= A #543[0][2] #323 * A #544[1][3] #56 - A #545[0][3] #324 * A #546[1][2];
        C32=
          A #547[0][0] #325 * C3200 #90 + A #548[1][0] #326 * C3210 #90 +
          A #549[2][0] #327 * C3220;
        C3200=
          #56 - A #550[1][1] #328 * A #551[2][3] #91 + A #552[1][3] #329 * A #553[2][1];
        C3210= A #554[0][1] #330 * A #555[2][3] #57 - A #556[0][3] #331 * A #557[2][1];
        C3220=
          #57 - A #558[0][1] #332 * A #559[1][3] #92 + A #560[0][3] #333 * A #561[1][1];
        C33=
          A #562[0][0] #334 * C3300 #93 + A #563[1][0] #335 * C3310 #93 +
          A #564[2][0] #336 * C3320;
        C3300= A #565[1][1] #337 * A #566[2][2] #58 - A #567[1][2] #338 * A #568[2][1];
        C3310=
          #58 - A #569[0][1] #339 * A #570[2][2] #94 + A #571[0][2] #340 * A #572[2][1];
        C3320= A #573[0][1] #341 * A #574[1][2] #59 - A #575[0][2] #342 * A #576[1][1];
      tel
    returns ..;
    Det= _L1;
    _L2= A;
    _L1= #1 Det4x4(_L2, false);
    _= MTC_AC_Outputs;
  tel

  function Inv3x3(A : 'T^3^3; Epsilon : 'T; MTC_AC_Outputs : bool)
    returns (InvA : 'T^3^3; Error : bool)
    where 'T float
  var
    Det : 'T;
    _L8 : bool;
    _L7 : 'T;
    _L6 : 'T;
    _L5 : 'T^3^3;
    _L4 : 'T;
  let
    _L8= _L6 #1 <= _L7;
    _L7= Epsilon;
    assume A1 : Epsilon #1 >= 0.0;
    _L6= #1 if Det #2 < 0.0 then (#8 - Det) else (Det);
    Error= _L8;
    activate IfBlock1 if Error
      then let
        InvA= ((0.0)#6^3)#5^3;
      tel
      else var
        C00 : 'T;
        C01 : 'T;
        C02 : 'T;
        C10 : 'T;
        C11 : 'T;
        C12 : 'T;
        C20 : 'T;
        C21 : 'T;
        C22 : 'T;
      let
        InvA=
          #25[#26[C00 #45 / Det, C10 #46 / Det, C20 #47 / Det], #27[C01 #48 /
              Det, C11 #49 / Det, C21 #50 / Det], #28[C02 #51 / Det, C12 #52 /
              Det, C22 #53 / Det]];
        C00= A #197[1][1] #91 * A #198[2][2] #26 - A #199[1][2] #92 * A #200[2][1];
        C01=
          #29 - A #201[1][0] #93 * A #202[2][2] #21 + A #203[1][2] #94 * A #204[2][0];
        C02= A #205[1][0] #95 * A #206[2][1] #27 - A #207[1][1] #96 * A #208[2][0];
        C10=
          #30 - A #209[0][1] #97 * A #210[2][2] #22 + A #211[0][2] #98 * A #212[2][1];
        C11= A #213[0][0] #99 * A #214[2][2] #28 - A #215[0][2] #100 * A #216[2][0];
        C12=
          #31 - A #217[0][0] #101 * A #218[2][1] #23 + A #219[2][0] #102 * A #220[0][1];
        C20= A #221[0][1] #103 * A #222[1][2] #29 - A #223[0][2] #104 * A #224[1][1];
        C21=
          #32 - A #225[0][0] #105 * A #226[1][2] #24 + A #227[0][2] #106 * A #228[1][0];
        C22= A #229[0][0] #107 * A #230[1][1] #30 - A #231[0][1] #108 * A #232[1][0];
      tel
    returns ..;
    Det= _L4;
    _L5= A;
    _L4= #1 Det3x3(_L5, false);
    _= MTC_AC_Outputs;
  tel

  function Inv2x2(A : 'T^2^2; Epsilon : 'T; MTC_AC_Outputs : bool)
    returns (InvA : 'T^2^2; Error : bool)
    where 'T float
  var
    Det : 'T;
    _L1 : 'T;
    _L2 : 'T^2^2;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : bool;
  let
    _L1= #1 Det2x2(_L2, false);
    _L2= A;
    Det= _L1;
    activate IfBlock1 if Error
      then let
        InvA= ((0.0)#6^2)#5^2;
      tel
      else let
        InvA=
          #22[#23[A #29[1][1] #20 / Det, #17 - A #30[0][1] #21 / Det], #24[#18
              - A #31[1][0] #22 /
              Det, A #32[0][0] #23 / Det]];
      tel
    returns ..;
    Error= _L5;
    _L3= #1 if Det #2 < 0.0 then (#8 - Det) else (Det);
    assume A1 : Epsilon #1 >= 0.0;
    _L4= Epsilon;
    _L5= _L3 #1 <= _L4;
    _= MTC_AC_Outputs;
  tel

  function Det4x4(A : 'T^4^4; MTC_AC_Outputs : bool)
    returns (Det : 'T)
    where 'T numeric
  var
    C00 : 'T;
    C01 : 'T;
    C02 : 'T;
    C03 : 'T;
    C0330 : 'T;
    C0320 : 'T;
    C0310 : 'T;
    C0230 : 'T;
    C0220 : 'T;
    C0210 : 'T;
    C0130 : 'T;
    C0120 : 'T;
    C0110 : 'T;
    C0031 : 'T;
    C0021 : 'T;
    C0011 : 'T;
  let
    Det=
      A #0[0][0] #0 * C00 #12 + A #2[0][1] #3 * C01 #12 + A #4[0][2] #5 * C02
      #12 +
      A #6[0][3] #7 * C03;
    C00=
      A #8[1][1] #115 * C0011 #13 + A #11[2][1] #12 * C0021 #13 +
      A #13[3][1] #14 * C0031;
    C0011= A #15[2][2] #9 * A #16[3][3] #23 - A #17[2][3] #18 * A #117[3][2];
    C0021=
      #13 - A #116[1][2] #20 * A #21[3][3] #115 + A #25[1][3] #24 * A #26[3][2];
    C0031= A #27[1][2] #28 * A #29[2][3] #30 - A #31[1][3] #32 * A #33[2][2];
    C01=
      A #34[1][0] #35 * C0110 #14 + A #37[2][0] #38 * C0120 #14 +
      A #39[3][0] #40 * C0130;
    C0110= #14 - A #41[2][2] #42 * A #43[3][3] #118 + A #45[2][3] #46 * A #3[3][2];
    C0120= A #47[1][2] #48 * A #49[3][3] #50 - A #51[1][3] #52 * A #53[3][2];
    C0130= #15 - A #54[1][2] #55 * A #56[2][3] #57 + A #58[1][3] #59 * A #60[2][2];
    C02=
      A #61[1][0] #62 * C0210 #15 + A #64[2][0] #65 * C0220 #15 +
      A #66[3][0] #67 * C0230;
    C0210= A #68[2][1] #69 * A #70[3][3] #71 - A #72[2][3] #73 * A #74[3][1];
    C0220= #16 - A #75[1][1] #76 * A #77[3][3] #78 + A #79[1][3] #80 * A #81[3][1];
    C0230= A #82[1][1] #83 * A #84[2][3] #85 - A #86[1][3] #87 * A #88[2][1];
    C03=
      A #89[1][0] #90 * C0310 #16 + A #92[2][0] #93 * C0320 #16 +
      A #94[3][0] #95 * C0330;
    C0310= #17 - A #96[2][1] #97 * A #18[3][2] #98 + A #99[2][2] #100 * A #19[3][1];
    C0320= A #101[1][1] #102 * A #103[3][2] #104 - A #105[1][2] #106 * A #107[3][1];
    C0330=
      #18 - A #108[1][1] #109 * A #110[2][2] #111 + A #112[1][2] #113 * A #114[2][1];
    _= MTC_AC_Outputs;
  tel

  function Det3x3(A : 'T^3^3; MTC_AC_Outputs : bool)
    returns (Det : 'T)
    where 'T numeric
  var
    C00 : 'T;
    C01 : 'T;
    C02 : 'T;
  let
    Det= A #0[0][0] #1 * C00 #3 + A #3[0][1] #4 * C01 #3 + A #6[0][2] #7 * C02;
    C00= A #8[1][1] #9 * A #1[2][2] #10 - A #11[1][2] #12 * A #2[2][1];
    C01= #1 - A #13[1][0] #14 * A #15[2][2] #16 + A #17[1][2] #18 * A #19[2][0];
    C02= A #20[1][0] #21 * A #22[2][1] #23 - A #25[1][1] #26 * A #27[2][0];
    _= MTC_AC_Outputs;
  tel

  function Det2x2(A : 'T^2^2; MTC_AC_Outputs : bool)
    returns (Det : 'T)
    where 'T numeric
  let
    Det= A #0[0][0] #1 * A #2[1][1] #3 - A #4[0][1] #5 * A #6[1][0];
    _= MTC_AC_Outputs;
  tel

  function MatSub<<m, n>>(A : 'T^n^m; B : 'T^n^m; MTC_AC_Outputs : bool)
    returns (C : 'T^n^m)
    where 'T numeric
  var
    _L3 : 'T^n^m;
    _L2 : 'T^n^m;
    _L1 : 'T^n^m;
  let
    _L1= ( map (#1 VectSub <<n>>) <<m>>)(_L3, _L2, (false)^m);
    _L2= B;
    _L3= A;
    C= _L1;
    _= MTC_AC_Outputs;
  tel

  function VectSub<<n>>(U : 'T^n; V : 'T^n; MTC_AC_Outputs : bool)
    returns (W : 'T^n)
    where 'T numeric
  var
    _L3 : 'T^n;
    _L2 : 'T^n;
    _L1 : 'T^n;
  let
    _L1= ( map #1 $-$ <<n>>)(_L3, _L2);
    _L2= V;
    W= _L1;
    _L3= U;
    _= MTC_AC_Outputs;
  tel

  function VectAdd<<n>>(U : 'T^n; V : 'T^n; MTC_AC_Outputs : bool)
    returns (W : 'T^n)
    where 'T numeric
  var
    _L1 : 'T^n;
    _L2 : 'T^n;
    _L3 : 'T^n;
  let
    _L1= ( map #1 $+$ <<n>>)(_L2, _L3);
    _L2= U;
    _L3= V;
    W= _L1;
    _= MTC_AC_Outputs;
  tel

  function BuildArray<<N>>(
      StartValue : 'T;
      Increment : 'T;
      MTC_AC_Outputs : bool)
    returns (Output : 'T^N)
    where 'T numeric
  var
    _L2 : 'T^N;
    _L1 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : 'T^N;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1, _L2=
      ( mapfold 1 #1 MTCEx::MTC_Instrumenters::vect_SumDup_MTC_INST <<N>>)(_L9,
        _L5, (false)^N, (false)^N);
    _L3= StartValue;
    _L4= Increment;
    Output= _L2;
    _= _L1;
    _L5= (_L4)#1^N;
    _L8= (Increment #2 : 'T);
    _L9= _L3 #1 - _L8;
    _= MTC_AC_Outputs;
  tel

  function #pragma kcg expand #end SumDup(
      a : 'T;
      b : 'T;
      MTC_AC_s1 : bool;
      MTC_AC_s2 : bool)
    returns (
      s1 : 'T;
      s2 : 'T;
      MTC_AC_a : bool default = false;
      MTC_AC_b : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
  let
    _L1= a;
    _L2= b;
    _L3= _L1 #1 + _L2;
    s1= _L3;
    s2= _L3;
    _= MTC_AC_s1;
    _= MTC_AC_s2;
    MTC_AC_a= false;
    MTC_AC_b= false;
  tel

  function #pragma kcg expand #end SelectorHelper<<DstSize>>(
      Input : 'T^DstSize;
      Index : 'I;
      Default : 'T;
      MTC_AC_Output : bool)
    returns (
      Output : 'T;
      MTC_AC_Input : bool default = false;
      MTC_AC_Index : bool default = false;
      MTC_AC_Default : bool default = false)
    where 'I integer
  var
    _L1 : 'T;
    _L2 : 'T^DstSize;
    _L3 : 'I;
    _L4 : 'T;
  let
    _L1= (_L2#1 . [_L3] default _L4);
    _L2= Input;
    _L3= Index;
    _L4= Default;
    Output= _L1;
    _= MTC_AC_Output;
    MTC_AC_Input= false;
    MTC_AC_Index= false;
    MTC_AC_Default= false;
  tel

  function Selector<<SrcSize, DstSize>>(
      Input : 'T^SrcSize;
      Indices : 'I^DstSize;
      Default : 'T;
      MTC_AC_Outputs : bool)
    returns (Output : 'T^DstSize)
    where 'I integer
  var
    _L1 : 'T^DstSize;
    _L2 : 'T^SrcSize;
    _L3 : 'I^DstSize;
    _L4 : 'T;
    _L5 : 'T^SrcSize^DstSize;
    _L6 : 'T^DstSize;
  let
    _L1=
      ( map
        (#1 MTCEx::MTC_Instrumenters::vect_SelectorHelper_MTC_INST <<SrcSize>>)
        <<DstSize>>)(_L5, _L3, _L6, (false)^DstSize, (false)^DstSize);
    _L2= Input;
    _L3= Indices;
    _L4= Default;
    Output= _L1;
    _L5= (_L2)#1^DstSize;
    _L6= (_L4)#2^DstSize;
    _= MTC_AC_Outputs;
  tel

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/libmath_MTC_INST/math.xscade */
package math
  node #pragma kcg expand #end Abs(
      A_Input : 'T;
      MTC_AC_A_Output : bool;
      MTC_INSTRU : bool)
    returns (A_Output : 'T; MTC_AC_A_Input : bool default = false)
    where 'T numeric
  sig
    MTC_sig_1;
  var
    MTC_AC_1 : bool;
    MTC_AC_2 : bool;
    MTC_AC_3 : bool;
    MTC_AC_4 : bool;
    MTC_AC_5 : bool;
    MTC_CC_1_T : bool;
    MTC_CC_2_F : bool;
    MTC_CC_3_A : bool;
    MTC_CC_4_A : bool;
    _L1 : bool;
    _L2 : 'T;
    _L3 : 'T;
    _L5 : 'T;
    _L8 : 'T;
  let
    _L1= _L8 #1 <= _L5;
    _L2= #2 if _L1 then (_L5) else (_L3);
    _L3= #5 - _L5;
    _L5= A_Input;
    A_Output= _L2;
    _L8= (0 #1 : 'T);
    MTC_AC_1= MTC_AC_A_Output;
    MTC_AC_2= _L1;
    MTC_AC_3= #1 not _L1;
    emit 'MTC_sig_1 if MTC_AC_1;
    MTC_AC_4= MTC_AC_2 #1 and MTC_AC_1;
    emit 'MTC_sig_1 if MTC_AC_4;
    MTC_AC_5= MTC_AC_3 #2 and MTC_AC_1;
    emit 'MTC_sig_1 if MTC_AC_5;
    MTC_CC_1_T= _L1 #3 and MTC_AC_1;
    MTC_CC_2_F= #2 not _L1 #4 and MTC_AC_1;
    MTC_CC_3_A= MTC_AC_4;
    MTC_CC_4_A= MTC_AC_5;
    ()=
      #1 MTCEx::MTC_Observers::math_Abs_PATHS1_MTC_OBS(MTC_CC_3_A, MTC_CC_4_A,
        MTC_CC_1_T, MTC_CC_2_F, MTC_INSTRU);
    MTC_AC_A_Input= 'MTC_sig_1;
  tel

  function #pragma kcg expand #end BoolToInt16(
      BTI_Input : bool;
      MTC_AC_BTI_Output : bool)
    returns (BTI_Output : int16; MTC_AC_BTI_Input : bool default = false)
  var
    _L1 : bool;
    _L2 : int16;
    _L3 : int16;
    _L4 : int16;
  let
    _L1= BTI_Input;
    BTI_Output= _L2;
    _L2= #1 if _L1 then (_L3) else (_L4);
    _L3= (1 #1 : int16);
    _L4= (0 #2 : int16);
    _= MTC_AC_BTI_Output;
    MTC_AC_BTI_Input= false;
  tel

  function #pragma kcg expand #end BoolToFloat32(
      BTR_Input : bool;
      MTC_AC_BTR_Output : bool)
    returns (BTR_Output : float32; MTC_AC_BTR_Input : bool default = false)
  var
    _L10 : float32;
    _L5 : bool;
    _L6 : float32;
    _L9 : float32;
  let
    _L5= BTR_Input;
    BTR_Output= _L6;
    _L6= #1 if _L5 then (_L10) else (_L9);
    _L9= (0.0 #2 : float32);
    _L10= (1.0 #1 : float32);
    _= MTC_AC_BTR_Output;
    MTC_AC_BTR_Input= false;
  tel

  function #pragma kcg expand #end InRangeInIn(
      IRII_Input : 'T;
      A : 'T;
      B : 'T;
      MTC_AC_IRII_Output : bool)
    returns (
      IRII_Output : bool;
      MTC_AC_IRII_Input : bool default = false;
      MTC_AC_A : bool default = false;
      MTC_AC_B : bool default = false)
    where 'T numeric
  var
    _L10 : 'T;
    _L12 : bool;
    _L13 : 'T;
    _L2 : bool;
    _L4 : bool;
    _L8 : 'T;
  let
    _L2= _L12 #1 and _L4;
    _L4= _L8 #2 >= _L10;
    _L8= IRII_Input;
    IRII_Output= _L2;
    _L10= A;
    _L12= _L13 #3 >= _L8;
    _L13= B;
    assume A1 : A #1 <= B;
    _= MTC_AC_IRII_Output;
    MTC_AC_IRII_Input= false;
    MTC_AC_A= false;
    MTC_AC_B= false;
  tel

  function #pragma kcg expand #end InRangeInOut(
      IRIO_Input : 'T;
      A : 'T;
      B : 'T;
      MTC_AC_IRIO_Output : bool)
    returns (
      IRIO_Output : bool;
      MTC_AC_IRIO_Input : bool default = false;
      MTC_AC_A : bool default = false;
      MTC_AC_B : bool default = false)
    where 'T numeric
  var
    _L3 : 'T;
    _L14 : bool;
    _L13 : 'T;
    _L12 : 'T;
    _L10 : bool;
    _L17 : bool;
  let
    _L3= IRIO_Input;
    _L14= _L3 #1 >= _L12;
    _L13= B;
    _L12= A;
    _L10= _L17 #2 and _L14;
    IRIO_Output= _L10;
    _L17= _L13 #3 > _L3;
    assume A1 : A #1 <= B;
    _= MTC_AC_IRIO_Output;
    MTC_AC_IRIO_Input= false;
    MTC_AC_A= false;
    MTC_AC_B= false;
  tel

  function #pragma kcg expand #end InRangeOutIn(
      IROI_Input : 'T;
      A : 'T;
      B : 'T;
      MTC_AC_IROI_Output : bool)
    returns (
      IROI_Output : bool;
      MTC_AC_IROI_Input : bool default = false;
      MTC_AC_A : bool default = false;
      MTC_AC_B : bool default = false)
    where 'T numeric
  var
    _L3 : 'T;
    _L7 : bool;
    _L29 : bool;
    _L24 : 'T;
    _L23 : 'T;
    _L30 : bool;
  let
    _L3= IROI_Input;
    IROI_Output= _L29;
    _L7= _L3 #1 > _L23;
    _L29= _L30 #2 and _L7;
    _L24= B;
    _L23= A;
    _L30= _L24 #3 >= _L3;
    assume A1 : A #1 <= B;
    _= MTC_AC_IROI_Output;
    MTC_AC_IROI_Input= false;
    MTC_AC_A= false;
    MTC_AC_B= false;
  tel

  function #pragma kcg expand #end InRangeOutOut(
      IROO_Input : 'T;
      A : 'T;
      B : 'T;
      MTC_AC_IROO_Output : bool)
    returns (
      IROO_Output : bool;
      MTC_AC_IROO_Input : bool default = false;
      MTC_AC_A : bool default = false;
      MTC_AC_B : bool default = false)
    where 'T numeric
  var
    _L3 : 'T;
    _L29 : bool;
    _L28 : bool;
    _L24 : 'T;
    _L23 : 'T;
    _L30 : bool;
  let
    _L3= IROO_Input;
    IROO_Output= _L29;
    _L29= _L28 #1 and _L30;
    _L28= _L24 #2 > _L3;
    _L24= B;
    _L23= A;
    _L30= _L3 #3 > _L23;
    assume A1 : A #1 <= B;
    _= MTC_AC_IROO_Output;
    MTC_AC_IROO_Input= false;
    MTC_AC_A= false;
    MTC_AC_B= false;
  tel

  function #pragma kcg expand #end Max(
      I1 : 'T;
      I2 : 'T;
      MTC_AC_Ma_Output : bool)
    returns (
      Ma_Output : 'T;
      MTC_AC_I1 : bool default = false;
      MTC_AC_I2 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : bool;
    _L4 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= _L1 #1 >= _L2;
    _L4= #2 if _L3 then (_L1) else (_L2);
    Ma_Output= _L4;
    _= MTC_AC_Ma_Output;
    MTC_AC_I1= false;
    MTC_AC_I2= false;
  tel

  function Max3(I1 : 'T; I2 : 'T; I3 : 'T; MTC_AC_Outputs : bool)
    returns (Ma3_Output : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : bool;
    _L5 : bool;
    _L6 : bool;
    _L7 : bool;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= I3;
    _L4= _L1 #1 >= _L2;
    _L5= _L1 #2 >= _L3;
    _L6= _L2 #3 >= _L3;
    _L7= _L4 #4 and _L5;
    _L8= #5 if _L7 then (_L1) else (_L9);
    _L9= #8 if _L6 then (_L2) else (_L3);
    Ma3_Output= _L8;
    _= MTC_AC_Outputs;
  tel

  function #pragma kcg expand #end Mean3(
      I1 : 'T;
      I2 : 'T;
      I3 : 'T;
      MTC_AC_Me3_Output : bool;
      MTC_INSTRU : bool)
    returns (
      Me3_Output : 'T;
      MTC_AC_I1 : bool default = false;
      MTC_AC_I2 : bool default = false;
      MTC_AC_I3 : bool default = false)
    where 'T numeric
  sig
    MTC_sig_1, MTC_sig_2, MTC_sig_3;
  var
    MTC_AC_1 : bool;
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : 'T;
    _L7 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= I3;
    _L4= _L1 #1 + _L2 #1 + _L3;
    _L5= _L4 #2 / _L7;
    Me3_Output= _L5;
    _L7= (3 #1 : 'T);
    MTC_AC_1= MTC_AC_Me3_Output;
    emit 'MTC_sig_1 if MTC_AC_1;
    emit 'MTC_sig_2 if MTC_AC_1;
    emit 'MTC_sig_3 if MTC_AC_1;
    MTC_AC_I1= 'MTC_sig_1;
    MTC_AC_I2= 'MTC_sig_2;
    MTC_AC_I3= 'MTC_sig_3;
    _= MTC_INSTRU;
  tel

  function #pragma kcg expand #end Min(
      I1 : 'T;
      I2 : 'T;
      MTC_AC_Mi_Output : bool)
    returns (
      Mi_Output : 'T;
      MTC_AC_I1 : bool default = false;
      MTC_AC_I2 : bool default = false)
    where 'T numeric
  var
    _L21 : 'T;
    _L22 : 'T;
    _L24 : 'T;
    _L25 : bool;
  let
    _L21= I1;
    _L22= I2;
    _L24= #1 if _L25 then (_L21) else (_L22);
    _L25= _L21 #4 <= _L22;
    Mi_Output= _L24;
    _= MTC_AC_Mi_Output;
    MTC_AC_I1= false;
    MTC_AC_I2= false;
  tel

  function Min3(I1 : 'T; I2 : 'T; I3 : 'T; MTC_AC_Outputs : bool)
    returns (Mi3_Output : 'T)
    where 'T numeric
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L7 : bool;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= _L4 #1 <= _L5;
    _L2= _L4 #2 <= _L6;
    _L3= _L5 #3 <= _L6;
    _L4= I1;
    _L5= I2;
    _L6= I3;
    _L7= _L1 #4 and _L2;
    _L8= #5 if _L7 then (_L4) else (_L9);
    _L9= #8 if _L3 then (_L5) else (_L6);
    Mi3_Output= _L8;
    _= MTC_AC_Outputs;
  tel

  function Sign(S_Input : 'T; MTC_AC_Outputs : bool)
    returns (S_Ouput : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L15 : 'T;
    _L16 : 'T;
    _L4 : bool;
    _L5 : bool;
    _L7 : 'T;
    _L8 : 'T;
    _L20 : 'T;
    _L21 : 'T;
  let
    _L1= S_Input;
    _L4= _L1 #1 > _L15;
    _L5= _L15 #2 = _L1;
    S_Ouput= _L7;
    _L7= #3 if _L4 then (_L16) else (_L8);
    _L8= #6 if _L5 then (_L21) else (_L20);
    _L15= (0 #3 : 'T);
    _L16= (1 #4 : 'T);
    _L20= #1 - (1 #1 : 'T);
    _L21= (0 #2 : 'T);
    _= MTC_AC_Outputs;
  tel

  function #pragma kcg expand #end Mean(
      I1 : 'T;
      I2 : 'T;
      MTC_AC_Me_output : bool;
      MTC_INSTRU : bool)
    returns (
      Me_output : 'T;
      MTC_AC_I1 : bool default = false;
      MTC_AC_I2 : bool default = false)
    where 'T numeric
  sig
    MTC_sig_1, MTC_sig_2;
  var
    MTC_AC_1 : bool;
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L6 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= _L4 #1 / _L6;
    _L4= _L1 #2 + _L2;
    Me_output= _L3;
    _L6= (2 #1 : 'T);
    MTC_AC_1= MTC_AC_Me_output;
    emit 'MTC_sig_1 if MTC_AC_1;
    emit 'MTC_sig_2 if MTC_AC_1;
    MTC_AC_I1= 'MTC_sig_1;
    MTC_AC_I2= 'MTC_sig_2;
    _= MTC_INSTRU;
  tel

  function Round(R_Input : 'T; MTC_AC_Outputs : bool)
    returns (R_Output : int32)
    where 'T float
  var
    _L2 : bool;
    _L4 : 'T;
    _L5 : 'T;
    _L7 : 'T;
    _L8 : int32;
    _L9 : 'T;
    _L10 : int32;
    _L12 : 'T;
    _L17 : 'T;
    _L22 : 'T;
    _L21 : 'T;
    _L20 : 'T;
    _L19 : 'T;
    _L18 : bool;
    _L25 : 'T;
    _L26 : 'T;
    _L27 : bool;
    _L34 : 'T;
  let
    _L2= _L12 #1 >= _L17;
    _L4= #2 if _L2 then (_L5) else (_L34);
    _L5= _L34 #5 + _L7;
    _L7= (1.0 #19 : 'T);
    _L8= (_L25 #6 : int32);
    R_Output= _L8;
    _L9= R_Input;
    _L10= (_L9 #7 : int32);
    _L12= _L9 #8 - _L34;
    _L17= (0.5 #20 : 'T);
    _L22= _L34 #9 - _L21;
    _L21= (1.0 #21 : 'T);
    _L20= (- 0.5 #22 : 'T);
    _L19= #10 if _L18 then (_L22) else (_L34);
    _L18= _L12 #13 <= _L20;
    _L25= #14 if _L27 then (_L19) else (_L4);
    _L26= (0.0 #23 : 'T);
    _L27= _L12 #17 < _L26;
    _L34= (_L10 #18 : 'T);
    _= MTC_AC_Outputs;
  tel

  function ByteToUint8(
      b1 : bool;
      b2 : bool;
      b3 : bool;
      b4 : bool;
      b5 : bool;
      b6 : bool;
      b7 : bool;
      b8 : bool;
      MTC_AC_Outputs : bool)
    returns (OTI_Output : uint8)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : uint8;
    _L6 : uint8;
    _L7 : uint8;
    _L10 : uint8;
    _L9 : uint8;
    _L8 : uint8;
    _L13 : uint8;
    _L12 : uint8;
    _L11 : uint8;
    _L16 : uint8;
    _L15 : uint8;
    _L14 : uint8;
    _L17 : uint8;
    _L18 : uint8;
    _L19 : uint8;
    _L23 : uint8;
    _L22 : uint8;
    _L21 : uint8;
    _L20 : uint8;
    _L31 : uint8;
    _L30 : uint8;
    _L29 : uint8;
    _L28 : uint8;
    _L32 : uint8;
    _L33 : bool;
    _L34 : bool;
    _L35 : bool;
    _L36 : bool;
    _L40 : uint8;
    _L39 : uint8;
    _L38 : uint8;
    _L37 : uint8;
    _L43 : uint8;
    _L42 : uint8;
    _L41 : uint8;
  let
    _L1= b1;
    _L2= b2;
    _L3= b3;
    _L4= b4;
    _L5= #1 if _L1 then (_L6) else (_L7);
    _L6= (1 #1 : uint8);
    _L7= (0 #2 : uint8);
    _L10= (2 #3 : uint8);
    _L9= (0 #4 : uint8);
    _L8= #4 if _L2 then (_L10) else (_L9);
    _L13= (4 #5 : uint8);
    _L12= (0 #6 : uint8);
    _L11= #7 if _L3 then (_L13) else (_L12);
    _L16= (8 #7 : uint8);
    _L15= (0 #8 : uint8);
    _L14= #10 if _L4 then (_L16) else (_L15);
    _L17= _L11 #13 + _L32;
    _L18= _L8 #14 + _L17;
    _L19= _L5 #15 + _L18;
    OTI_Output= _L19;
    _L23= (0 #10 : uint8);
    _L22= (16 #9 : uint8);
    _L21= _L20 #16 + _L29;
    _L20= #17 if _L33 then (_L22) else (_L23);
    _L31= (0 #12 : uint8);
    _L30= (32 #11 : uint8);
    _L29= _L28 #20 + _L40;
    _L28= #21 if _L34 then (_L30) else (_L31);
    _L32= _L14 #24 + _L21;
    _L33= b5;
    _L34= b6;
    _L35= b7;
    _L36= b8;
    _L40= _L37 #25 + _L43;
    _L39= (64 #13 : uint8);
    _L38= (0 #14 : uint8);
    _L37= #26 if _L35 then (_L39) else (_L38);
    _L43= #29 if _L36 then (_L42) else (_L41);
    _L42= (128 #15 : uint8);
    _L41= (0 #17 : uint8);
    _= MTC_AC_Outputs;
  tel

  function RoundCeil(RC_Input : 'T; MTC_AC_Outputs : bool)
    returns (RC_Output : int32)
    where 'T float
  var
    _L1 : 'T;
    _L2 : bool;
    _L3 : 'T;
    _L4 : int32;
    _L6 : int32;
    _L7 : 'T;
    _L9 : int32;
    _L10 : 'T;
    _L11 : int32;
    _L12 : 'T;
    _L14 : bool;
  let
    _L1= RC_Input;
    _L2= _L1 #1 <= _L3;
    _L3= (0.0 #13 : 'T);
    _L4= #2 if _L2 then (_L6) else (_L9);
    _L6= (_L1 #5 : int32);
    _L7= (_L6 #6 : 'T);
    _L9= #7 if _L14 then (_L6) else (_L11);
    _L10= _L1 #10 + _L12;
    _L11= (_L10 #11 : int32);
    _L12= (1.0 #12 : 'T);
    RC_Output= _L4;
    _L14= _L7 #12 = _L1;
    _= MTC_AC_Outputs;
  tel

  function RoundFloor(RF_Input : 'T; MTC_AC_Outputs : bool)
    returns (RF_Output : int32)
    where 'T numeric
  var
    _L1 : 'T;
    _L24 : bool;
    _L25 : 'T;
    _L26 : int32;
    _L30 : 'T;
    _L31 : 'T;
    _L32 : int32;
    _L33 : int32;
    _L38 : int32;
    _L41 : 'T;
    _L43 : bool;
  let
    _L1= RF_Input;
    RF_Output= _L26;
    _L24= _L1 #1 >= _L25;
    _L25= (0 #15 : 'T);
    _L26= #2 if _L24 then (_L33) else (_L38);
    _L30= _L1 #5 - _L31;
    _L31= (1 #14 : 'T);
    _L32= (_L30 #6 : int32);
    _L33= (_L1 #7 : int32);
    _L38= #8 if _L43 then (_L33) else (_L32);
    _L41= (_L33 #11 : 'T);
    _L43= _L41 #12 = _L1;
    _= MTC_AC_Outputs;
  tel

  function #pragma kcg expand #end IntToBool(
      ITB_Input : 'T;
      MTC_AC_ITB_Output : bool)
    returns (ITB_Output : bool; MTC_AC_ITB_Input : bool default = false)
    where 'T integer
  var
    _L1 : 'T;
    _L2 : bool;
    _L3 : 'T;
  let
    _L1= ITB_Input;
    _L2= _L1 #1 <> _L3;
    ITB_Output= _L2;
    _L3= (0 #1 : 'T);
    _= MTC_AC_ITB_Output;
    MTC_AC_ITB_Input= false;
  tel

  function #pragma kcg expand #end RealToBool(
      RTB_Input : 'T;
      MTC_AC_RTB_Output : bool)
    returns (RTB_Output : bool; MTC_AC_RTB_Input : bool default = false)
    where 'T float
  var
    _L3 : bool;
    _L2 : 'T;
    _L1 : 'T;
  let
    _L3= _L2 #1 <> _L1;
    _L2= RTB_Input;
    _L1= (0.0 #1 : 'T);
    RTB_Output= _L3;
    _= MTC_AC_RTB_Output;
    MTC_AC_RTB_Input= false;
  tel

  function #pragma kcg expand #end BoolToInt32(
      BTI_Input : bool;
      MTC_AC_BTI_Output : bool)
    returns (BTI_Output : int32; MTC_AC_BTI_Input : bool default = false)
  var
    _L1 : bool;
    _L2 : int32;
    _L3 : int32;
    _L4 : int32;
  let
    _L1= BTI_Input;
    BTI_Output= _L2;
    _L2= #1 if _L1 then (_L3) else (_L4);
    _L3= (1 #1 : int32);
    _L4= (0 #2 : int32);
    _= MTC_AC_BTI_Output;
    MTC_AC_BTI_Input= false;
  tel

  function #pragma kcg expand #end BoolToUint8(
      BTI_Input : bool;
      MTC_AC_BTI_Output : bool)
    returns (BTI_Output : uint8; MTC_AC_BTI_Input : bool default = false)
  var
    _L1 : bool;
    _L2 : uint8;
    _L3 : uint8;
    _L4 : uint8;
  let
    _L1= BTI_Input;
    BTI_Output= _L2;
    _L2= #1 if _L1 then (_L3) else (_L4);
    _L3= (1 #3 : uint8);
    _L4= (0 #4 : uint8);
    _= MTC_AC_BTI_Output;
    MTC_AC_BTI_Input= false;
  tel

  function #pragma kcg expand #end BoolToInt64(
      BTI_Input : bool;
      MTC_AC_BTI_Output : bool)
    returns (BTI_Output : int64; MTC_AC_BTI_Input : bool default = false)
  var
    _L1 : bool;
    _L2 : int64;
    _L3 : int64;
    _L4 : int64;
  let
    _L1= BTI_Input;
    BTI_Output= _L2;
    _L2= #1 if _L1 then (_L3) else (_L4);
    _L3= (1 #1 : int64);
    _L4= (0 #2 : int64);
    _= MTC_AC_BTI_Output;
    MTC_AC_BTI_Input= false;
  tel

  function #pragma kcg expand #end BoolToInt8(
      BTI_Input : bool;
      MTC_AC_BTI_Output : bool)
    returns (BTI_Output : int8; MTC_AC_BTI_Input : bool default = false)
  var
    _L1 : bool;
    _L2 : int8;
    _L3 : int8;
    _L4 : int8;
  let
    _L1= BTI_Input;
    BTI_Output= _L2;
    _L2= #1 if _L1 then (_L3) else (_L4);
    _L3= (1 #1 : int8);
    _L4= (0 #2 : int8);
    _= MTC_AC_BTI_Output;
    MTC_AC_BTI_Input= false;
  tel

  function #pragma kcg expand #end BoolToUint64(
      BTI_Input : bool;
      MTC_AC_BTI_Output : bool)
    returns (BTI_Output : uint64; MTC_AC_BTI_Input : bool default = false)
  var
    _L1 : bool;
    _L2 : uint64;
    _L3 : uint64;
    _L4 : uint64;
  let
    _L1= BTI_Input;
    BTI_Output= _L2;
    _L2= #1 if _L1 then (_L3) else (_L4);
    _L3= (1 #4 : uint64);
    _L4= (0 #3 : uint64);
    _= MTC_AC_BTI_Output;
    MTC_AC_BTI_Input= false;
  tel

  function #pragma kcg expand #end BoolToUint16(
      BTI_Input : bool;
      MTC_AC_BTI_Output : bool)
    returns (BTI_Output : uint16; MTC_AC_BTI_Input : bool default = false)
  var
    _L1 : bool;
    _L2 : uint16;
    _L3 : uint16;
    _L4 : uint16;
  let
    _L1= BTI_Input;
    BTI_Output= _L2;
    _L2= #1 if _L1 then (_L3) else (_L4);
    _L3= (1 #1 : uint16);
    _L4= (0 #2 : uint16);
    _= MTC_AC_BTI_Output;
    MTC_AC_BTI_Input= false;
  tel

  function #pragma kcg expand #end BoolToUint32(
      BTI_Input : bool;
      MTC_AC_BTI_Output : bool)
    returns (BTI_Output : uint32; MTC_AC_BTI_Input : bool default = false)
  var
    _L1 : bool;
    _L2 : uint32;
    _L3 : uint32;
    _L4 : uint32;
  let
    _L1= BTI_Input;
    BTI_Output= _L2;
    _L2= #1 if _L1 then (_L3) else (_L4);
    _L3= (1 #1 : uint32);
    _L4= (0 #2 : uint32);
    _= MTC_AC_BTI_Output;
    MTC_AC_BTI_Input= false;
  tel

  function #pragma kcg expand #end BoolToFloat64(
      BTR_Input : bool;
      MTC_AC_BTR_Output : bool)
    returns (BTR_Output : float64; MTC_AC_BTR_Input : bool default = false)
  var
    _L10 : float64;
    _L5 : bool;
    _L6 : float64;
    _L9 : float64;
  let
    _L5= BTR_Input;
    BTR_Output= _L6;
    _L6= #1 if _L5 then (_L10) else (_L9);
    _L9= (0.0 #2 : float64);
    _L10= (1.0 #1 : float64);
    _= MTC_AC_BTR_Output;
    MTC_AC_BTR_Input= false;
  tel

  function #pragma kcg expand #end NumericToUint8(
      Input1 : 'T;
      MTC_AC_Output1 : bool)
    returns (Output1 : uint8; MTC_AC_Input1 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : uint8;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L1 #1 : uint8);
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end NumericToInt8(
      Input1 : 'T;
      MTC_AC_Output1 : bool)
    returns (Output1 : int8; MTC_AC_Input1 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : int8;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L1 #1 : int8);
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end NumericToInt16(
      Input1 : 'T;
      MTC_AC_Output1 : bool)
    returns (Output1 : int16; MTC_AC_Input1 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : int16;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L1 #1 : int16);
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end NumericToInt32(
      Input1 : 'T;
      MTC_AC_Output1 : bool)
    returns (Output1 : int32; MTC_AC_Input1 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : int32;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L1 #1 : int32);
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end NumericToInt64(
      Input1 : 'T;
      MTC_AC_Output1 : bool)
    returns (Output1 : int64; MTC_AC_Input1 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : int64;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L1 #1 : int64);
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end NumericToUint16(
      Input1 : 'T;
      MTC_AC_Output1 : bool)
    returns (Output1 : uint16; MTC_AC_Input1 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : uint16;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L1 #1 : uint16);
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end NumericToUint32(
      Input1 : 'T;
      MTC_AC_Output1 : bool)
    returns (Output1 : uint32; MTC_AC_Input1 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : uint32;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L1 #1 : uint32);
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end NumericToUint64(
      Input1 : 'T;
      MTC_AC_Output1 : bool)
    returns (Output1 : uint64; MTC_AC_Input1 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : uint64;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L1 #1 : uint64);
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end NumericToFloat64(
      Input1 : 'T;
      MTC_AC_Output1 : bool)
    returns (Output1 : float64; MTC_AC_Input1 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : float64;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L1 #1 : float64);
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end NumericToFloat32(
      Input1 : 'T;
      MTC_AC_Output1 : bool)
    returns (Output1 : float32; MTC_AC_Input1 : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : float32;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L1 #1 : float32);
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end PolynomialStep(
      Acc : 'T;
      X : 'T;
      C : 'T;
      MTC_AC_Y : bool)
    returns (
      Y : 'T;
      MTC_AC_Acc : bool default = false;
      MTC_AC_X : bool default = false;
      MTC_AC_C : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : 'T;
  let
    _L1= Acc;
    _L2= X;
    _L3= C;
    Y= _L5;
    _L4= _L1 #1 * _L2;
    _L5= _L4 #1 + _L3;
    _= MTC_AC_Y;
    MTC_AC_Acc= false;
    MTC_AC_X= false;
    MTC_AC_C= false;
  tel

  function #pragma kcg expand #end Polynomial<<N>>(
      X : 'T;
      C : 'T^N;
      MTC_AC_Y : bool)
    returns (
      Y : 'T;
      MTC_AC_X : bool default = false;
      MTC_AC_C : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T^N;
    _L5 : 'T^N;
  let
    _L1=
      ( fold #1 MTCEx::MTC_Instrumenters::math_PolynomialStep_MTC_INST <<N>>)(_L2,
        _L4, _L5, (false)^N, (false)^N);
    _L2= (0 #1 : 'T);
    _L3= X;
    _L4= (_L3)#1^N;
    _L5= C;
    Y= _L1;
    _= MTC_AC_Y;
    MTC_AC_X= false;
    MTC_AC_C= false;
  tel

  function Mod(value : 'T; modulus : 'T; MTC_AC_Outputs : bool)
    returns (remain : 'T)
    where 'T numeric
  var
    _L25 : int32;
    _L23 : 'T;
    _L22 : 'T;
    _L21 : 'T;
    _L20 : 'T;
    _L19 : bool;
    _L18 : 'T;
    _L17 : 'T;
    _L16 : 'T;
    _L15 : 'T;
    _L14 : 'T;
  let
    remain= _L21;
    _L14= _L20 #1 / _L16;
    _L15= modulus;
    _L16= #1 if _L19 then (_L22) else (_L15);
    _L17= (_L25 #1 : 'T);
    _L18= _L17 #1 * _L15;
    _L19= _L15 #1 = _L23;
    _L20= value;
    _L21= _L20 #1 - _L18;
    _L22= (1 #2 : 'T);
    _L23= (0 #3 : 'T);
    _L25= #1 RoundFloor(_L14, false);
    _= MTC_AC_Outputs;
  tel

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/libmathext_MTC_INST/mathext.xscade */
package mathext
  package mathextimpl
    function imported #pragma kcg C:name AcoshR32_mathext_mathextimpl #end
      AcoshR32(i : float32) returns (o : float32) specialize AcoshR;

    function imported #pragma kcg C:name AcosR32_mathext_mathextimpl #end
      AcosR32(i : float32) returns (o : float32) specialize AcosR;

    function imported #pragma kcg C:name AsinhR32_mathext_mathextimpl #end
      AsinhR32(i : float32) returns (o : float32) specialize AsinhR;

    function imported #pragma kcg C:name AsinR32_mathext_mathextimpl #end
      AsinR32(i : float32) returns (o : float32) specialize AsinR;

    function imported #pragma kcg C:name Atan2R32_mathext_mathextimpl #end
      Atan2R32(y : float32; x : float32)
      returns (o : float32)
      specialize Atan2R;

    function imported #pragma kcg C:name AtanhR32_mathext_mathextimpl #end
      AtanhR32(i : float32) returns (o : float32) specialize AtanhR;

    function imported #pragma kcg C:name AtanR32_mathext_mathextimpl #end
      AtanR32(i : float32) returns (o : float32) specialize AtanR;

    function imported #pragma kcg C:name CoshR32_mathext_mathextimpl #end
      CoshR32(i : float32) returns (o : float32) specialize CoshR;

    function imported #pragma kcg C:name CosR32_mathext_mathextimpl #end CosR32(
        i : float32)
      returns (o : float32)
      specialize CosR;

    function imported #pragma kcg C:name ExpR32_mathext_mathextimpl #end ExpR32(
        i : float32)
      returns (o : float32)
      specialize ExpR;

    function imported #pragma kcg C:name LnR32_mathext_mathextimpl #end LnR32(
        i : float32)
      returns (o : float32)
      specialize LnR;

    function imported #pragma kcg C:name LogR32_mathext_mathextimpl #end LogR32(
        i : float32)
      returns (o : float32)
      specialize LogR;

    function imported #pragma kcg C:name PowerR32_mathext_mathextimpl #end
      PowerR32(i : float32; p : int32) returns (o : float32) specialize PowerR;

    function imported #pragma kcg C:name PowerRR32_mathext_mathextimpl #end
      PowerRR32(i : float32; p : float32)
      returns (o : float32)
      specialize PowerRR;

    function imported #pragma kcg C:name SinhR32_mathext_mathextimpl #end
      SinhR32(i : float32) returns (o : float32) specialize SinhR;

    function imported #pragma kcg C:name SinR32_mathext_mathextimpl #end SinR32(
        i : float32)
      returns (o : float32)
      specialize SinR;

    function imported #pragma kcg C:name SqrtR32_mathext_mathextimpl #end
      SqrtR32(i : float32) returns (o : float32) specialize SqrtR;

    function imported #pragma kcg C:name TanhR32_mathext_mathextimpl #end
      TanhR32(i : float32) returns (o : float32) specialize TanhR;

    function imported #pragma kcg C:name TanR32_mathext_mathextimpl #end TanR32(
        i : float32)
      returns (o : float32)
      specialize TanR;

    function imported #pragma kcg C:name TenPowR32_mathext_mathextimpl #end
      TenPowR32(i : float32) returns (o : float32) specialize TenPowR;

    function imported #pragma kcg C:name AcoshR64_mathext_mathextimpl #end
      AcoshR64(i : float64) returns (o : float64) specialize AcoshR;

    function imported #pragma kcg C:name AcosR64_mathext_mathextimpl #end
      AcosR64(i : float64) returns (o : float64) specialize AcosR;

    function imported #pragma kcg C:name AsinhR64_mathext_mathextimpl #end
      AsinhR64(i : float64) returns (o : float64) specialize AsinhR;

    function imported #pragma kcg C:name AsinR64_mathext_mathextimpl #end
      AsinR64(i : float64) returns (o : float64) specialize AsinR;

    function imported #pragma kcg C:name Atan2R64_mathext_mathextimpl #end
      Atan2R64(y : float64; x : float64)
      returns (o : float64)
      specialize Atan2R;

    function imported #pragma kcg C:name AtanhR64_mathext_mathextimpl #end
      AtanhR64(i : float64) returns (o : float64) specialize AtanhR;

    function imported #pragma kcg C:name AtanR64_mathext_mathextimpl #end
      AtanR64(i : float64) returns (o : float64) specialize AtanR;

    function imported #pragma kcg C:name CoshR64_mathext_mathextimpl #end
      CoshR64(i : float64) returns (o : float64) specialize CoshR;

    function imported #pragma kcg C:name CosR64_mathext_mathextimpl #end CosR64(
        i : float64)
      returns (o : float64)
      specialize CosR;

    function imported #pragma kcg C:name ExpR64_mathext_mathextimpl #end ExpR64(
        i : float64)
      returns (o : float64)
      specialize ExpR;

    function imported #pragma kcg C:name LnR64_mathext_mathextimpl #end LnR64(
        i : float64)
      returns (o : float64)
      specialize LnR;

    function imported #pragma kcg C:name LogR64_mathext_mathextimpl #end LogR64(
        i : float64)
      returns (o : float64)
      specialize LogR;

    function imported #pragma kcg C:name PowerR64_mathext_mathextimpl #end
      PowerR64(i : float64; p : int32) returns (o : float64) specialize PowerR;

    function imported #pragma kcg C:name PowerRR64_mathext_mathextimpl #end
      PowerRR64(i : float64; p : float64)
      returns (o : float64)
      specialize PowerRR;

    function imported #pragma kcg C:name SinhR64_mathext_mathextimpl #end
      SinhR64(i : float64) returns (o : float64) specialize SinhR;

    function imported #pragma kcg C:name SinR64_mathext_mathextimpl #end SinR64(
        i : float64)
      returns (o : float64)
      specialize SinR;

    function imported #pragma kcg C:name SqrtR64_mathext_mathextimpl #end
      SqrtR64(i : float64) returns (o : float64) specialize SqrtR;

    function imported #pragma kcg C:name TanhR64_mathext_mathextimpl #end
      TanhR64(i : float64) returns (o : float64) specialize TanhR;

    function imported #pragma kcg C:name TanR64_mathext_mathextimpl #end TanR64(
        i : float64)
      returns (o : float64)
      specialize TanR;

    function imported #pragma kcg C:name TenPowR64_mathext_mathextimpl #end
      TenPowR64(i : float64) returns (o : float64) specialize TenPowR;

    function imported #pragma kcg C:name PowerI_mathext #end PowerI32(
        i : int32;
        p : int32)
      returns (o : int32)
      specialize PowerI;

  end;

  function imported AcosR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported AcoshR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported AsinR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported AsinhR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported Atan2R(Input1 : 'T; Input2 : 'T)
    returns (Output1 : 'T)
    where 'T float;

  function imported AtanR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported AtanhR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported CosR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported CoshR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported ExpR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported LnR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported LogR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported PowerRR(P_Input : 'T; Power : 'T)
    returns (P_Output : 'T)
    where 'T float;

  function imported SinR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported SinhR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported SqrtR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported TanR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported TanhR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function imported TenPowR(Input1 : 'T) returns (Output1 : 'T) where 'T float;

  function Square(Square_In : 'T; MTC_AC_Outputs : bool)
    returns (Square_Out : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
  let
    _L1= Square_In;
    _L2= _L1 #1 * _L1;
    Square_Out= _L2;
    _= MTC_AC_Outputs;
  tel

  function Inv(Inv_In : 'T; MTC_AC_Outputs : bool)
    returns (Inv_Out : 'T)
    where 'T float
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
  let
    _L1= Inv_In;
    _L2= (1.0 #4 : 'T);
    _L3= _L2 #1 / _L1;
    Inv_Out= _L3;
    _= MTC_AC_Outputs;
  tel

  function HypotR(HypotR_I1 : 'T; HypotR_I2 : 'T; MTC_AC_Outputs : bool)
    returns (HypotR_O : 'T)
    where 'T float
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
  let
    _L1= HypotR_I2;
    _L2= HypotR_I1;
    _L3= _L2 #1 * _L2;
    _L4= _L1 #2 * _L1;
    _L5= _L3 #3 + _L4;
    _L6= #4 SqrtR(_L5);
    HypotR_O= _L6;
    _= MTC_AC_Outputs;
  tel

  function imported #pragma kcg C:name PowerI_mathext #end PowerI(
      P_Input : 'T;
      Power : 'T)
    returns (P_Output : 'T)
    where 'T integer;

  function imported PowerR(P_Input : 'T; Power : int32)
    returns (P_Output : 'T)
    where 'T float;

  function #pragma kcg expand #end SinCosR(
      Input1 : 'T;
      MTC_AC_Output1 : bool;
      MTC_AC_Output2 : bool)
    returns (Output1 : 'T; Output2 : 'T; MTC_AC_Input1 : bool default = false)
    where 'T float
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
  let
    _L1= Input1;
    _L2= #1 SinR(_L1);
    _L3= #1 CosR(_L1);
    Output1= _L2;
    Output2= _L3;
    _= MTC_AC_Output1;
    _= MTC_AC_Output2;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end SphericalToCartesian(
      r : 'T;
      theta : 'T;
      phi : 'T;
      MTC_AC_x : bool;
      MTC_AC_y : bool;
      MTC_AC_z : bool)
    returns (
      x : 'T;
      y : 'T;
      z : 'T;
      MTC_AC_r : bool default = false;
      MTC_AC_theta : bool default = false;
      MTC_AC_phi : bool default = false)
    where 'T float
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : 'T;
    _L10 : 'T;
    _L18 : 'T;
  let
    _L1= r;
    _L2= theta;
    _L3= phi;
    x= _L9;
    y= _L10;
    _L4= #1 CosR(_L3);
    _L5= #1 SinR(_L3);
    _L6= #2 CosR(_L2);
    _L7= #2 SinR(_L2);
    _L8= _L1 #1 * _L5;
    _L9= _L8 #2 * _L6;
    _L10= _L8 #3 * _L7;
    _L18= _L1 #4 * _L4;
    z= _L18;
    _= MTC_AC_x;
    _= MTC_AC_y;
    _= MTC_AC_z;
    MTC_AC_r= false;
    MTC_AC_theta= false;
    MTC_AC_phi= false;
  tel

  function #pragma kcg expand #end RadiansToDegrees(
      Radians : 'T;
      MTC_AC_Degrees : bool)
    returns (Degrees : 'T; MTC_AC_Radians : bool default = false)
    where 'T float
  var
    pi : 'T;
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
  let
    _L1= Radians;
    Degrees= _L4;
    pi= _L2;
    _L2= (3.1415926535897 #1 : 'T);
    _L3= _L5 #1 / _L6;
    _L4= _L1 #1 * _L3;
    _L5= (180.0 #2 : 'T);
    _L6= pi;
    _= MTC_AC_Degrees;
    MTC_AC_Radians= false;
  tel

  function #pragma kcg expand #end PolarToCartesian(
      r : 'T;
      theta : 'T;
      MTC_AC_x : bool;
      MTC_AC_y : bool)
    returns (
      x : 'T;
      y : 'T;
      MTC_AC_r : bool default = false;
      MTC_AC_theta : bool default = false)
    where 'T float
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
  let
    _L1= #1 CosR(_L6);
    _L2= #1 SinR(_L6);
    _L3= _L1 #1 * _L5;
    _L4= _L5 #2 * _L2;
    _L5= r;
    _L6= theta;
    x= _L3;
    y= _L4;
    _= MTC_AC_x;
    _= MTC_AC_y;
    MTC_AC_r= false;
    MTC_AC_theta= false;
  tel

  function #pragma kcg expand #end FahrenheitToCelsius(
      Fahrenheit : 'T;
      MTC_AC_Celsius : bool)
    returns (Celsius : 'T; MTC_AC_Fahrenheit : bool default = false)
    where 'T float
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : 'T;
  let
    _L1= Fahrenheit;
    Celsius= _L2;
    _L2= _L3 #1 * _L4;
    _L3= _L1 #1 - _L5;
    _L4= (5.0 #3 / 9.0 #1 : 'T);
    _L5= (32.0 #2 : 'T);
    _= MTC_AC_Celsius;
    MTC_AC_Fahrenheit= false;
  tel

  function #pragma kcg expand #end DegreesToRadians(
      Degrees : 'T;
      MTC_AC_Radians : bool)
    returns (Radians : 'T; MTC_AC_Degrees : bool default = false)
    where 'T float
  var
    pi : 'T;
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
  let
    _L1= Degrees;
    Radians= _L4;
    pi= _L2;
    _L2= (3.1415926535897 #1 : 'T);
    _L3= _L6 #1 / _L5;
    _L4= _L1 #1 * _L3;
    _L5= (180.0 #2 : 'T);
    _L6= pi;
    _= MTC_AC_Radians;
    MTC_AC_Degrees= false;
  tel

  function #pragma kcg expand #end CelsiusToFahrenheit(
      Celsius : 'T;
      MTC_AC_Fahrenheit : bool)
    returns (Fahrenheit : 'T; MTC_AC_Celsius : bool default = false)
    where 'T float
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : 'T;
  let
    _L1= Celsius;
    Fahrenheit= _L3;
    _L2= _L1 #1 * _L4;
    _L3= _L2 #1 + _L5;
    _L4= (9.0 #2 / 5.0 #1 : 'T);
    _L5= (32.0 #2 : 'T);
    _= MTC_AC_Fahrenheit;
    MTC_AC_Celsius= false;
  tel

  function #pragma kcg expand #end CartesianToSpherical(
      x : 'T;
      y : 'T;
      z : 'T;
      MTC_AC_r : bool;
      MTC_AC_theta : bool;
      MTC_AC_phi : bool)
    returns (
      r : 'T;
      theta : 'T;
      phi : 'T;
      MTC_AC_x : bool default = false;
      MTC_AC_y : bool default = false;
      MTC_AC_z : bool default = false)
    where 'T float
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L6 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= #1 Atan2R(_L8, _L7);
    _L2= #1 HypotR(_L7, _L8, false);
    _L3= #2 HypotR(_L2, _L9, false);
    _L6= #2 Atan2R(_L2, _L9);
    _L7= x;
    _L8= y;
    _L9= z;
    r= _L3;
    theta= _L1;
    phi= _L6;
    _= MTC_AC_r;
    _= MTC_AC_theta;
    _= MTC_AC_phi;
    MTC_AC_x= false;
    MTC_AC_y= false;
    MTC_AC_z= false;
  tel

  function #pragma kcg expand #end CartesianToPolar(
      x : 'T;
      y : 'T;
      MTC_AC_r : bool;
      MTC_AC_theta : bool)
    returns (
      r : 'T;
      theta : 'T;
      MTC_AC_x : bool default = false;
      MTC_AC_y : bool default = false)
    where 'T float
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
  let
    _L1= #1 Atan2R(_L4, _L3);
    _L2= #1 HypotR(_L3, _L4, false);
    _L3= x;
    _L4= y;
    r= _L2;
    theta= _L1;
    _= MTC_AC_r;
    _= MTC_AC_theta;
    MTC_AC_x= false;
    MTC_AC_y= false;
  tel

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/libpwlinear_MTC_INST/pwlinear.xscade */
package pwlinear
  function #pragma kcg expand #end LimiterUnSymmetrical(
      LUS_Input : 'T;
      LowLimit : 'T;
      HighLimit : 'T;
      MTC_AC_LUS_Output : bool)
    returns (
      LUS_Output : 'T;
      MTC_AC_LUS_Input : bool default = false;
      MTC_AC_LowLimit : bool default = false;
      MTC_AC_HighLimit : bool default = false)
    where 'T numeric
  var
    _L1 : bool;
    _L11 : 'T;
    _L13 : 'T;
    _L15 : 'T;
    _L2 : bool;
    _L3 : 'T;
    _L9 : 'T;
  let
    _L1= _L3 #1 >= _L15;
    _L2= _L3 #2 <= _L13;
    _L3= LUS_Input;
    _L9= #3 if _L1 then (_L15) else (_L11);
    _L11= #6 if _L2 then (_L13) else (_L3);
    _L13= LowLimit;
    _L15= HighLimit;
    LUS_Output= _L9;
    assume A1 : LowLimit #3 <= HighLimit;
    _= MTC_AC_LUS_Output;
    MTC_AC_LUS_Input= false;
    MTC_AC_LowLimit= false;
    MTC_AC_HighLimit= false;
  tel

  function #pragma kcg expand #end PreLoadUnSymmetrical(
      PLUS_Input : 'T;
      NegOffset : 'T;
      PosOffset : 'T;
      Slope : 'T;
      MTC_AC_PLUS_Output : bool)
    returns (
      PLUS_Output : 'T;
      MTC_AC_PLUS_Input : bool default = false;
      MTC_AC_NegOffset : bool default = false;
      MTC_AC_PosOffset : bool default = false;
      MTC_AC_Slope : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L12 : 'T;
    _L14 : 'T;
    _L15 : 'T;
    _L4 : bool;
    _L5 : 'T;
    _L7 : 'T;
    _L9 : 'T;
    _L17 : 'T;
  let
    _L1= PLUS_Input;
    PLUS_Output= _L7;
    _L4= _L1 #1 < _L17;
    _L5= #2 if _L4 then (_L12) else (_L15);
    _L7= _L9 #5 + _L5;
    _L9= _L1 #6 * _L14;
    _L12= NegOffset;
    _L14= Slope;
    _L15= PosOffset;
    _L17= (0 #3 : 'T);
    _= MTC_AC_PLUS_Output;
    MTC_AC_PLUS_Input= false;
    MTC_AC_NegOffset= false;
    MTC_AC_PosOffset= false;
    MTC_AC_Slope= false;
  tel

  node ClockCounter(Reset : bool) returns (Count : int32)
  var
    _L1 : int32;
    _L2 : int32;
    _L6 : int32;
    _L7 : int32;
    _L8 : int32;
    _L11 : int32;
    _L13 : bool;
    _L16 : int32;
  let
    _L2= #1 if _L13 then (_L16) else (_L7);
    Count= _L1;
    _L6= #pre4 fby(_L1; 1; 0);
    _L7= _L8 #5 + _L6;
    _L8= 1;
    _L1= (_L11) #6 -> (_L2);
    _L11= 0;
    _L13= Reset;
    _L16= 0;
  tel

  function Quantizer(Q_Input : 'T; Interval : 'T; MTC_AC_Outputs : bool)
    returns (Q_Output : 'T)
    where 'T float
  var
    _L8 : 'T;
    _L11 : 'T;
    _L12 : 'T;
    _L13 : 'T;
    _L142 : 'T;
    _L140 : bool;
    _L139 : 'T;
    _L138 : 'T;
    _L137 : 'T;
    _L136 : 'T;
    _L135 : 'T;
    _L134 : 'T;
    _L133 : int32;
    _L130 : 'T;
    _L129 : bool;
    _L128 : 'T;
    _L127 : 'T;
    _L126 : 'T;
    _L125 : bool;
    _L124 : 'T;
  let
    _L8= Q_Input;
    Q_Output= _L13;
    _L11= Interval;
    _L12= _L8 #1 / _L11;
    _L13= _L136 #2 * _L11;
    _L142= _L12 #3 - _L124;
    _L140= _L142 #4 <= _L137;
    _L139= _L124 #5 - _L126;
    _L138= (1.0 #7 : 'T);
    _L137= (- 0.5 #4 : 'T);
    _L136= #6 if _L125 then (_L134) else (_L127);
    _L135= _L124 #9 + _L138;
    _L134= #10 if _L140 then (_L139) else (_L124);
    _L133= (_L12 #8 : int32);
    _L130= (0.0 #3 : 'T);
    _L129= _L142 #14 >= _L128;
    _L128= (0.5 #6 : 'T);
    _L127= #15 if _L129 then (_L135) else (_L124);
    _L126= (1.0 #5 : 'T);
    _L125= _L142 #18 < _L130;
    _L124= (_L133 #9 : 'T);
    assume A1 : Interval #1 <> 0.0;
    _= MTC_AC_Outputs;
  tel

  node RateLimiter(Input : 'T; Rising : 'T; Falling : 'T; deltaT : 'T)
    returns (Output : 'T last = Input)
    where 'T float
  var
    _L1 : 'T;
    _L6 : 'T;
    _L7 : 'T;
    _L8 : bool;
    _L9 : 'T;
    _L10 : 'T;
    _L12 : bool;
    _L13 : 'T;
    _L14 : 'T;
    _L38 : 'T;
    _L40 : 'T;
    _L41 : 'T;
    _L42 : 'T;
    _L48 : 'T;
    _L49 : 'T;
    _L50 : 'T;
    _L52 : 'T;
    _L53 : 'T;
    _L54 : 'T;
    _L55 : 'T;
  let
    _L1= Input;
    Output= _L9;
    _L6= Rising;
    _L7= Falling;
    _L8= _L38 #1 < _L7;
    _L9= #2 if _L8 then (_L10) else (_L13);
    _L12= _L38 #5 > _L6;
    _L13= #6 if _L12 then (_L14) else (_L1);
    _L10= _L53 #9 + _L41;
    _L14= _L52 #10 + _L42;
    _L38= _L49 #11 / _L54;
    _L40= deltaT;
    _L41= _L7 #12 * _L55;
    _L42= _L6 #13 * _L40;
    assume A1 : Falling #1 <= Rising;
    _L48= last 'Output;
    _L49= _L50 #16 - _L48;
    _L50= Input;
    _L52= last 'Output;
    _L53= last 'Output;
    _L54= deltaT;
    _L55= deltaT;
  tel

  node Counter(Incr : 'T; Reset : bool) returns (Count : 'T) where 'T numeric
  var
    _L2 : 'T;
    _L3 : bool;
    _L4 : 'T;
    _L9 : 'T;
    _L18 : 'T;
    _L47 : 'T;
  let
    _L2= Incr;
    _L3= Reset;
    Count= _L4;
    _L4= #1 if _L3 then (_L47) else (_L18);
    _L9= _L4 #4 + _L2;
    _L18= #5 fby(_L9; 1; _L47);
    _L47= (0 #1 : 'T);
  tel

  node FallingHysteresis(LL : 'T; FH_Input : 'T; UL : 'T; Init : bool)
    returns (FH_Output : bool)
    where 'T numeric
  var
    _L10 : bool;
    _L9 : bool;
    _L6 : bool;
    _L5 : bool;
    _L4 : bool;
    _L3 : 'T;
    _L2 : 'T;
    _L1 : 'T;
    _L16 : bool;
    _L17 : bool;
  let
    _L10= _L2 #1 < _L3;
    _L9= _L2 #2 <= _L1;
    _L6= #pre3 fby(_L17; 1; false);
    _L5= (_L4) #4 -> (_L6);
    _L4= Init;
    FH_Output= _L17;
    _L3= LL;
    _L2= FH_Input;
    _L1= UL;
    _L16= _L9 #7 and _L5;
    _L17= _L10 #8 or _L16;
    assume A1 : LL #3 <= UL;
  tel

  node RisingHysteresis(UL : 'T; A : 'T; LL : 'T; Init : bool)
    returns (S : bool)
    where 'T numeric
  var
    _L6 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : bool;
    _L10 : bool;
    _L11 : bool;
    _L15 : bool;
    _L16 : bool;
    _L22 : bool;
    _L24 : bool;
  let
    _L6= UL;
    _L7= A;
    _L8= LL;
    S= _L24;
    _L9= Init;
    _L10= (_L9) #1 -> (_L11);
    _L11= #pre4 fby(_L24; 1; false);
    _L15= _L7 #5 > _L6;
    _L16= _L7 #6 >= _L8;
    _L22= _L16 #7 and _L10;
    _L24= _L15 #8 or _L22;
    assume A1 : UL #7 >= LL;
  tel

  function #pragma kcg expand #end LimiterSymmetrical(
      LS_Input : 'T;
      BandOrigin : 'T;
      Tolerance : 'T;
      MTC_AC_LS_Output : bool)
    returns (
      LS_Output : 'T;
      MTC_AC_LS_Input : bool default = false;
      MTC_AC_BandOrigin : bool default = false;
      MTC_AC_Tolerance : bool default = false)
    where 'T numeric
  var
    Upper_limit : 'T;
    Lower_limit : 'T;
    _L1 : bool;
    _L10 : 'T;
    _L2 : bool;
    _L5 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= _L8 #1 >= Upper_limit;
    _L2= _L8 #2 <= Lower_limit;
    Lower_limit= _L9 #3 - _L10;
    Upper_limit= _L10 #4 + _L9;
    _L5= #5 if _L1 then (Upper_limit) else (_L7);
    _L7= #8 if _L2 then (Lower_limit) else (_L8);
    _L8= LS_Input;
    LS_Output= _L5;
    _L9= BandOrigin;
    _L10= Tolerance;
    _= MTC_AC_LS_Output;
    MTC_AC_LS_Input= false;
    MTC_AC_BandOrigin= false;
    MTC_AC_Tolerance= false;
  tel

  function PreLoadSymmetrical(
      PLS_Input : 'T;
      Offset : 'T;
      Slope : 'T;
      MTC_AC_Outputs : bool)
    returns (PLS_Output : 'T)
    where 'T numeric
  var
    _L1 : bool;
    _L10 : 'T;
    _L2 : 'T;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L8 : 'T;
    _L9 : 'T;
    _L12 : 'T;
  let
    _L1= _L6 #1 > _L12;
    _L2= #2 if _L1 then (_L10) else (_L5);
    _L4= _L8 #5 + _L2;
    _L5= #6 - _L10;
    _L6= PLS_Input;
    _L8= _L6 #7 * _L9;
    _L9= Slope;
    _L10= Offset;
    PLS_Output= _L4;
    _L12= (0 #3 : 'T);
    _= MTC_AC_Outputs;
  tel

  function DeadBandUnSymmetrical(
      DBUS_Input : 'T;
      LowTol : 'T;
      HiTol : 'T;
      MTC_AC_Outputs : bool)
    returns (DBUS_Output : 'T)
    where 'T numeric
  var
    _L10 : 'T;
    _L8 : 'T;
    _L7 : 'T;
    _L5 : 'T;
    _L3 : bool;
    _L2 : bool;
    _L1 : 'T;
    _L11 : 'T;
    _L13 : 'T;
    _L15 : 'T;
  let
    _L10= DBUS_Input;
    _L8= (0 #3 : 'T);
    _L7= HiTol;
    DBUS_Output= _L1;
    _L5= #1 if _L3 then (_L13) else (_L8);
    _L3= _L10 #4 >= _L7;
    _L2= _L11 #5 >= _L10;
    _L1= #6 if _L2 then (_L15) else (_L5);
    _L11= LowTol;
    _L13= _L10 #9 - _L7;
    _L15= _L10 #10 - _L11;
    assume A1 : LowTol #1 <= HiTol;
    _= MTC_AC_Outputs;
  tel

  function DeadBandSymmetrical(
      DBS_Input : 'T;
      Tolerance : 'T;
      MTC_AC_Outputs : bool)
    returns (DBS_Output : 'T)
    where 'T numeric
  var
    _L26 : 'T;
    _L25 : bool;
    _L22 : 'T;
    _L20 : 'T;
    _L19 : 'T;
    _L18 : bool;
    _L17 : 'T;
    _L30 : 'T;
    _L31 : 'T;
    _L34 : 'T;
  let
    _L17= #1 if _L25 then (_L20) else (_L26);
    _L18= _L34 #4 >= _L30;
    _L19= _L34 #5 - _L30;
    _L20= _L30 #6 + _L34;
    _L22= (0 #3 : 'T);
    _L25= _L31 #7 >= _L34;
    _L26= #8 if _L18 then (_L19) else (_L22);
    _L30= Tolerance;
    _L31= #11 - _L30;
    DBS_Output= _L17;
    _L34= DBS_Input;
    _= MTC_AC_Outputs;
  tel

  node MinReset(Input : 'T; Reset : bool; Init : 'T)
    returns (Output : 'T)
    where 'T numeric
  var
    _L24 : 'T;
    _L23 : 'T;
    _L22 : 'T;
    _L21 : 'T;
    _L20 : bool;
    _L19 : 'T;
  let
    _L20= Reset;
    _L21= Input;
    _L22= #1 if _L20 then (_L24) else (_L23);
    Output= _L22;
    _L23= #1 MTCEx::MTC_Instrumenters::math_Min_MTC_INST(_L21, _L19, false, false);
    _L24= Init;
    _L19= #1 fby(_L22; 1; Init);
  tel

  node MaxReset(Input : 'T; Reset : bool; Init : 'T)
    returns (Output : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L8 : bool;
    _L12 : 'T;
    _L15 : 'T;
  let
    _L1= Input;
    Output= _L6;
    _L5= #1 MTCEx::MTC_Instrumenters::math_Max_MTC_INST(_L1, _L12, false, false);
    _L6= #1 if _L8 then (_L15) else (_L5);
    _L8= Reset;
    _L12= #1 fby(_L6; 1; Init);
    _L15= Init;
  tel

  node CheckSlope(Input : 'T; Max : 'T) returns (Output : bool) where 'T numeric
  var
    _L3 : bool;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L7 : 'T;
    _L8 : bool;
    _L9 : 'T;
  let
    _L3= (true) #1 -> (_L8);
    _L4= #1 MTCEx::MTC_Instrumenters::math_Abs_MTC_INST(_L5, false, false);
    _L5= _L7 #1 - _L6;
    _L6= #pre1 fby(_L7; 1; (0 : 'T));
    _L7= Input;
    _L8= _L4 #1 < _L9;
    _L9= Max;
    Output= _L3;
  tel

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/libpwlinear_MTC_INST/lut.xscade */
package lut
  function Interp1D<<Xs>>(
      IdxX : { k : int32, f : 'T };
      Y : 'T^Xs;
      MTC_AC_Outputs : bool)
    returns (OutY : 'T)
    where 'T float
  var
    Idx : int32;
    _L23 : 'T;
    _L29 : int32;
    _L28 : int32;
    _L27 : int32;
    _L26 : int32;
    _L25 : 'T;
    _L21 : 'T^Xs;
    _L20 : 'T;
    _L16 : 'T;
    _L15 : 'T;
    _L30 : int32;
    _L31 : 'T;
  let
    _L23= (_L21#7 . [_L28] default (0.0 #1 : 'T));
    _L29= 1;
    _L28= _L29 #6 + _L27;
    _L27= Idx;
    _L26= Idx;
    _L25= (_L21#5 . [_L26] default (0.0 #2 : 'T));
    _L21= Y;
    _L20= _L23 #4 - _L25;
    Idx= _L30;
    _L16= _L15 #3 + _L25;
    OutY= _L16;
    _L15= _L31 #2 * _L20;
    assume A1 : 0 #1 <= Idx #1 and Idx #1 < Xs #5 - 1;
    _L30= IdxX#1.k;
    _L31= IdxX#2.f;
    _= MTC_AC_Outputs;
  tel

  function Interp2DFloor<<Xs, Ys>>(
      IdxX : { k : int32, f : 'T };
      IdxY : { k : int32, f : 'T };
      Z : 'T^Ys^Xs;
      MTC_AC_Outputs : bool)
    returns (OutZ : 'T)
    where 'T float
  var
    i : int32;
    j : int32;
    _L11 : 'T;
    _L16 : 'T;
    _L21 : 'T;
    _L18 : 'T;
    _L45 : 'T;
    _L47 : 'T;
    _L48 : 'T;
    _L49 : 'T;
    _L50 : 'T;
    _L53 : bool;
    _L54 : 'T;
    _L56 : 'T;
    _L55 : bool;
    _L57 : int32;
    _L58 : int32;
  let
    i= _L57;
    j= _L58;
    _L11= (Z#2 . [i #1 + 1][j] default (0.0 #4 : 'T));
    _L16= (Z#1 . [i][j] default (0.0 #3 : 'T));
    _L18= (Z#4 . [i #3 + 1][j #4 + 1] default (0.0 #6 : 'T));
    _L21= (Z#3 . [i][j #2 + 1] default (0.0 #5 : 'T));
    OutZ= _L48;
    _L45= IdxX#1.f;
    _L47= IdxY#2.f;
    _L48= #11 if _L53 then (_L49) else (_L50);
    _L49= #14 if _L55 then (_L16) else (_L11);
    _L50= #17 if _L55 then (_L21) else (_L18);
    _L54= (1.0 #2 : 'T);
    _L56= (1.0 #1 : 'T);
    _L53= _L47 #20 < _L54;
    _L55= _L45 #21 < _L56;
    assume A2 : 0 #2 <= j #2 and j #23 < Ys #2 - 1;
    assume A1 : 0 #1 <= i #1 and i #22 < Xs #1 - 1;
    _L57= IdxX#3.k;
    _L58= IdxY#5.k;
    _= MTC_AC_Outputs;
  tel

  function PreLutDirect(
      InX : 'T;
      Orig : 'T;
      Step : 'T;
      NbElem : int32;
      Extrapol : bool;
      MTC_AC_Outputs : bool)
    returns (OutIndex : { k : int32, f : 'T })
    where 'T float
  var
    bLow : bool;
    bHigh : bool;
    F0 : 'T;
    N : int32;
    _L1 : 'T;
    _L17 : bool;
    _L45 : bool;
    _L49 : int32;
    _L56 : bool;
    _L71 : int32;
    _L75 : { k : int32, f : 'T };
    _L87 : int32;
    _L88 : 'T;
    _L89 : bool;
    _L93 : int32;
    _L92 : 'T;
    _L94 : { k : int32, f : 'T };
    _L98 : { k : int32, f : 'T };
    _L100 : { k : int32, f : 'T };
    _L103 : 'T;
    _L162 : { k : int32, f : 'T };
    _L163 : { k : int32, f : 'T };
    _L165 : 'T;
    _L164 : 'T;
    _L166 : 'T;
    _L167 : 'T;
    _L169 : 'T;
    _L171 : int32;
    _L173 : int32;
    _L174 : bool;
    _L175 : 'T;
    _L176 : 'T;
    _L177 : 'T;
    _L182 : { k : int32, f : 'T };
    _L180 : 'T;
    _L178 : 'T;
    _L181 : int32;
    _L184 : int32;
    _L185 : int32;
    _L186 : 'T;
    _L187 : 'T;
    _L172 : int32;
    _L188 : { k : int32, f : 'T };
    _L191 : { k : int32, f : 'T };
  let
    _L1= InX;
    bLow= _L17;
    _L45= bLow;
    _L49= (0 #28 : int32);
    _L56= bHigh;
    _L71= NbElem #1 - 2;
    _L75= #5{ k:_L71, f:_L177 };
    _L87= (0 #29 : int32);
    _L88= (0.0 #30 : 'T);
    _L89= Extrapol;
    _L92= (1.0 #32 : 'T);
    _L93= NbElem #31 - (2 #33 : int32);
    OutIndex= _L98;
    _L94= #6{ k:_L93, f:_L92 };
    _L98= #11 if _L45 then (_L163) else (_L100);
    _L100= #14 if _L56 then (_L162) else (_L182);
    _L17= _L1 #17 <= _L103;
    _L103= Orig;
    _L162= #18 if _L89 then (_L75) else (_L94);
    _L163= #21 if _L89 then (_L188) else (_L191);
    F0= _L167;
    _L164= InX;
    _L165= Orig;
    _L166= _L164 #24 - _L165;
    _L167= _L166 #25 / _L169;
    _L169= Step;
    _L171= (_L167 #26 : int32);
    N= _L171;
    _L173= NbElem;
    bHigh= _L174;
    _L175= F0;
    _L176= F0;
    _L182= #7{ k:_L181, f:_L178 };
    _L180= F0;
    _L178= _L180 #29 - _L186;
    _L181= N;
    _L184= N;
    _L177= _L176 #30 - _L187;
    _L185= NbElem #2 - 2;
    _L186= (_L184 #31 : 'T);
    _L187= (_L185 #27 : 'T);
    _L174= _L172 #34 > _L173;
    _L172= N;
    _L188= #1{ k:_L49, f:_L175 };
    _L191= #4{ k:_L87, f:_L88 };
    _= MTC_AC_Outputs;
  tel

  function Lut1DCeil<<Xs>>(
      InX : 'T;
      X : 'T^Xs;
      Y : 'T^Xs;
      MTC_AC_Outputs : bool)
    returns (OutY : 'T)
    where 'T float
  var
    i : int32;
    _L191 : 'T^Xs;
    _L190 : 'T^Xs;
    _L189 : 'T;
    _L186 : int32;
    _L192 : 'T;
    _L193 : 'T^Xs;
    _L194 : 'T^Xs;
    _L198 : int32;
    _L197 : int32;
    _L199 : int32;
    _L200 : int32;
  let
    OutY= _L192;
    _L186= 0;
    i=
      ( foldi #1 MTCEx::MTC_Instrumenters::lut_SearchIdxCeil_MTC_INST <<Xs>>)(_L186,
        _L191, _L194, (false)^Xs, (false)^Xs);
    _L189= InX;
    _L190= X;
    _L191= (_L189)#7^Xs;
    _L192= (_L193#3 . [_L199] default (0.0 #1 : 'T));
    _L193= Y;
    _L194= #1 reverse _L190;
    _L197= _L198 #4 - i;
    _L198= (Xs #2 : int32);
    _L199= _L197 #5 - _L200;
    _L200= 1;
    _= MTC_AC_Outputs;
  tel

  function Lut1DNearest<<Xs>>(
      InX : 'T;
      X : 'T^Xs;
      Y : 'T^Xs;
      MTC_AC_Outputs : bool)
    returns (OutY : 'T)
    where 'T float
  var
    i : int32;
    _L189 : 'T^(Xs - 2 - 0 + 1);
    _L188 : 'T^(Xs - 1 - 1 + 1);
    _L187 : 'T;
    _L185 : int32;
    _L184 : 'T^(Xs - 1);
    _L191 : 'T^Xs;
    _L190 : 'T;
  let
    _L184= (_L187)#6^(Xs - 1);
    _L185= 0;
    i=
      ( foldi #1 SearchNearest <<Xs - 1>>)(_L185, _L184, _L189, _L188, (
          false)^(Xs - 1));
    _L187= InX;
    _L188= X #1 [1 .. Xs - 1];
    _L189= X #2 [0 .. Xs - 2];
    OutY= _L190;
    _L190= (_L191#1 . [i] default (0.0 #1 : 'T));
    _L191= Y;
    _= MTC_AC_Outputs;
  tel

  function Lut2DFloor<<Xs, Ys>>(
      InX : 'T;
      InY : 'T;
      X : 'T^Xs;
      Y : 'T^Ys;
      Z : 'T^Ys^Xs;
      MTC_AC_Outputs : bool)
    returns (OutZ : 'T)
    where 'T float
  var
    i : int32;
    j : int32;
    _L2 : 'T;
    _L6 : 'T;
    _L11 : int32;
    _L12 : int32;
    _L14 : 'T^Xs;
    _L15 : int32;
    _L19 : int32;
    _L18 : 'T^Ys;
    _L20 : 'T;
    _L22 : 'T^Xs;
    _L23 : 'T^Ys;
  let
    _L2= InX;
    _L6= InY;
    OutZ= _L20;
    _L12= 0;
    _L18= Y;
    _L19= 0;
    i= _L11;
    j= _L15;
    _L20= (Z#1 . [i][j] default (0.0 #1 : 'T));
    _L22= (_L2)#4^Xs;
    _L23= (_L6)#5^Ys;
    _L11=
      ( foldi #6 MTCEx::MTC_Instrumenters::lut_SearchIdxFloor_MTC_INST <<Xs>>)(_L12,
        _L22, _L14, (false)^Xs, (false)^Xs);
    _L15=
      ( foldi #8 MTCEx::MTC_Instrumenters::lut_SearchIdxFloor_MTC_INST <<Ys>>)(_L19,
        _L23, _L18, (false)^Ys, (false)^Ys);
    _L14= X;
    _= MTC_AC_Outputs;
  tel

  function #pragma kcg expand #end SearchIdxFloor(
      i : int32;
      Acc : int32;
      InX : 'T;
      Xi : 'T;
      MTC_AC_Out : bool)
    returns (
      Out : int32;
      MTC_AC_i : bool default = false;
      MTC_AC_Acc : bool default = false;
      MTC_AC_InX : bool default = false;
      MTC_AC_Xi : bool default = false)
    where 'T numeric
  var
    _L8 : int32;
    _L40 : 'T;
    _L77 : bool;
    _L84 : int32;
    _L74 : 'T;
    _L86 : int32;
  let
    _L8= Acc;
    _L40= InX;
    Out= _L84;
    _L84= #1 if _L77 then (_L8) else (_L86);
    _L74= Xi;
    _L86= i;
    _L77= _L40 #1 < _L74;
    _= MTC_AC_Out;
    MTC_AC_i= false;
    MTC_AC_Acc= false;
    MTC_AC_InX= false;
    MTC_AC_Xi= false;
  tel

  function Lut2DCeil<<Xs, Ys>>(
      InX : 'T;
      InY : 'T;
      X : 'T^Xs;
      Y : 'T^Ys;
      Z : 'T^Ys^Xs;
      MTC_AC_Outputs : bool)
    returns (OutZ : 'T)
    where 'T float
  var
    i : int32;
    j : int32;
    _L2 : 'T;
    _L6 : 'T;
    _L11 : int32;
    _L13 : int32;
    _L14 : 'T^Xs;
    _L15 : int32;
    _L18 : 'T^Ys;
    _L17 : int32;
    _L20 : 'T;
    _L22 : 'T^Xs;
    _L23 : 'T^Ys;
    _L24 : 'T^Xs;
    _L27 : 'T^Ys;
  let
    _L2= InX;
    _L6= InY;
    OutZ= _L20;
    _L13= 0;
    _L14= X;
    _L17= 0;
    _L18= Y;
    i= _L11;
    j= _L15;
    _L20= (Z#2 . [Xs #6 - i #5 - 1][Ys #8 - j #7 - 1] default (0.0 #1 : 'T));
    _L22= (_L2)#6^Xs;
    _L23= (_L6)#7^Ys;
    _L11=
      ( foldi #8 MTCEx::MTC_Instrumenters::lut_SearchIdxCeil_MTC_INST <<Xs>>)(_L13,
        _L22, _L24, (false)^Xs, (false)^Xs);
    _L15=
      ( foldi #10 MTCEx::MTC_Instrumenters::lut_SearchIdxCeil_MTC_INST <<Ys>>)(_L17,
        _L23, _L27, (false)^Ys, (false)^Ys);
    _L24= #1 reverse _L14;
    _L27= #3 reverse _L18;
    _= MTC_AC_Outputs;
  tel

  function #pragma kcg expand #end SearchIdxCeil(
      i : int32;
      Acc : int32;
      InX : 'T;
      Xi : 'T;
      MTC_AC_Out : bool)
    returns (
      Out : int32;
      MTC_AC_i : bool default = false;
      MTC_AC_Acc : bool default = false;
      MTC_AC_InX : bool default = false;
      MTC_AC_Xi : bool default = false)
    where 'T numeric
  var
    _L8 : int32;
    _L40 : 'T;
    _L77 : bool;
    _L84 : int32;
    _L74 : 'T;
    _L86 : int32;
  let
    _L8= Acc;
    _L40= InX;
    Out= _L84;
    _L84= #1 if _L77 then (_L8) else (_L86);
    _L74= Xi;
    _L86= i;
    _L77= _L40 #1 > _L74;
    _= MTC_AC_Out;
    MTC_AC_i= false;
    MTC_AC_Acc= false;
    MTC_AC_InX= false;
    MTC_AC_Xi= false;
  tel

  function SearchNearest(
      i : int32;
      Acc : int32;
      InX : 'T;
      Xi1 : 'T;
      Xi2 : 'T;
      MTC_AC_Outputs : bool)
    returns (Out : int32)
    where 'T numeric
  var
    _L8 : int32;
    _L40 : 'T;
    _L74 : 'T;
    _L77 : bool;
    _L84 : int32;
    _L85 : 'T;
    _L87 : 'T;
    _L91 : 'T;
    _L98 : int32;
    _L99 : 'T;
    _L100 : 'T;
    _L101 : bool;
    _L102 : int32;
    _L103 : int32;
    _L104 : int32;
  let
    _L8= Acc;
    _L40= InX;
    _L74= Xi1;
    Out= _L84;
    _L84= #1 if _L77 then (_L8) else (_L98);
    _L85= Xi2;
    _L87= Xi1;
    _L91= InX;
    _L98= #4 if _L101 then (_L102) else (_L103);
    _L100= _L91 #7 - _L87;
    _L99= _L85 #8 - _L91;
    _L101= _L99 #1 > _L100;
    _L77= _L40 #10 < _L74;
    _L102= i;
    _L103= _L102 #11 + _L104;
    _L104= 1;
    _= MTC_AC_Outputs;
  tel

  function Lut2DNearest<<Xs, Ys>>(
      InX : 'T;
      InY : 'T;
      X : 'T^Xs;
      Y : 'T^Ys;
      Z : 'T^Ys^Xs;
      MTC_AC_Outputs : bool)
    returns (OutZ : 'T)
    where 'T float
  var
    i : int32;
    j : int32;
    _L2 : 'T;
    _L6 : 'T;
    _L11 : int32;
    _L13 : int32;
    _L14 : 'T^(Xs - 2 - 0 + 1);
    _L15 : int32;
    _L18 : 'T^(Ys - 1 - 1 + 1);
    _L17 : int32;
    _L20 : 'T;
    _L21 : 'T^(Xs - 1 - 1 + 1);
    _L26 : 'T^(Ys - 2 - 0 + 1);
    _L27 : 'T^(Xs - 1);
    _L28 : 'T^(Ys - 1);
  let
    _L2= InX;
    _L6= InY;
    OutZ= _L20;
    _L13= 0;
    _L14= X #1 [0 .. Xs - 2];
    _L17= 0;
    _L18= Y #4 [1 .. Ys - 1];
    i= _L11;
    j= _L15;
    _L20= (Z#1 . [i][j] default (0.0 #1 : 'T));
    _L21= X #2 [1 .. Xs - 1];
    _L26= Y #3 [0 .. Ys - 2];
    _L27= (_L2)#10^(Xs - 1);
    _L28= (_L6)#12^(Ys - 1);
    _L11=
      ( foldi #14 SearchNearest <<Xs - 1>>)(_L13, _L27, _L14, _L21, (false)^(Xs - 1));
    _L15=
      ( foldi #17 SearchNearest <<Ys - 1>>)(_L17, _L28, _L26, _L18, (false)^(Ys - 1));
    _= MTC_AC_Outputs;
  tel

  function Interp1DFloor<<Xs>>(
      IdxX : { k : int32, f : 'T };
      Y : 'T^Xs;
      MTC_AC_Outputs : bool)
    returns (OutY : 'T)
    where 'T float
  var
    Idx : int32;
    _L21 : 'T^Xs;
    _L23 : 'T;
    _L25 : 'T;
    _L26 : int32;
    _L27 : int32;
    _L28 : int32;
    _L29 : int32;
    _L30 : 'T;
    _L32 : bool;
    _L33 : 'T;
    _L34 : int32;
    _L35 : 'T;
  let
    OutY= _L30;
    Idx= _L34;
    _L21= Y;
    _L25= (_L21#2 . [_L28] default (0.0 #3 : 'T));
    _L26= Idx;
    _L27= Idx;
    _L28= _L29 #3 + _L27;
    _L29= 1;
    _L23= (_L21#4 . [_L26] default (0.0 #2 : 'T));
    _L30= #5 if _L32 then (_L23) else (_L25);
    _L32= _L35 #8 < _L33;
    _L33= (1.0 #1 : 'T);
    assume A1 : 0 #1 <= Idx #1 and Idx #9 < Xs #1 - 1;
    _L34= IdxX#1.k;
    _L35= IdxX#2.f;
    _= MTC_AC_Outputs;
  tel

  function Interp2D<<Xs, Ys>>(
      IdxX : { k : int32, f : 'T };
      IdxY : { k : int32, f : 'T };
      Z : 'T^Ys^Xs;
      MTC_AC_Outputs : bool)
    returns (OutZ : 'T)
    where 'T float
  var
    i : int32;
    j : int32;
    _L11 : 'T;
    _L12 : 'T;
    _L13 : 'T;
    _L14 : 'T;
    _L16 : 'T;
    _L21 : 'T;
    _L18 : 'T;
    _L41 : 'T;
    _L40 : 'T;
    _L39 : 'T;
    _L44 : 'T;
    _L43 : 'T;
    _L42 : 'T;
    _L45 : int32;
    _L46 : int32;
    _L47 : 'T;
    _L48 : 'T;
  let
    i= _L45;
    j= _L46;
    _L11= (Z#4 . [i][j] default (0.0 #4 : 'T));
    _L12= _L14 #4 + _L11;
    _L14= _L47 #5 * _L13;
    _L16= (Z#3 . [i #22 + 1][j] default (0.0 #3 : 'T));
    _L18= (Z#2 . [i][j #21 + 1] default (0.0 #2 : 'T));
    _L21= (Z#1 . [i #19 + 1][j #20 + 1] default (0.0 #1 : 'T));
    OutZ= _L43;
    _L13= _L16 #13 - _L11;
    _L39= _L40 #14 + _L18;
    _L40= _L47 #15 * _L41;
    _L41= _L21 #16 - _L18;
    _L42= _L39 #17 - _L12;
    _L43= _L44 #18 + _L12;
    _L44= _L48 #19 * _L42;
    assume A1 : 0 #2 <= i #2 and i #2 < Xs #19 - 1;
    assume A2 : 0 #4 <= j #4 and j #4 < Ys #21 - 1;
    _L45= IdxX#1.k;
    _L46= IdxY#5.k;
    _L47= IdxX#3.f;
    _L48= IdxY#4.f;
    _= MTC_AC_Outputs;
  tel

  function #pragma kcg expand #end SearchIdx(
      i : int32;
      AccIn : int32;
      InX : 'T;
      X : 'T;
      MTC_AC_AccOut : bool)
    returns (
      AccOut : int32;
      MTC_AC_i : bool default = false;
      MTC_AC_AccIn : bool default = false;
      MTC_AC_InX : bool default = false;
      MTC_AC_X : bool default = false)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : bool;
    _L7 : int32;
    _L8 : 'T;
    _L9 : int32;
    _L10 : int32;
  let
    _L1= InX;
    _L2= _L1 #1 >= _L8;
    _L7= i;
    AccOut= _L9;
    _L8= X;
    _L9= #1 if _L2 then (_L7) else (_L10);
    _L10= AccIn;
    _= MTC_AC_AccOut;
    MTC_AC_i= false;
    MTC_AC_AccIn= false;
    MTC_AC_InX= false;
    MTC_AC_X= false;
  tel

  function #pragma kcg expand #end Proj<<N>>(
      Idx : int32;
      Input1 : 'T^N;
      DefVal : 'T;
      MTC_AC_Output1 : bool;
      MTC_AC_Output2 : bool)
    returns (
      Output1 : 'T;
      Output2 : 'T;
      MTC_AC_Idx : bool default = false;
      MTC_AC_Input1 : bool default = false;
      MTC_AC_DefVal : bool default = false)
  var
    _L1 : 'T^N;
    _L2 : int32;
    _L6 : 'T;
    _L5 : 'T;
    _L4 : int32;
    _L3 : int32;
  let
    _L1= Input1;
    _L2= Idx;
    _L3= _L2 #1 + _L4;
    _L4= 1;
    _L5= (_L1#1 . [_L2] default DefVal);
    _L6= (_L1#2 . [_L3] default DefVal);
    Output1= _L5;
    Output2= _L6;
    _= MTC_AC_Output1;
    _= MTC_AC_Output2;
    MTC_AC_Idx= false;
    MTC_AC_Input1= false;
    MTC_AC_DefVal= false;
  tel

  function #pragma kcg expand #end PreLutNoSat<<Xs>>(
      InX : 'T;
      X : 'T^Xs;
      MTC_AC_F : bool;
      MTC_AC_Idx : bool)
    returns (
      F : 'T;
      Idx : int32;
      MTC_AC_InX : bool default = false;
      MTC_AC_X : bool default = false)
    where 'T float
  var
    idx : int32;
    X2 : 'T;
    X1 : 'T;
    _L33 : int32;
    _L39 : 'T^(Xs - 2 - 0 + 1);
    _L40 : 'T^(Xs - 1);
    _L42 : 'T;
    _L41 : 'T;
  let
    idx=
      ( foldi #1 MTCEx::MTC_Instrumenters::lut_SearchIdx_MTC_INST <<Xs - 1>>)(_L33,
        _L40, _L39, (false)^(Xs - 1), (false)^(Xs - 1));
    Idx= idx;
    _L33= 0;
    _L39= X #1 [0 .. Xs - 2];
    _L40= (InX)#1^(Xs - 1);
    X1= _L41;
    X2= _L42;
    _L41= (X#3 . [Idx] default (0.0 #1 : 'T));
    _L42= (X#4 . [Idx #2 + 1] default (0.0 #2 : 'T));
    activate IfBlock2 if X1 #1 = X2
      then var
        _L4 : 'T;
      let
        F= _L4;
        _L4= (0.0 #3 : 'T);
      tel
      else var
        _L4 : 'T;
      let
        _L4= (InX #6 - X1) #1 / (X2 #7 - X1);
        F= _L4;
      tel
    returns ..;
    assume A1 : ( fold #2 $and$ <<Xs - 1>>)(true, ( map
        #2 $<=$
        <<Xs - 1>>)(X #4 [0 .. Xs - 2], X #5 [1 .. Xs - 1]));
    _= MTC_AC_F;
    _= MTC_AC_Idx;
    MTC_AC_InX= false;
    MTC_AC_X= false;
  tel

  function Lut1DNoSat<<Xs>>(
      InX : 'T;
      X : 'T^Xs;
      Y : 'T^Xs;
      MTC_AC_Outputs : bool)
    returns (OutY : 'T)
    where 'T float
  var
    Idx : int32;
    _L16 : 'T;
    _L24 : 'T;
    _L25 : 'T;
    _L26 : 'T^Xs;
    _L27 : 'T^Xs;
    _L28 : 'T;
    _L29 : 'T;
  let
    _L25, Idx=
      (#1 MTCEx::MTC_Instrumenters::lut_PreLutNoSat_MTC_INST <<Xs>>)(_L16, _L27,
        false, false);
    _L16= InX;
    _L24=
      #1 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L25, _L29,
        _L28, false, false);
    OutY= _L24;
    _L26= Y;
    _L29, _L28=
      (#1 MTCEx::MTC_Instrumenters::lut_Proj_MTC_INST <<Xs>>)(Idx, _L26, (0.0 #1
        : 'T), false, false);
    _L27= X;
    _= MTC_AC_Outputs;
  tel

  function Limiter<<Xs>>(Val : 'T; Range : 'T^Xs; MTC_AC_Outputs : bool)
    returns (LimitedVal : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : bool;
    _L5 : 'T;
    _L6 : 'T;
    _L7 : bool;
  let
    _L1= Val;
    _L2= Range #1[0];
    _L3= Range #2[Xs #1 - 1];
    _L4= _L1 #1 < _L2;
    _L5= #1 if _L4 then (_L2) else (_L6);
    _L6= #2 if _L7 then (_L3) else (_L1);
    _L7= _L1 #1 > _L3;
    LimitedVal= _L5;
    _= MTC_AC_Outputs;
  tel

  function #pragma kcg expand #end InterpolateLinear(
      F : 'T;
      Y1 : 'T;
      Y2 : 'T;
      MTC_AC_Y : bool)
    returns (
      Y : 'T;
      MTC_AC_F : bool default = false;
      MTC_AC_Y1 : bool default = false;
      MTC_AC_Y2 : bool default = false)
    where 'T numeric
  var
    _L9 : 'T;
    _L8 : 'T;
    _L6 : 'T;
    _L11 : 'T;
    _L12 : 'T;
    _L13 : 'T;
  let
    _L6= _L12 #1 - _L13;
    Y= _L9;
    _L8= _L11 #1 * _L6;
    _L9= _L8 #1 + _L13;
    _L11= F;
    _L12= Y2;
    _L13= Y1;
    _= MTC_AC_Y;
    MTC_AC_F= false;
    MTC_AC_Y1= false;
    MTC_AC_Y2= false;
  tel

  function Lut1DFloor<<Xs>>(
      InX : 'T;
      X : 'T^Xs;
      Y : 'T^Xs;
      MTC_AC_Outputs : bool)
    returns (OutY : 'T)
    where 'T float
  var
    i : int32;
    _L188 : 'T^Xs;
    _L187 : 'T^Xs;
    _L186 : 'T^Xs;
    _L185 : 'T;
    _L184 : 'T;
    _L182 : int32;
  let
    _L182= 0;
    i=
      ( foldi #1 MTCEx::MTC_Instrumenters::lut_SearchIdxFloor_MTC_INST <<Xs>>)(_L182,
        _L186, _L188, (false)^Xs, (false)^Xs);
    _L184= InX;
    _L185= (_L187#1 . [i] default (0.0 #1 : 'T));
    _L186= (_L184)#6^Xs;
    _L187= Y;
    _L188= X;
    OutY= _L185;
    _= MTC_AC_Outputs;
  tel

  function Lut3DNearest<<Xs, Ys, Zs>>(
      InX : 'T;
      InY : 'T;
      InZ : 'T;
      X : 'T^Xs;
      Y : 'T^Ys;
      Z : 'T^Zs;
      W : 'T^Zs^Ys^Xs;
      MTC_AC_Outputs : bool)
    returns (OutW : 'T)
    where 'T float
  var
    i : int32;
    j : int32;
    k : int32;
    _L2 : 'T;
    _L6 : 'T;
    _L11 : int32;
    _L13 : int32;
    _L14 : 'T^(Xs - 2 - 0 + 1);
    _L15 : int32;
    _L18 : 'T^(Ys - 1 - 1 + 1);
    _L17 : int32;
    _L20 : 'T;
    _L21 : 'T^(Xs - 1 - 1 + 1);
    _L26 : 'T^(Ys - 2 - 0 + 1);
    _L27 : 'T^(Xs - 1);
    _L28 : 'T^(Ys - 1);
    _L34 : int32;
    _L33 : 'T^(Zs - 1 - 1 + 1);
    _L32 : 'T^(Zs - 1);
    _L31 : int32;
    _L30 : 'T^(Zs - 2 - 0 + 1);
    _L29 : 'T;
  let
    _L2= InX;
    _L6= InY;
    OutW= _L20;
    _L13= 0;
    _L14= X #1 [0 .. Xs - 2];
    _L17= 0;
    _L18= Y #2 [1 .. Ys - 1];
    i= _L11;
    j= _L15;
    _L20= (W#6 . [i][j][k] default (0.0 #1 : 'T));
    _L21= X #3 [1 .. Xs - 1];
    _L26= Y #4 [0 .. Ys - 2];
    _L27= (_L2)#1^(Xs - 1);
    _L28= (_L6)#2^(Ys - 1);
    _L11=
      ( foldi #1 SearchNearest <<Xs - 1>>)(_L13, _L27, _L14, _L21, (false)^(Xs - 1));
    _L15=
      ( foldi #2 SearchNearest <<Ys - 1>>)(_L17, _L28, _L26, _L18, (false)^(Ys - 1));
    _L29= InZ;
    _L30= Z #7 [0 .. Zs - 2];
    _L31=
      ( foldi #3 SearchNearest <<Zs - 1>>)(_L34, _L32, _L30, _L33, (false)^(Zs - 1));
    _L32= (_L29)#3^(Zs - 1);
    _L33= Z #8 [1 .. Zs - 1];
    _L34= 0;
    k= _L31;
    _= MTC_AC_Outputs;
  tel

  function Lut2DNoSat<<Xs, Ys>>(
      InX : 'T;
      InY : 'T;
      X : 'T^Xs;
      Y : 'T^Ys;
      Z : 'T^Ys^Xs;
      MTC_AC_Outputs : bool)
    returns (OutZ : 'T)
    where 'T float
  var
    rateY : 'T;
    rateX : 'T;
    idxY : int32;
    idxX : int32;
    _L22 : 'T;
    _L52 : 'T;
    _L79 : 'T;
    _L82 : 'T;
    _L83 : int32;
    _L84 : 'T;
    _L87 : 'T;
    _L93 : int32;
    _L94 : 'T;
    _L95 : 'T;
    _L96 : 'T;
    _L97 : 'T;
    _L98 : 'T;
    _L99 : 'T;
    _L101 : 'T;
    _L100 : 'T;
  let
    _L94, _L93=
      (#1 MTCEx::MTC_Instrumenters::lut_PreLutNoSat_MTC_INST <<Xs>>)(_L52, X,
        false, false);
    _L22=
      #3 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L95, _L79,
        _L87, false, false);
    OutZ= _L22;
    _L52= InX;
    _L79=
      #1 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L96, _L98,
        _L99, false, false);
    _L82, _L83=
      (#2 MTCEx::MTC_Instrumenters::lut_PreLutNoSat_MTC_INST <<Ys>>)(_L84, Y,
        false, false);
    _L84= InY;
    _L87=
      #2 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L97, _L101,
        _L100, false, false);
    rateY= _L82;
    rateX= _L94;
    idxX= _L93;
    idxY= _L83;
    _L95= rateX;
    _L96= rateY;
    _L97= rateY;
    _L98= (Z#10 . [idxX][idxY] default (0.0 #3 : 'T));
    _L99= (Z#11 . [idxX][idxY #9 + 1] default (0.0 #4 : 'T));
    _L100= (Z#9 . [idxX #7 + 1][idxY #8 + 1] default (0.0 #2 : 'T));
    _L101= (Z#8 . [idxX #6 + 1][idxY] default (0.0 #1 : 'T));
    _= MTC_AC_Outputs;
  tel

  function #pragma kcg expand #end Lut2D<<Xs, Ys>>(
      InX : 'T;
      InY : 'T;
      X : 'T^Xs;
      Y : 'T^Ys;
      Z : 'T^Ys^Xs;
      Extrapol : bool;
      MTC_AC_OutZ : bool)
    returns (
      OutZ : 'T;
      MTC_AC_InX : bool default = false;
      MTC_AC_InY : bool default = false;
      MTC_AC_X : bool default = false;
      MTC_AC_Y : bool default = false;
      MTC_AC_Z : bool default = false;
      MTC_AC_Extrapol : bool default = false)
    where 'T float
  var
    Xsat : 'T;
    Ysat : 'T;
    _L52 : 'T;
    _L53 : 'T;
    _L54 : 'T;
  let
    activate IfBlock1 if Extrapol
      then var
        _L2 : 'T;
        _L3 : 'T;
      let
        Xsat= _L2;
        _L2= InX;
        _L3= InY;
        Ysat= _L3;
      tel
      else var
        _L1 : 'T;
        _L2 : 'T;
        _L3 : 'T;
        _L4 : 'T;
      let
        Xsat= _L2;
        _L1= InX;
        _L2= #1 Limiter2(_L1, X #1[0], X #2[Xs #1 - 1], false);
        _L3= #2 Limiter2(_L4, Y #3[0], Y #4[Ys #2 - 1], false);
        _L4= InY;
        Ysat= _L3;
      tel
    returns ..;
    _L52= (#1 Lut2DNoSat <<Xs, Ys>>)(_L53, _L54, X, Y, Z, false);
    _L53= Xsat;
    _L54= Ysat;
    OutZ= _L52;
    _= MTC_AC_OutZ;
    MTC_AC_InX= false;
    MTC_AC_InY= false;
    MTC_AC_X= false;
    MTC_AC_Y= false;
    MTC_AC_Z= false;
    MTC_AC_Extrapol= false;
  tel

  function #pragma kcg expand #end Lut1D<<Xs>>(
      InX : 'T;
      X : 'T^Xs;
      Y : 'T^Xs;
      Extrapol : bool;
      MTC_AC_OutY : bool)
    returns (
      OutY : 'T;
      MTC_AC_InX : bool default = false;
      MTC_AC_X : bool default = false;
      MTC_AC_Y : bool default = false;
      MTC_AC_Extrapol : bool default = false)
    where 'T float
  var
    Xsat : 'T;
    _L16 : 'T;
    _L18 : 'T;
  let
    activate IfBlock1 if Extrapol
      then var
        _L2 : 'T;
      let
        Xsat= _L2;
        _L2= InX;
      tel
      else var
        _L1 : 'T;
        _L2 : 'T;
      let
        Xsat= _L2;
        _L1= InX;
        _L2= #1 Limiter2(_L1, X #1[0], X #2[Xs #1 - 1], false);
      tel
    returns ..;
    _L16= (#1 Lut1DNoSat <<Xs>>)(_L18, X, Y, false);
    _L18= Xsat;
    OutY= _L16;
    _= MTC_AC_OutY;
    MTC_AC_InX= false;
    MTC_AC_X= false;
    MTC_AC_Y= false;
    MTC_AC_Extrapol= false;
  tel

  function Lut3DNoSat<<Xs, Ys, Zs>>(
      InX : 'T;
      InY : 'T;
      InZ : 'T;
      X : 'T^Xs;
      Y : 'T^Ys;
      Z : 'T^Zs;
      W : 'T^Zs^Ys^Xs;
      MTC_AC_Outputs : bool)
    returns (OutW : 'T)
    where 'T float
  var
    rateY : 'T;
    idxY : int32;
    rateZ : 'T;
    idxZ : int32;
    rateX : 'T;
    idxX : int32;
    _L190 : 'T;
    _L189 : 'T;
    _L188 : 'T;
    _L187 : 'T;
    _L186 : 'T;
    _L185 : 'T;
    _L184 : 'T;
    _L183 : 'T;
    _L182 : 'T;
    _L181 : 'T;
    _L180 : 'T;
    _L179 : 'T;
    _L178 : 'T;
    _L177 : 'T;
    _L175 : 'T;
    _L176 : int32;
    _L174 : 'T;
    _L172 : 'T;
    _L173 : int32;
    _L171 : 'T;
    _L170 : 'T;
    _L169 : 'T;
    _L168 : 'T;
    _L167 : 'T;
    _L166 : 'T;
    _L164 : 'T;
    _L165 : int32;
    _L163 : 'T;
    _L162 : 'T;
  let
    _L162= InY;
    rateZ= _L172;
    _L163=
      #14 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L166, _L180,
        _L170, false, false);
    _L164, _L165=
      (#6 MTCEx::MTC_Instrumenters::lut_PreLutNoSat_MTC_INST <<Xs>>)(_L184, X,
        false, false);
    _L166= rateY;
    _L167=
      (W#16 . [idxX #22 + 1][idxY #23 + 1][idxZ #24 + 1] default (0.0 #8 : 'T));
    _L168=
      #13 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L187, _L185,
        _L171, false, false);
    _L169= (W#14 . [idxX #18 + 1][idxY][idxZ #19 + 1] default (0.0 #6 : 'T));
    _L170=
      #12 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L181, _L190,
        _L167, false, false);
    idxX= _L165;
    _L171= (W#10 . [idxX][idxY][idxZ #13 + 1] default (0.0 #2 : 'T));
    _L172, _L173=
      (#5 MTCEx::MTC_Instrumenters::lut_PreLutNoSat_MTC_INST <<Zs>>)(_L177, Z,
        false, false);
    _L174=
      #11 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L187, _L189,
        _L188, false, false);
    idxY= _L176;
    _L175, _L176=
      (#4 MTCEx::MTC_Instrumenters::lut_PreLutNoSat_MTC_INST <<Ys>>)(_L162, Y,
        false, false);
    _L177= InZ;
    rateX= _L164;
    _L178=
      #10 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L182, _L186,
        _L163, false, false);
    _L179= rateY;
    _L180=
      #9 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L181, _L183,
        _L169, false, false);
    _L181= rateZ;
    _L182= rateX;
    _L183= (W#13 . [idxX #17 + 1][idxY][idxZ] default (0.0 #5 : 'T));
    _L184= InX;
    rateY= _L175;
    idxZ= _L173;
    _L185= (W#9 . [idxX][idxY][idxZ] default (0.0 #1 : 'T));
    _L186=
      #8 MTCEx::MTC_Instrumenters::lut_InterpolateLinear_MTC_INST(_L179, _L168,
        _L174, false, false);
    OutW= _L178;
    _L187= rateZ;
    _L188= (W#12 . [idxX][idxY #15 + 1][idxZ #16 + 1] default (0.0 #4 : 'T));
    _L189= (W#11 . [idxX][idxY #14 + 1][idxZ] default (0.0 #3 : 'T));
    _L190= (W#15 . [idxX #20 + 1][idxY #21 + 1][idxZ] default (0.0 #7 : 'T));
    _= MTC_AC_Outputs;
  tel

  function #pragma kcg expand #end Lut3D<<Xs, Ys, Zs>>(
      InX : 'T;
      InY : 'T;
      InZ : 'T;
      X : 'T^Xs;
      Y : 'T^Ys;
      Z : 'T^Zs;
      W : 'T^Zs^Ys^Xs;
      Extrapol : bool;
      MTC_AC_OutW : bool)
    returns (
      OutW : 'T;
      MTC_AC_InX : bool default = false;
      MTC_AC_InY : bool default = false;
      MTC_AC_InZ : bool default = false;
      MTC_AC_X : bool default = false;
      MTC_AC_Y : bool default = false;
      MTC_AC_Z : bool default = false;
      MTC_AC_W : bool default = false;
      MTC_AC_Extrapol : bool default = false)
    where 'T float
  var
    In1Sat : 'T;
    In3Sat : 'T;
    In2Sat : 'T;
    _L89 : 'T;
    _L90 : 'T;
    _L91 : 'T;
    _L92 : 'T;
  let
    activate IfBlock1 if Extrapol
      then var
        _L1 : 'T;
        _L2 : 'T;
        _L3 : 'T;
      let
        _L1= InX;
        _L2= InY;
        _L3= InZ;
        In1Sat= _L1;
        In2Sat= _L2;
        In3Sat= _L3;
      tel
      else var
        _L1 : 'T;
        _L2 : 'T;
        _L3 : 'T;
        _L4 : 'T;
        _L5 : 'T;
        _L6 : 'T;
      let
        _L1= InX;
        _L2= InY;
        _L3= InZ;
        In1Sat= _L4;
        In2Sat= _L5;
        In3Sat= _L6;
        _L4= #1 Limiter2(_L1, X #1[0], X #2[Xs #1 - 1], false);
        _L5= #2 Limiter2(_L2, Y #3[0], Y #4[Ys #2 - 1], false);
        _L6= #3 Limiter2(_L3, Z #5[0], Z #6[Zs #3 - 1], false);
      tel
    returns ..;
    _L89= (#1 Lut3DNoSat <<Xs, Ys, Zs>>)(_L90, _L91, _L92, X, Y, Z, W, false);
    _L90= In1Sat;
    _L91= In2Sat;
    _L92= In3Sat;
    OutW= _L89;
    _= MTC_AC_OutW;
    MTC_AC_InX= false;
    MTC_AC_InY= false;
    MTC_AC_InZ= false;
    MTC_AC_X= false;
    MTC_AC_Y= false;
    MTC_AC_Z= false;
    MTC_AC_W= false;
    MTC_AC_Extrapol= false;
  tel

  function #pragma kcg expand #end PreLut<<Xs>>(
      InX : 'T;
      X : 'T^Xs;
      Extrapol : bool;
      MTC_AC_Out : bool)
    returns (
      Out : { k : int32, f : 'T };
      MTC_AC_InX : bool default = false;
      MTC_AC_X : bool default = false;
      MTC_AC_Extrapol : bool default = false)
    where 'T float
  var
    Xsat : 'T;
    _L44 : int32;
    _L43 : 'T;
    _L45 : 'T;
    _L52 : { k : int32, f : 'T };
  let
    activate IfBlock1 if Extrapol
      then var
        _L7 : 'T;
      let
        Xsat= _L7;
        _L7= InX;
      tel
      else var
        _L5 : 'T;
        _L6 : 'T;
      let
        _L5= InX;
        Xsat= _L6;
        _L6= #1 Limiter2(_L5, X #1[0], X #2[Xs #1 - 1], false);
      tel
    returns ..;
    _L43, _L44=
      (#1 MTCEx::MTC_Instrumenters::lut_PreLutNoSat_MTC_INST <<Xs>>)(_L45, X,
        false, false);
    _L45= Xsat;
    Out= _L52;
    _L52= #2{ k:_L44, f:_L43 };
    _= MTC_AC_Out;
    MTC_AC_InX= false;
    MTC_AC_X= false;
    MTC_AC_Extrapol= false;
  tel

  function Limiter2(Val : 'T; Low : 'T; High : 'T; MTC_AC_Outputs : bool)
    returns (LimitedVal : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : bool;
    _L5 : 'T;
    _L6 : 'T;
    _L7 : bool;
  let
    _L1= Val;
    _L2= Low;
    _L3= High;
    _L4= _L1 #1 < _L2;
    _L5= #1 if _L4 then (_L2) else (_L6);
    _L6= #2 if _L7 then (_L3) else (_L1);
    _L7= _L1 #1 > _L3;
    LimitedVal= _L5;
    _= MTC_AC_Outputs;
  tel

end;


/* xscade source: J:/Modelisation_Surveillance/Modelisation_Surveillance_MTC_INST/KCG/libverif_MTC_INST/libverif.xscade */
package verif
  node AlwaysAfterFirstCond(Input1 : bool; Cond : bool) returns (Output1 : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
  let
    _L1= Cond;
    _L2= Input1;
    Output1= _L4;
    _L3=
      #1 MTCEx::MTC_Instrumenters::verif_HasNeverBeenTrue_MTC_INST(_L1, false, false);
    _L4= _L3 #2 or _L2;
  tel

  node #pragma kcg expand #end HasNeverBeenTrue(
      Input1 : bool;
      MTC_AC_Output1 : bool)
    returns (Output1 : bool; MTC_AC_Input1 : bool default = false)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : bool;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= (_L4) #1 -> (_L5);
    _L3= #pre4 fby(_L2; 1; false);
    _L4= #5 not _L1;
    _L5= _L4 #6 and _L3;
    _= MTC_AC_Output1;
    MTC_AC_Input1= false;
  tel

  function #pragma kcg expand #end Implies(A : bool; B : bool; MTC_AC_C : bool)
    returns (
      C : bool;
      MTC_AC_A : bool default = false;
      MTC_AC_B : bool default = false)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
  let
    _L1= A;
    _L2= B;
    C= _L3;
    _L3= _L4 #1 or _L2;
    _L4= #2 not _L1;
    _= MTC_AC_C;
    MTC_AC_A= false;
    MTC_AC_B= false;
  tel

  node AtLeastNTicks(Input1 : bool; N : int32) returns (Output1 : bool)
  var
    cnt : int32;
    _L1 : bool;
    _L2 : int32;
    _L3 : int32;
    _L5 : int32;
    _L6 : int32;
    _L7 : int32;
    _L8 : int32;
    _L10 : int32;
    _L11 : int32;
    _L22 : int32;
    _L23 : int32;
    _L24 : bool;
    _L25 : bool;
    _L32 : bool;
    _L33 : int32;
  let
    _L1= Input1;
    _L2= N;
    Output1= _L25;
    _L3= _L10 #1 + _L6;
    _L5= cnt;
    _L6= (_L8) #2 -> (_L7);
    _L7= #pre5 fby(_L5; 1; 0);
    _L8= 0;
    _L10= 1;
    _L11= #6 if _L1 then (_L3) else (_L8);
    cnt= _L33;
    _L22= N;
    _L23= cnt;
    _L24= _L23 #9 >= _L22;
    _L25= _L24 #10 and _L1;
    _L32= _L11 #11 < _L2;
    _L33= #12 if _L32 then (_L11) else (_L2);
  tel

  node ImpliesWithinNTick(Input1 : bool; Input2 : bool; N : int32)
    returns (Output1 : bool)
  var
    _L5 : bool;
    _L4 : bool;
    _L2 : bool;
    _L1 : bool;
  let
    _L5=
      #1 MTCEx::MTC_Instrumenters::verif_Implies_MTC_INST(_L4, _L1, false, false);
    _L4= #2 AtLeastNTicks(_L2, N);
    Output1= _L5;
    _L2= Input1;
    _L1= Input2;
  tel

  node AfterNthTick<<N>>(Input1 : bool) returns (Output1 : bool)
  var
    _L6 : bool;
    _L5 : bool;
    _L4 : bool;
    _L3 : bool;
    _L2 : bool;
    _L1 : bool;
  let
    _L6= false;
    _L5= true;
    _L4= true;
    _L3= #1 if _L2 then (_L1) else (_L4);
    _L2= #4 fby(_L5; N; _L6);
    Output1= _L3;
    _L1= Input1;
  tel

end;

/* $********** SCADE Suite KCG 64-bit 6.6 (build i19) ***********
** -
** Generation date: 2020-02-07T16:46:45
*************************************************************$ */
